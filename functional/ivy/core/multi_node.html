

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multi node &mdash; Ivy 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Ivy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../why_ivy.html">Why Ivy?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../using_ivy.html">Using Ivy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../training_a_network.html">Training a Network</a></li>
</ul>
<p class="caption"><span class="caption-text">Array</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../array/array_mode_handler.html">Array mode handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/conversions.html">Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/linalg.html">Linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/logic.html">Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/math.html">Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/meta.html">Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/reductions.html">Reductions</a></li>
</ul>
<p class="caption"><span class="caption-text">Functional</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../backends.html">Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../frontends.html">Frontends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ivy.html">Ivy</a></li>
</ul>
<p class="caption"><span class="caption-text">Graph compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/compiler.html">Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/globals.html">Globals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/graph.html">Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/helpers.html">Helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/op_logging.html">Op logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_compiler/param.html">Param</a></li>
</ul>
<p class="caption"><span class="caption-text">Stateful</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/converters.html">Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/initializers.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/module.html">Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/optimizers.html">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/sequential.html">Sequential</a></li>
</ul>
<p class="caption"><span class="caption-text">Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ivy"">Ivy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mech"">Ivy mech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vision"">Ivy vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../robot"">Ivy robot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gym"">Ivy gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory"">Ivy memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../builder"">Ivy builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models"">Ivy models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ecosystem"">Ivy ecosystem</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ivy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li>Multi node</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/functional/ivy/core/multi_node.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ivy.functional.ivy.core.multi_node">
<span id="multi-node"></span><h1>Multi node<a class="headerlink" href="#module-ivy.functional.ivy.core.multi_node" title="Permalink to this headline">¶</a></h1>
<p>Collection of multi-node Ivy functions.</p>
<dl class="py data">
<dt id="ivy.functional.ivy.core.multi_node.split_factors">
<code class="sig-prename descclassname">ivy.</code><code class="sig-name descname">split_factors</code><em class="property"> = {}</em><a class="headerlink" href="#ivy.functional.ivy.core.multi_node.split_factors" title="Permalink to this definition">¶</a></dt>
<dd><p># Node Queries #
# ————-#</p>
<p># Retreival #</p>
<dl>
<dt>def node(x: Union[ivy.Array, ivy.NativeArray])        -&gt; ivy.Node:</dt><dd><p>“””
Get the native node handle for input array x.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>Tensor for which to get the node handle.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>node handle for the array, in native framework format.</p>
</dd>
</dl>
<p>“””
return _cur_framework(x).node(x)</p>
</dd>
<dt>def node_str(x: Union[ivy.Array, ivy.NativeArray])        -&gt; str:</dt><dd><p>“””
Get the node string for input array x.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>Tensor for which to get the node string.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>node string for the array, e.g. ‘cuda:0’, ‘cuda:1’, ‘cpu’ etc..</p>
</dd>
</dl>
<p>“””
return _cur_framework(x).node_str(x)</p>
</dd>
</dl>
<p># Conversions #</p>
<dl>
<dt>def node_to_str(node_in: ivy.Node)        -&gt; str:</dt><dd><p>“””
Convert native data type to string representation.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_in</dt>
<dd class="field-odd"><p>The node handle to convert to string.</p>
</dd>
<dt class="field-even">type node_in</dt>
<dd class="field-even"><p>node handle</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>node string e.g. ‘cuda:0’.</p>
</dd>
</dl>
<p>“””
return _cur_framework(None).node_to_str(node_in)</p>
</dd>
</dl>
<p># noinspection PyShadowingNames
def str_to_node(node_str: str)        -&gt; ivy.Node:</p>
<blockquote>
<div><p>“””
Convert node string representation to native node type.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node string to conver to native node handle.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>Native node handle.</p>
</dd>
</dl>
<p>“””
return _cur_framework(None).str_to_node(node_str)</p>
</div></blockquote>
<p># Memory #</p>
<p># noinspection PyShadowingNames
def total_mem_on_node(node_str: str)        -&gt; float:</p>
<blockquote>
<div><p>“””
Get the total amount of memory (in GB) for a given node string. In case of CPU, the total RAM is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node string to conver to native node handle.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The total memory on the node in GB.</p>
</dd>
</dl>
<p>“””
raise NotImplementedError</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def used_mem_on_node(node_str: str, process_specific=False)        -&gt; float:</p>
<blockquote>
<div><p>“””
Get the used memory (in GB) for a given node string. In case of CPU, the used RAM is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node string to conver to native node handle.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param process_specific</dt>
<dd class="field-odd"><p>Whether the check the memory used by this python process alone. Default is False.</p>
</dd>
<dt class="field-even">type process_specific</dt>
<dd class="field-even"><p>bool, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The used memory on the node in GB.</p>
</dd>
</dl>
<p>“””
raise NotImplementedError</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def percent_used_mem_on_node(node_str: str, process_specific=False)        -&gt; float:</p>
<blockquote>
<div><p>“””
Get the percentage used memory for a given node string. In case of CPU, the used RAM is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node string to conver to native node handle.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param process_specific</dt>
<dd class="field-odd"><p>Whether the check the memory used by this python process alone. Default is False.</p>
</dd>
<dt class="field-even">type process_specific</dt>
<dd class="field-even"><p>bool, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The percentage used memory on the node.</p>
</dd>
</dl>
<p>“””
raise NotImplementedError</p>
</div></blockquote>
<p># Utilization #</p>
<p># noinspection PyShadowingNames
def node_util(node_str: str)        -&gt; float:</p>
<blockquote>
<div><p>“””
Get the current utilization (%) for a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node string of the node to query utilization for.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The node utilization (%)</p>
</dd>
</dl>
<p>“””
raise NotImplementedError</p>
</div></blockquote>
<p># Availability #</p>
<dl>
<dt>def gpu_is_available()        -&gt; bool:</dt><dd><p>“””
Determine whether a GPU is available to use, with the backend framework.</p>
<dl class="field-list simple">
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>Boolean, as to whether a gpu is available.</p>
</dd>
</dl>
<p>“””
return _cur_framework().gpu_is_available()</p>
</dd>
<dt>def num_gpus()        -&gt; int:</dt><dd><p>“””
Determine the number of available GPUs, with the backend framework.</p>
<dl class="field-list simple">
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>Number of available GPUs.</p>
</dd>
</dl>
<p>“””
return _cur_framework().num_gpus()</p>
</dd>
<dt>def tpu_is_available()        -&gt; bool:</dt><dd><p>“””
Determine whether a TPU is available to use, with the backend framework.</p>
<dl class="field-list simple">
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>Boolean, as to whether a tpu is available.</p>
</dd>
</dl>
<p>“””
return _cur_framework().tpu_is_available()</p>
</dd>
</dl>
<p># Default node #
# —————#</p>
<dl>
<dt>def default_node():</dt><dd><p>“””
Return the default node.
“””
global DEFAULT_NODE
if not ivy.exists(DEFAULT_NODE):</p>
<blockquote>
<div><p>DEFAULT_NODE = ‘gpu:0’ if ivy.gpu_is_available() else ‘cpu’</p>
</div></blockquote>
<p>return DEFAULT_NODE</p>
</dd>
<dt>def set_default_node(node):</dt><dd><p>assert node[0:3] in [‘gpu’, ‘tpu’, ‘cpu’]
if node != ‘cpu’:</p>
<blockquote>
<div><p>assert node[3] == ‘:’
assert node[4:].isnumeric()</p>
</div></blockquote>
<p>global DEFAULT_NODE
DEFAULT_NODE = node</p>
</dd>
</dl>
<p># node Allocation #
# ——————#</p>
<p># noinspection PyShadowingNames
def to_node(x: Union[ivy.Array, ivy.NativeArray], node_str: str = None)        -&gt; Union[ivy.Array, ivy.NativeArray]:</p>
<blockquote>
<div><p>“””
Move the input array x to the desired node, specified by node string.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>Array to move onto the node.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>node to move the array to ‘cuda:0’, ‘cuda:1’, ‘cpu’ etc. Keep same node if None.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The array x, but now placed on the target node.</p>
</dd>
</dl>
<p>“””
return _cur_framework(x).to_node(x, node_str)</p>
</div></blockquote>
<p># Function Splitting #
# ——————-#</p>
<p># noinspection PyShadowingNames
def split_factor(node_str=None):</p>
<blockquote>
<div><p>“””
Get the global split factor for a given node, which can be used to scale batch splitting chunk sizes for the
node across the codebase. Default global value for each node is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to query the split factor for. Sets the default node by default.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The split factor for the specified node.</p>
</dd>
</dl>
<p>“””
global SPLIT_FACTORS
node_str = ivy.default(node_str, default_node())
if node_str in SPLIT_FACTORS:</p>
<blockquote>
<div><p>return SPLIT_FACTORS[node_str]</p>
</div></blockquote>
<p>SPLIT_FACTORS[node_str] = 0.
return SPLIT_FACTORS[node_str]</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def set_split_factor(factor, node_str=None):</p>
<blockquote>
<div><p>“””
Set the global split factor for a given node, which can be used to scale batch splitting chunk sizes for the
node across the codebase.</p>
<dl class="field-list simple">
<dt class="field-odd">param factor</dt>
<dd class="field-odd"><p>The factor to set the node-specific split factor to.</p>
</dd>
<dt class="field-even">type factor</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to set the split factor for. Sets the default node by default.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str, optional</p>
</dd>
</dl>
<p>“””
assert 0 &lt;= factor
global SPLIT_FACTORS
node_str = ivy.default(node_str, default_node())
SPLIT_FACTORS[node_str] = factor</p>
</div></blockquote>
<dl>
<dt>def split_func_call(func: Callable, inputs: Iterable[Union[Union[ivy.Array, ivy.NativeArray], ivy.Container]],</dt><dd><blockquote>
<div><p>mode: str, max_chunk_size: int = None, chunk_size: int = None,
input_axes: Union[int, Iterable[int]] = 0, output_axes: Union[int, Iterable[int]] = None)        -&gt; Iterable[Union[Union[ivy.Array, ivy.NativeArray], ivy.Container]]:</p>
</div></blockquote>
<p>“””
Call a function by splitting its inputs along a given axis, and calling the function in chunks, rather than feeding
the entire input array at once. This can be useful to reduce memory usage of the node the arrays are on.
:param func: The function to be called.
:type func: callable
:param inputs: A list of inputs to pass into the function.
:type inputs: sequence of arrays
:param mode: The mode by which to unify the return values, must be one of [ concat | mean | sum ]
:type mode: str
:param max_chunk_size: The maximum size of each of the chunks to be fed into the function.
:type max_chunk_size: int
:param chunk_size: The size of each of the chunks to be fed into the function. Specifying this arg overwrites the</p>
<blockquote>
<div><p>global split factor. Default is None.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">type chunk_size</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
<dt class="field-even">param input_axes</dt>
<dd class="field-even"><p>The axes along which to split each of the inputs, before passing to the function. Default is 0.</p>
</dd>
<dt class="field-odd">type input_axes</dt>
<dd class="field-odd"><p>int or sequence of ints, optional</p>
</dd>
<dt class="field-even">param output_axes</dt>
<dd class="field-even"><p>The axes along which to concat each of the returned outputs. Default is same as fist input axis.</p>
</dd>
<dt class="field-odd">type output_axes</dt>
<dd class="field-odd"><p>int or sequence of ints, optional</p>
</dd>
<dt class="field-even">return</dt>
<dd class="field-even"><p>The return from the function, following input splitting and re-concattenation.</p>
</dd>
</dl>
<p>“””
if not ivy.exists(max_chunk_size) and not ivy.exists(chunk_size):</p>
<blockquote>
<div><p>raise Exception(‘Either max_chunk_size or chunk_size must be specified, but neither were provided.’)</p>
</div></blockquote>
<dl class="simple">
<dt>if isinstance(input_axes, int):</dt><dd><p>input_axes = [input_axes]*len(inputs)</p>
</dd>
<dt>chunk_size = ivy.default(</dt><dd><p>chunk_size, lambda: max(int(round(max_chunk_size * ivy.split_factor(ivy.default_node()))), 1), True)</p>
</dd>
</dl>
<p>dim_size = inputs[0].shape[input_axes[0]]
if chunk_size &gt;= dim_size:</p>
<blockquote>
<div><p>return func(<a href="#id1"><span class="problematic" id="id2">*</span></a>inputs)</p>
</div></blockquote>
<p>num_chunks = dim_size / chunk_size
num_chunks_floored = math.floor(dim_size / chunk_size)
chunk_sizes = [chunk_size] * num_chunks_floored
if num_chunks != num_chunks_floored:</p>
<blockquote>
<div><p>chunk_sizes.append(dim_size - chunk_size * num_chunks_floored)</p>
</div></blockquote>
<dl class="simple">
<dt>inputs_split = [ivy.split(inp, chunk_sizes, input_axes[i], True) if ivy.is_array(inp)</dt><dd><p>else inp.split(chunk_sizes, input_axes[i], True) for i, inp in enumerate(inputs)]</p>
</dd>
</dl>
<p>rets = [func(<a href="#id3"><span class="problematic" id="id4">*</span></a>i) for i in zip(<a href="#id5"><span class="problematic" id="id6">*</span></a>inputs_split)]
rets = [ret if isinstance(ret, tuple) else (ret,) for ret in rets]
num_outputs = len(rets[0])
if output_axes is None:</p>
<blockquote>
<div><p>output_axes = [input_axes[0]] * num_outputs</p>
</div></blockquote>
<dl class="simple">
<dt>elif isinstance(output_axes, int):</dt><dd><p>output_axes = [output_axes] * num_outputs</p>
</dd>
</dl>
<p>is_mean = mode == ‘mean’
is_sum = mode == ‘sum’
if is_mean or is_sum:</p>
<blockquote>
<div><dl class="simple">
<dt>rets = [[(r.expand_dims(output_axis) if isinstance(r, ivy.Container) else ivy.expand_dims(r, output_axis)) * cs</dt><dd><p>for output_axis, r in zip(output_axes, ret)] for ret, cs in zip(rets, chunk_sizes)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>concatted = [ivy.concatenate([r[i] for r in rets], output_axes[i]) if ivy.is_array(rets[0][i])</dt><dd><p>else ivy.Container.concat([r[i] for r in rets], output_axes[i])
for i in range(num_outputs)]</p>
</dd>
<dt>if is_mean:</dt><dd><dl>
<dt>ret = [(item.reduce_sum(output_axis) if isinstance(item, ivy.Container)</dt><dd><blockquote>
<div><p>else ivy.reduce_sum(item, output_axis))/sum(chunk_sizes)</p>
</div></blockquote>
<p>for item, output_axis in zip(concatted, output_axes)]</p>
</dd>
</dl>
</dd>
<dt>elif is_sum:</dt><dd><dl class="simple">
<dt>ret = [(item.reduce_sum(output_axis) if isinstance(item, ivy.Container)</dt><dd><p>else ivy.reduce_sum(item, output_axis)) for item, output_axis in zip(concatted, output_axes)]</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><p>ret = concatted</p>
</dd>
</dl>
<p>return ret[0] if len(ret) == 1 else ret</p>
</dd>
</dl>
<p># Multi-Node #
# ———–#</p>
<p>class MultiNode:</p>
<blockquote>
<div><dl>
<dt>def __init__(self, data: Iterable, axis=0):</dt><dd><dl class="simple">
<dt>if isinstance(data, MultiNode):</dt><dd><p># noinspection PyUnresolvedReferences,PyProtectedMember
data = data._dict</p>
</dd>
</dl>
<p>self._axis = axis
self._data = data
self._length = len(data)
self._counter = 0</p>
</dd>
<dt>def __len__(self):</dt><dd><p>return self._length</p>
</dd>
<dt>def __repr__(self):</dt><dd><p>return ‘MultiNode(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class MultiNodeItem(MultiNode):</p>
<blockquote>
<div><dl class="simple">
<dt>def __init__(self, data: Dict[ivy.Node, Any], axis=0):</dt><dd><p>super().__init__(data, axis)</p>
</dd>
</dl>
<p>&#64;property
def shape(self):</p>
<blockquote>
<div><p>shapes = [list(x.shape) if hasattr(x, ‘shape’) else None for x in self._data.values()]
if not shapes or None in shapes:</p>
<blockquote>
<div><p>return None</p>
</div></blockquote>
<p>shape0 = shapes[0]
for shp in shapes[1:]:</p>
<blockquote>
<div><p>assert shp == shape0</p>
</div></blockquote>
<p>shape0[self._axis] = shape0[self._axis]*len(self)
return tuple(shape0)</p>
</div></blockquote>
<dl>
<dt>def _slice(self, slice_obj: slice):</dt><dd><p>stacked_dim_size = 0
ret_dict = dict()
for ns, sub_item in self._data.items():</p>
<blockquote>
<div><dl class="simple">
<dt>if not hasattr(sub_item, ‘shape’):</dt><dd><p>continue</p>
</dd>
</dl>
<p>shp = sub_item.shape
rel_slice_obj = slice(slice_obj.start-stacked_dim_size, slice_obj.stop-stacked_dim_size, 1)
stacked_dim_size += shp[self._axis]
if slice_obj.start &lt; stacked_dim_size:</p>
<blockquote>
<div><dl class="simple">
<dt>if slice_obj.stop &lt; stacked_dim_size:</dt><dd><p>ret_dict[ns] = sub_item[rel_slice_obj]
return MultiNodeItem(ret_dict)</p>
</dd>
<dt>else:</dt><dd><p>ret_dict[ns] = sub_item[rel_slice_obj.start:]</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>return MultiNodeItem(ret_dict)</p>
</dd>
<dt>def __getitem__(self, query):</dt><dd><dl class="simple">
<dt>if isinstance(query, str):</dt><dd><p>return self._data[query]</p>
</dd>
<dt>elif isinstance(query, int):</dt><dd><p>return self._slice(slice(query, query+1, 1))</p>
</dd>
<dt>elif isinstance(query, slice):</dt><dd><p>return self._slice(query)</p>
</dd>
</dl>
</dd>
<dt>def keys(self):</dt><dd><p>return self._data.keys()</p>
</dd>
<dt>def values(self):</dt><dd><p>return self._data.values()</p>
</dd>
<dt>def items(self):</dt><dd><p>return self._data.items()</p>
</dd>
<dt>def __repr__(self):</dt><dd><p>return ‘MultiNodeItem(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class MultiNodeIter(MultiNode):</p>
<blockquote>
<div><dl class="simple">
<dt>def __init__(self, data: Iterable, node_strs):</dt><dd><p>self._node_strs = node_strs
super().__init__(data)</p>
</dd>
</dl>
<p># noinspection PyShadowingNames
def at_node(self, node_str):</p>
<blockquote>
<div><p>return [x[node_str] if isinstance(x, MultiNodeItem) else x for x in self._data]</p>
</div></blockquote>
<dl>
<dt>def at_nodes(self):</dt><dd><p>return {ns: self.at_node(ns) for ns in self._node_strs}</p>
</dd>
<dt>def __getitem__(self, item):</dt><dd><p>return self._data[item]</p>
</dd>
<dt>def __iter__(self):</dt><dd><p>self._counter = 0
return self</p>
</dd>
<dt>def __next__(self):</dt><dd><dl class="simple">
<dt>if self._counter == self._length:</dt><dd><p>raise StopIteration</p>
</dd>
</dl>
<p>ret = self.__getitem__(self._counter)
self._counter += 1
return ret</p>
</dd>
<dt>def __repr__(self):</dt><dd><p>return ‘MultiNodeIter(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class MultiNodeNest(MultiNodeIter):</p>
<blockquote>
<div><dl class="simple">
<dt>def __init__(self, data: Iterable, node_strs, max_depth=1):</dt><dd><p>self._max_depth = max_depth
super().__init__(data, node_strs)</p>
</dd>
</dl>
<p># noinspection PyShadowingNames
def at_node(self, node_str):</p>
<blockquote>
<div><dl class="simple">
<dt>return ivy.nested_map(self._data, lambda x: x[node_str] if isinstance(x, MultiNodeItem) else x,</dt><dd><p>max_depth=self._max_depth)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘MultiNodeNest(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p># Node Distribution #
# ——————#</p>
<p>class NodeDistItem(MultiNodeItem):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘NodeDistItem(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class NodeDistIter(MultiNodeIter):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘NodeDistIter(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class NodeDistNest(MultiNodeNest):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘NodeDistNest(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def node_dist_array(x, node_strs: Union[Iterable[str], Dict[str, int]], axis=0):</dt><dd><p>“””
Distribute an array across the specified nodes, returning a list of sub-arrays, each on a different node.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>The array to distribute across nodes.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to distribute the array across.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs or dict of split sizes</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to split the array. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array distributed across the target nodes</p>
</dd>
</dl>
<p>“””
split_arg = list(node_strs.values()) if isinstance(node_strs, dict) else len(node_strs)
return NodeDistItem(</p>
<blockquote>
<div><dl class="simple">
<dt>{ns: ivy.to_node(x_sub, ns) for x_sub, ns in zip(ivy.split(x, split_arg, axis, with_remainder=True),</dt><dd><p>node_strs)})</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def node_dist(x, node_strs: Union[Iterable[str], Dict[str, int]], axis=0):</dt><dd><p>“””
Distribute the input item across the specified nodes, returning a list of sub-items, each on a different node.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>The input array or container to distribute across nodes.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array or container</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to distribute the input across.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs or dict of split sizes</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to split the input. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array or container distributed across the target nodes</p>
</dd>
</dl>
<p>“””
if ivy.is_array(x):</p>
<blockquote>
<div><p>return node_dist_array(x, node_strs, axis)</p>
</div></blockquote>
<dl class="simple">
<dt>elif isinstance(x, ivy.Container):</dt><dd><p>return x.node_dist(node_strs, axis)</p>
</dd>
</dl>
<p>return x</p>
</dd>
<dt>def node_dist_iter(xs, node_strs: Union[Iterable[str], Dict[str, int]], axis=0):</dt><dd><p>“””
Distribute elements of the iterbale xs across the specified nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">param xs</dt>
<dd class="field-odd"><p>The iterable of items to distribute.</p>
</dd>
<dt class="field-even">type xs</dt>
<dd class="field-even"><p>iterable of any</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to distribute the iterable elements across.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs or dict of split sizes</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to split the arrays in the iterable xs. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>iterable with each element distributed to the target nodes</p>
</dd>
</dl>
<p>“””
if isinstance(node_strs, str):</p>
<blockquote>
<div><p>node_strs = [node_strs]</p>
</div></blockquote>
<p>return NodeDistIter([node_dist(x, node_strs, axis) for x in xs], node_strs)</p>
</dd>
<dt>def distribute_nest(args, kwargs, node_strs: Union[Iterable[str], Dict[str, int]], axis=0, max_depth=1):</dt><dd><p>“””
Distribute the nested input arguments across the specified nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">param args</dt>
<dd class="field-odd"><p>The positional nested arguments to distribute.</p>
</dd>
<dt class="field-even">type args</dt>
<dd class="field-even"><p>list of any</p>
</dd>
<dt class="field-odd">param kwargs</dt>
<dd class="field-odd"><p>The keyword nested arguments to distribute.</p>
</dd>
<dt class="field-even">type kwargs</dt>
<dd class="field-even"><p>dict of any</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to distribute the nested arguments across.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs or dict of split sizes</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to split the arrays in the arguments. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param max_depth</dt>
<dd class="field-odd"><p>The maximum nested depth to reach. Default is 1. Increase this if the nest is deeper.</p>
</dd>
<dt class="field-even">type max_depth</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>nested arguments distributed to the target nodes</p>
</dd>
</dl>
<p>“””
if isinstance(node_strs, str):</p>
<blockquote>
<div><p>node_strs = [node_strs]</p>
</div></blockquote>
<p>args_dist = ivy.nested_map(args, lambda x: node_dist(x, node_strs, axis), max_depth=max_depth)
kwargs_dist = ivy.nested_map(kwargs, lambda x: node_dist(x, node_strs, axis), max_depth=max_depth)
return NodeDistNest(args_dist, node_strs), NodeDistNest(kwargs_dist, node_strs)</p>
</dd>
</dl>
<p># Node Cloning #
# ————-#</p>
<p>class ClonedItem(MultiNodeItem):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘ClonedItem(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class ClonedIter(MultiNodeIter):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘ClonedIter(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<p>class ClonedNest(MultiNodeNest):</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return ‘ClonedNest(‘ + self._data.__repr__() + ‘)’</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def clone_array(x, node_strs):</dt><dd><p>“””
Clone an array across the specified nodes, returning a list of cloned arrays, each on a different node.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>The array to clone across nodes.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to clone the array to.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array cloned to each of the target nodes</p>
</dd>
</dl>
<p>“””
return ClonedItem({ns: ivy.stop_gradient(ivy.to_node(x, ns)) for ns in node_strs})</p>
</dd>
<dt>def clone(x, node_strs):</dt><dd><p>“””
Clone the input item to each of the specified nodes, returning a list of cloned items, each on a different node.</p>
<dl class="field-list simple">
<dt class="field-odd">param x</dt>
<dd class="field-odd"><p>The input array or container to clone to each node.</p>
</dd>
<dt class="field-even">type x</dt>
<dd class="field-even"><p>array or container</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to clone the input to.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array or container distributed across the target nodes</p>
</dd>
</dl>
<p>“””
if ivy.is_array(x):</p>
<blockquote>
<div><p>return clone_array(x, node_strs)</p>
</div></blockquote>
<dl class="simple">
<dt>elif isinstance(x, ivy.Container):</dt><dd><p>return x.node_clone(node_strs)</p>
</dd>
</dl>
<p>return x</p>
</dd>
<dt>def clone_iter(xs, node_strs):</dt><dd><p>“””
Clone elements of the iterbale xs to each of the specified nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">param xs</dt>
<dd class="field-odd"><p>The iterable of items to clone.</p>
</dd>
<dt class="field-even">type xs</dt>
<dd class="field-even"><p>iterable of any</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to clone each of the iterable elements to.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>iterable with each element cloned to each of the target nodes</p>
</dd>
</dl>
<p>“””
if isinstance(node_strs, str):</p>
<blockquote>
<div><p>node_strs = [node_strs]</p>
</div></blockquote>
<p>return ClonedIter([clone(x, node_strs) for x in xs], node_strs)</p>
</dd>
<dt>def clone_nest(args, kwargs, node_strs, max_depth=1):</dt><dd><p>“””
Clone the input arguments across the specified nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">param args</dt>
<dd class="field-odd"><p>The positional arguments to clone.</p>
</dd>
<dt class="field-even">type args</dt>
<dd class="field-even"><p>list of any</p>
</dd>
<dt class="field-odd">param kwargs</dt>
<dd class="field-odd"><p>The keyword arguments to clone.</p>
</dd>
<dt class="field-even">type kwargs</dt>
<dd class="field-even"><p>dict of any</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to clone the arguments to.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs</p>
</dd>
<dt class="field-odd">param max_depth</dt>
<dd class="field-odd"><p>The maximum nested depth to reach. Default is 1. Increase this if the nest is deeper.</p>
</dd>
<dt class="field-even">type max_depth</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>arguments cloned to each of the target nodes</p>
</dd>
</dl>
<p>“””
if isinstance(node_strs, str):</p>
<blockquote>
<div><p>node_strs = [node_strs]</p>
</div></blockquote>
<p>args_cloned = ivy.nested_map(args, lambda x: clone(x, node_strs), max_depth=max_depth)
kwargs_cloned = ivy.nested_map(kwargs, lambda x: clone(x, node_strs), max_depth=max_depth)
return ClonedNest(args_cloned, node_strs), ClonedNest(kwargs_cloned, node_strs)</p>
</dd>
</dl>
<p># Node Unification #
# —————–#</p>
<p># noinspection PyShadowingNames
def _concat_unify_array(xs, node_str, axis):</p>
<blockquote>
<div><p>return ivy.concatenate([ivy.to_node(x_sub, node_str) for x_sub in xs.values()], axis)</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def _sum_unify_array(xs, node_str, _=None):</p>
<blockquote>
<div><p>return sum([ivy.to_node(x_sub, node_str) for x_sub in xs.values()])</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def _mean_unify_array(xs, node_str, _=None):</p>
<blockquote>
<div><p>return _sum_unify_array(xs, node_str) / len(xs)</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def unify_array(xs, node_str, mode, axis=0):</p>
<blockquote>
<div><p>“””
Unify a list of sub-arrays, on arbitrary nodes, to a single array on the specified node.</p>
<dl class="field-list simple">
<dt class="field-odd">param xs</dt>
<dd class="field-odd"><p>The list of arrays to unify onto the specified node.</p>
</dd>
<dt class="field-even">type xs</dt>
<dd class="field-even"><p>sequence of arrays</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to unify the arrays to.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param mode</dt>
<dd class="field-odd"><p>The mode by which to unify, must be one of [ concat | mean | sum ]</p>
</dd>
<dt class="field-even">type mode</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to concattenate the array, if concat mode is set. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array unified to the target node</p>
</dd>
</dl>
<p>“””
return {‘concat’: _concat_unify_array,</p>
<blockquote>
<div><p>‘sum’: _sum_unify_array,
‘mean’: _mean_unify_array}[mode](xs, node_str, axis)</p>
</div></blockquote>
</div></blockquote>
<p># noinspection PyShadowingNames
def unify(xs, node_str, mode, axis=0):</p>
<blockquote>
<div><p>“””
Unify a list of sub-arrays, on arbitrary nodes, to a single concattenated array on the specified node.</p>
<dl class="field-list simple">
<dt class="field-odd">param xs</dt>
<dd class="field-odd"><p>The list of sub-arrays to unify onto the specified node.</p>
</dd>
<dt class="field-even">type xs</dt>
<dd class="field-even"><p>sequence of arrays</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to unify the sub-arrays to.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param mode</dt>
<dd class="field-odd"><p>The mode by which to unify, must be one of [ concat | mean | sum ]</p>
</dd>
<dt class="field-even">type mode</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to concattenate the array, if concat mode is set. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>array unified to the target node</p>
</dd>
</dl>
<p>“””
if isinstance(xs, ivy.MultiNodeContainer):</p>
<blockquote>
<div><p>xs = MultiNodeItem(xs.at_nodes())</p>
</div></blockquote>
<dl class="simple">
<dt>elif not isinstance(xs, MultiNodeItem):</dt><dd><p>return xs</p>
</dd>
</dl>
<p># noinspection PyProtectedMember
xs0 = next(iter(xs.items()))[1]
if ivy.is_array(xs0):</p>
<blockquote>
<div><p>return unify_array(xs, node_str, mode, axis)</p>
</div></blockquote>
<dl class="simple">
<dt>elif isinstance(xs0, ivy.Container):</dt><dd><p>return ivy.Container.unify(xs, node_str, mode, axis)</p>
</dd>
</dl>
<p>return xs</p>
</div></blockquote>
<p># noinspection PyShadowingNames
def unify_iter(xs, node_str, mode, axis=0, transpose=False):</p>
<blockquote>
<div><p>“””
Unify elements of the iterbale xs to a single target node.</p>
<dl class="field-list simple">
<dt class="field-odd">param xs</dt>
<dd class="field-odd"><p>The iterable of items to unify.</p>
</dd>
<dt class="field-even">type xs</dt>
<dd class="field-even"><p>iterable of any</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to unify the elements of the iterable to.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param mode</dt>
<dd class="field-odd"><p>The mode by which to unify, must be one of [ concat | mean | sum ]</p>
</dd>
<dt class="field-even">type mode</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to concattenate the sub-arrays. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param transpose</dt>
<dd class="field-odd"><p>Whether to transpose the first and second dimensions of the iterator. Default is False.</p>
</dd>
<dt class="field-even">type transpose</dt>
<dd class="field-even"><p>bool, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>iterable with each element unified to a single target nodes</p>
</dd>
</dl>
<p>“””
# noinspection PyProtectedMember
xs = xs._data if isinstance(xs, MultiNodeIter) else xs
if transpose:</p>
<blockquote>
<div><p># ToDo: make this more elegant, this method should not be responsible for transposing iterators
xs_t = [MultiNodeItem({ivy.node_str(i) if ivy.is_array(i) else i.node_str: i</p>
<blockquote>
<div><p>for i in mdi}) for mdi in list(map(list, zip(<a href="#id7"><span class="problematic" id="id8">*</span></a>xs)))]</p>
</div></blockquote>
<p>return [unify(x, node_str, mode, axis) for x in xs_t]</p>
</div></blockquote>
<p>return unify(xs, node_str, mode, axis)</p>
</div></blockquote>
<p># noinspection PyShadowingNames,PyProtectedMember
def unify_nest(args: Type[MultiNode], kwargs: Type[MultiNode], node_str, mode, axis=0, max_depth=1):</p>
<blockquote>
<div><p>“””
Unify the input nested arguments, which consist of sub-arrays spread across arbitrary nodes, to unified arrays
on the single target node.</p>
<dl class="field-list simple">
<dt class="field-odd">param args</dt>
<dd class="field-odd"><p>The nested positional arguments to unify.</p>
</dd>
<dt class="field-even">type args</dt>
<dd class="field-even"><p>MultiNode</p>
</dd>
<dt class="field-odd">param kwargs</dt>
<dd class="field-odd"><p>The nested keyword arguments to unify.</p>
</dd>
<dt class="field-even">type kwargs</dt>
<dd class="field-even"><p>MultiNode</p>
</dd>
<dt class="field-odd">param node_str</dt>
<dd class="field-odd"><p>The node to unify the nested arguments to.</p>
</dd>
<dt class="field-even">type node_str</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param mode</dt>
<dd class="field-odd"><p>The mode by which to unify, must be one of [ concat | mean | sum ]</p>
</dd>
<dt class="field-even">type mode</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param axis</dt>
<dd class="field-odd"><p>The axis along which to concattenate the sub-arrays. Default is 0.</p>
</dd>
<dt class="field-even">type axis</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param max_depth</dt>
<dd class="field-odd"><p>The maximum nested depth to reach. Default is 1. Increase this if the nest is deeper.</p>
</dd>
<dt class="field-even">type max_depth</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>nested arguments unified to the target node</p>
</dd>
</dl>
<p>“””
args = args._data if isinstance(args, MultiNodeIter) else args
kwargs = kwargs._data if isinstance(kwargs, MultiNodeIter) else kwargs
args_uni = ivy.nested_map(args, lambda x: unify(x, node_str, mode, axis), max_depth=max_depth)
kwargs_uni = ivy.nested_map(kwargs, lambda x: unify(x, node_str, mode, axis), max_depth=max_depth)
return args_uni, kwargs_uni</p>
</div></blockquote>
<p># Node Mappers #
# ————-#</p>
<p>class NodeMapper(abc.ABC):</p>
<blockquote>
<div><dl>
<dt>def __init__(self, fn, ret_fn, queue_class, worker_class, node_strs, timeout=None, constant=None, unique=None):</dt><dd><p>“””
Node Mapper base class.</p>
<dl class="field-list simple">
<dt class="field-odd">param fn</dt>
<dd class="field-odd"><p>The function which the node mapper parallelises across nodes.</p>
</dd>
<dt class="field-even">type fn</dt>
<dd class="field-even"><p>callable</p>
</dd>
<dt class="field-odd">param ret_fn</dt>
<dd class="field-odd"><p>The function which receives the ivy.MultiNodeIter as input, and produces a single node output.</p>
</dd>
<dt class="field-even">type ret_fn</dt>
<dd class="field-even"><p>callable</p>
</dd>
<dt class="field-odd">param queue_class</dt>
<dd class="field-odd"><p>The class to use for creating queues.</p>
</dd>
<dt class="field-even">type queue_class</dt>
<dd class="field-even"><p>class</p>
</dd>
<dt class="field-odd">param worker_class</dt>
<dd class="field-odd"><p>The class to use for creating parallel workers.</p>
</dd>
<dt class="field-even">type worker_class</dt>
<dd class="field-even"><p>class</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>A list of nodes on which to parallelise the function.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of str</p>
</dd>
<dt class="field-odd">param timeout</dt>
<dd class="field-odd"><p>The timeout for getting items from the queues. Default is global.</p>
</dd>
<dt class="field-even">type timeout</dt>
<dd class="field-even"><p>float, optional</p>
</dd>
<dt class="field-odd">param constant</dt>
<dd class="field-odd"><p>A dict of keyword arguments which are the same for each process. Default is None.</p>
</dd>
<dt class="field-even">type constant</dt>
<dd class="field-even"><p>dict of any, optional</p>
</dd>
<dt class="field-odd">param unique</dt>
<dd class="field-odd"><p>A dict of keyword argument sequences which are unique for each process. Default is None.</p>
</dd>
<dt class="field-even">type unique</dt>
<dd class="field-even"><p>dict of iterables of any, optional</p>
</dd>
</dl>
<p>“””
constant_kwargs = ivy.default(constant, {})
unique_kwargs = ivy.default(unique, {})
self._fn = fn
self._ret_fn = ret_fn
self._node_strs = node_strs
self._num_workers = len(node_strs)
self._timeout = ivy.default(timeout, ivy.queue_timeout())
self._workers = dict()
self._input_queues = dict()
self._output_queues = dict()
self._worker_class = worker_class
for i, ns in enumerate(self._node_strs):</p>
<blockquote>
<div><p>input_queue = queue_class()
output_queue = queue_class()
worker_kwargs = dict(<a href="#id9"><span class="problematic" id="id10">**</span></a>constant_kwargs, <a href="#id11"><span class="problematic" id="id12">**</span></a>{k: v[i] for k, v in unique_kwargs.items()})
worker = self._worker_class(target=self._worker_fn, args=(input_queue, output_queue, node_strs[i],</p>
<blockquote>
<div><p>worker_kwargs, ivy.current_framework_str()))</p>
</div></blockquote>
<p>worker.start()
self._input_queues[ns] = input_queue
self._output_queues[ns] = output_queue
self._workers[ns] = worker</p>
</div></blockquote>
</dd>
<dt>def __getstate__(self):</dt><dd><p># prevent already running processes from being pickled as sent to new processes
state = self.__dict__.copy()
state[‘_workers’] = None
state[‘_ret_fn’] = None
return state</p>
</dd>
</dl>
<p># noinspection PyShadowingNames
def _worker_fn(self, input_queue, output_queue, node_str, kwargs, framework_str):</p>
<blockquote>
<div><p>ivy.set_framework(framework_str)
ivy.set_default_node(node_str)
for k, v in kwargs.items():</p>
<blockquote>
<div><dl class="simple">
<dt>if isinstance(v, ivy.Module) and not v.built:</dt><dd><p>v.build(node_str=node_str)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>if ‘node_str’ in inspect.getfullargspec(self._fn).args:</dt><dd><p>kwargs[‘node_str’] = node_str</p>
</dd>
<dt>while True:</dt><dd><dl class="simple">
<dt>try:</dt><dd><p>loaded_kwargs = input_queue.get(timeout=self._timeout)</p>
</dd>
<dt>except queue.Empty:</dt><dd><p>continue</p>
</dd>
<dt>if loaded_kwargs is None:</dt><dd><p>return</p>
</dd>
<dt>if ‘split_factor’ in loaded_kwargs:</dt><dd><p>ivy.set_split_factor(loaded_kwargs[‘split_factor’], node_str)
del loaded_kwargs[‘split_factor’]</p>
</dd>
</dl>
<p>ret = self._fn(<a href="#id13"><span class="problematic" id="id14">**</span></a>loaded_kwargs, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs)
output_queue.put(ret)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def map(self, used_node_strs=None, split_factors=None, <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs):</dt><dd><p>“””
Map the function fn to each of the MultiNode args and kwargs, running each function in parallel with CUDA-safe
multiprocessing.</p>
<dl class="field-list simple">
<dt class="field-odd">param used_node_strs</dt>
<dd class="field-odd"><p>The nodes used in the current mapping pass. Default is all node_strs.</p>
</dd>
<dt class="field-even">type used_node_strs</dt>
<dd class="field-even"><p>sequence of str, optional</p>
</dd>
<dt class="field-odd">param split_factors</dt>
<dd class="field-odd"><p>The updated split factors 0 &lt; sf &lt; 1 for each node. Default is None.</p>
</dd>
<dt class="field-even">type split_factors</dt>
<dd class="field-even"><p>dict of floats, optional</p>
</dd>
<dt class="field-odd">param kwargs</dt>
<dd class="field-odd"><p>The MultiNode keyword arguments to map the function to.</p>
</dd>
<dt class="field-even">type kwargs</dt>
<dd class="field-even"><p>dict of any</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The results of the function, returned as a MultiNode instance.</p>
</dd>
</dl>
<p>“””
if ivy.exists(split_factors):</p>
<blockquote>
<div><p>kwargs[‘split_factor’] = split_factors</p>
</div></blockquote>
<p>used_node_strs = ivy.default(used_node_strs, self._node_strs)
[self._input_queues[ns].put({k: v[ns] for k, v in kwargs.items()}) for ns in used_node_strs]
return self._ret_fn(</p>
<blockquote>
<div><dl class="simple">
<dt>ivy.MultiNodeIter([self._output_queues[ns].get(timeout=self._timeout) for ns in used_node_strs],</dt><dd><p>self._num_workers))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>&#64;abc.abstractmethod
def __del__(self):</p>
<blockquote>
<div><p>raise NotImplementedError</p>
</div></blockquote>
</div></blockquote>
<p>class NodeMapperMultiProc(NodeMapper):</p>
<blockquote>
<div><dl>
<dt>def __init__(self, fn, ret_fn, node_strs, timeout=None, constant=None, unique=None):</dt><dd><p>multiprocessing = ivy.multiprocessing(‘forkserver’)
super().__init__(fn, ret_fn, multiprocessing.Queue, multiprocessing.Process, node_strs, timeout,</p>
<blockquote>
<div><p>constant, unique)</p>
</div></blockquote>
</dd>
<dt>def __del__(self):</dt><dd><p># noinspection PyBroadException
try:</p>
<blockquote>
<div><dl class="simple">
<dt>for i, w in enumerate(self._workers.values()):</dt><dd><p>self._input_queues[i].put(None)
w.join(timeout=0.25)</p>
</dd>
<dt>for q in self._input_queues.values():</dt><dd><p>q.cancel_join_thread()
q.close()</p>
</dd>
<dt>for q in self._output_queues.values():</dt><dd><p>q.cancel_join_thread()
q.close()</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>except Exception:</dt><dd><p>pass</p>
</dd>
<dt>finally:</dt><dd><dl class="simple">
<dt>for w in self._workers.values():</dt><dd><dl class="simple">
<dt>if w.is_alive():</dt><dd><p>w.terminate()</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p># Node Manager #
# ————-#</p>
<p>class NodeManager:</p>
<blockquote>
<div><dl>
<dt>def __init__(self, node_mapper=None, node_strs: Union[Iterable[str], Dict[str, int]] = None, da_dim_size=None,</dt><dd><blockquote>
<div><p>safety_factor=1.1, min_node_dim_size=0, max_node_dim_step_ratio=0.1, min_unit_node_tune_steps=10,
min_sf_tune_steps=10, starting_split_factor=0., max_split_factor_step_size=0.05, tune_node_alloc=True,
tune_node_splits=True):</p>
</div></blockquote>
<p>“””
Create node manager, which unlike the node mapper, handles all argument cloning and distributing internally.
The node manager only receivess a specification regarding the ratio of the batch each node should consume.</p>
<dl class="field-list simple">
<dt class="field-odd">param node_mapper</dt>
<dd class="field-odd"><p>The pre-built node mapper used by the manager internally.</p>
</dd>
<dt class="field-even">type node_mapper</dt>
<dd class="field-even"><p>NodeMapper</p>
</dd>
<dt class="field-odd">param node_strs</dt>
<dd class="field-odd"><p>The nodes to distribute and clone the arguments across.</p>
</dd>
<dt class="field-even">type node_strs</dt>
<dd class="field-even"><p>sequence of strs or dict of split sizes</p>
</dd>
<dt class="field-odd">param da_dim_size</dt>
<dd class="field-odd"><p>The size of the dimension along which the node allocation splitting is performed.</p>
</dd>
<dt class="field-even">type da_dim_size</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param safety_factor</dt>
<dd class="field-odd"><p>The factor by which to be safe in the avoidance of OOM GPU errors. Default is 1.1.</p>
</dd>
<dt class="field-even">type safety_factor</dt>
<dd class="field-even"><p>float, optional</p>
</dd>
<dt class="field-odd">param min_node_dim_size</dt>
<dd class="field-odd"><p>The minimum dimension size to pass to a node. Default is 0.</p>
</dd>
<dt class="field-even">type min_node_dim_size</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param max_node_dim_step_ratio</dt>
<dd class="field-odd"><p>The maximum step ratio for changing the dimension for a node. Default is 0.1.</p>
</dd>
<dt class="field-even">type max_node_dim_step_ratio</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param min_unit_node_tune_steps</dt>
<dd class="field-odd"><p>The minimum number of tune steps to make when optimizing with unit step size.
Default is 10.</p>
</dd>
<dt class="field-even">type min_unit_node_tune_steps</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param min_sf_tune_steps</dt>
<dd class="field-odd"><p>Minimum number of split factor tune steps. Default is 10.</p>
</dd>
<dt class="field-even">type min_sf_tune_steps</dt>
<dd class="field-even"><p>int, optional</p>
</dd>
<dt class="field-odd">param starting_split_factor</dt>
<dd class="field-odd"><p>The initial node-specific split factor. Default is 0.</p>
</dd>
<dt class="field-even">type starting_split_factor</dt>
<dd class="field-even"><p>float, optional</p>
</dd>
<dt class="field-odd">param max_split_factor_step_size</dt>
<dd class="field-odd"><p>The maximum step size for changing the split factor for a node.
Default is 0.05.</p>
</dd>
<dt class="field-even">type max_split_factor_step_size</dt>
<dd class="field-even"><p>float, optional</p>
</dd>
<dt class="field-odd">param tune_node_alloc</dt>
<dd class="field-odd"><p>Whether to tune the node split sizes internally based on node utilization tracking,
and use the provided values for initialization. Default is True.</p>
</dd>
<dt class="field-even">type tune_node_alloc</dt>
<dd class="field-even"><p>bool, optional</p>
</dd>
<dt class="field-odd">param tune_node_splits</dt>
<dd class="field-odd"><p>Whether to tune the per-node split sizes internally. Default is True.</p>
</dd>
<dt class="field-even">type tune_node_splits</dt>
<dd class="field-even"><p>bool, optional</p>
</dd>
</dl>
<p>“””
with_node_mapping = True if ivy.exists(node_mapper) else False
tune_node_alloc = False if not with_node_mapping else tune_node_alloc
self._node_mapper = node_mapper
node_strs = ivy.default(node_strs, [ivy.default_node()])
self._num_nodes = len(node_strs)
self._dim_size = da_dim_size
assert 1 &lt;= safety_factor
self._safety_factor = safety_factor
self._min_node_dim_size = min_node_dim_size
self._max_node_dim_step_ratio = max_node_dim_step_ratio
if self._dim_size:</p>
<blockquote>
<div><p>self._max_node_dim_step_size = max(int(round(self._max_node_dim_step_ratio * self._dim_size)), 1)</p>
</div></blockquote>
<p>self._min_unit_node_tune_steps = min_unit_node_tune_steps
self._min_sf_tune_steps = min_sf_tune_steps
self._max_split_factor_step_size = max_split_factor_step_size
self._with_node_mappig = with_node_mapping
self._tune_da = tune_node_alloc
self._tune_ns = tune_node_splits
self._tuned = ((not tune_node_alloc or self._num_nodes == 1) and not tune_node_splits)
self._first_da_tune_step = True
self._first_ns_tune_step = True
self._da_tune_count = 0
self._unit_da_tune_count = 0
self._ns_tune_count = 0
if tune_node_alloc:</p>
<blockquote>
<div><p>self._tune_step = self.da_tune_step</p>
</div></blockquote>
<dl class="simple">
<dt>elif tune_node_splits:</dt><dd><p>self._tune_step = self.ns_tune_step</p>
</dd>
<dt>else:</dt><dd><p>self._tune_step = None</p>
</dd>
</dl>
<p>self._observed_configs = set()
self._da_directions = dict()
self._da_directions_flipped = dict()
if isinstance(node_strs, dict):</p>
<blockquote>
<div><p>self._node_str_da_ratios = node_strs</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>self._node_str_da_ratios = dict(zip(node_strs, [1 / self._num_nodes] * self._num_nodes))</p>
</dd>
</dl>
<p>self._node_strs_keys = self._node_str_da_ratios.keys()
self._percent_mem_inc_per_unit_da_dim = dict(zip(self._node_strs_keys, [0] * self._num_nodes))
self._percent_mem_inc_per_sf = dict(zip(self._node_strs_keys, [0] * self._num_nodes))
self._percent_util_inc_per_unit_da_dim = dict(zip(self._node_strs_keys, [1] * self._num_nodes))
self._delta_da_dim_sizes = dict(zip(self._node_strs_keys, [0] * self._num_nodes))
self._delta_sfs = dict(zip(self._node_strs_keys, [0] * self._num_nodes))
self._node_percent_mems = None
self._node_utils = None
if with_node_mapping and ivy.exists(self._dim_size):</p>
<blockquote>
<div><p>self._compute_node_strs_da()</p>
</div></blockquote>
<p>self._node_strs_ns = {ns: starting_split_factor for ns in self._node_strs_keys}
if self._tune_ns and not with_node_mapping:</p>
<blockquote>
<div><p>[ivy.set_split_factor(starting_split_factor, ns) for ns in self._node_strs_keys]</p>
</div></blockquote>
<p>self._da_time = time.perf_counter()
self._da_step_time = 0
self._ns_time = time.perf_counter()
self._ns_step_time = 0</p>
</dd>
</dl>
<p># Node Allocation #</p>
<dl>
<dt>def _shift_da_splits(self, ordered_node_util_keys, deltas):</dt><dd><p>for i in range(math.floor(self._num_nodes / 2)):</p>
<blockquote>
<div><p># less and more utilized keys
less_util_node_str = ordered_node_util_keys[i]
more_util_node_str = ordered_node_util_keys[-i - 1]</p>
<p># less utilized
delta = max(min(deltas[less_util_node_str],</p>
<blockquote>
<div><p>self._node_strs_da[more_util_node_str] - self._min_node_dim_size), 1)</p>
</div></blockquote>
<dl class="simple">
<dt>if ivy.exists(self._max_node_dim_step_size):</dt><dd><p>delta = min(delta, self._max_node_dim_step_size)</p>
</dd>
</dl>
<p>self._node_strs_da[less_util_node_str] += delta
self._delta_da_dim_sizes[less_util_node_str] = delta</p>
<p># more utilized
self._node_strs_da[more_util_node_str] -= delta
self._delta_da_dim_sizes[more_util_node_str] = -delta</p>
</div></blockquote>
</dd>
<dt>def _compute_node_strs_da(self):</dt><dd><p>split_sizes = [int(round(r * self._dim_size)) for r in self._node_str_da_ratios.values()]
combined_batch_size = sum(split_sizes)
excess_size = combined_batch_size - self._dim_size
if excess_size &gt; 0:</p>
<blockquote>
<div><dl class="simple">
<dt>for i in range(abs(excess_size)):</dt><dd><p>split_sizes[i] -= 1</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>elif excess_size &lt; 0:</dt><dd><dl class="simple">
<dt>for i in range(abs(excess_size)):</dt><dd><p>split_sizes[i] += 1</p>
</dd>
</dl>
</dd>
</dl>
<p>self._node_strs_da = {k: v for k, v in zip(self._node_strs_keys, split_sizes)}</p>
</dd>
<dt>def _compute_node_da_ratios(self):</dt><dd><p>self._node_str_da_ratios = {k: v / self._dim_size for k, v in self._node_strs_da.items()}</p>
</dd>
<dt>def da_tune_step(self):</dt><dd><dl class="simple">
<dt>if self._tuned:</dt><dd><p>return</p>
</dd>
</dl>
<p>new_node_utils = dict(sorted({k: node_util(k) for k in self._node_strs_keys}.items(), key=lambda item: item[1]))
new_node_utils_keys = list(new_node_utils.keys())
highest_util_node = new_node_utils_keys[-1]
highest_util = new_node_utils[highest_util_node]
new_node_percent_mems = dict(sorted({k: percent_used_mem_on_node(k) for k in self._node_strs_keys}.items(),</p>
<blockquote>
<div><p>key=lambda item: item[1]))</p>
</div></blockquote>
<p># first step
if self._first_da_tune_step:</p>
<blockquote>
<div><p># shift the node splits by 1
self._shift_da_splits(new_node_utils_keys, {k: 1 for k in self._node_strs_keys})</p>
<p># update node percentage memory usages and utilizations
self._node_percent_mems = new_node_percent_mems
self._node_utils = new_node_utils</p>
<p># increment count, update ratios and tune step, and return
self._da_tune_count += 1
self._first_da_tune_step = False
self._compute_node_da_ratios()
if self._tune_ns:</p>
<blockquote>
<div><p>self._tune_step = self.ns_tune_step</p>
</div></blockquote>
<p>self._da_time = time.perf_counter()
return</p>
</div></blockquote>
<p># otherwise</p>
<p># check if all directions have changed, and if so, half the max node dim step size
if self._max_node_dim_step_size &gt; 1:</p>
<blockquote>
<div><dl class="simple">
<dt>da_directions = {k: 1 if i &lt; math.floor(self._num_nodes / 2) else -1</dt><dd><p>for i, (k, v) in enumerate(new_node_utils.items())}</p>
</dd>
<dt>if len(self._da_directions) == 0:</dt><dd><p>self._da_directions = da_directions
self._da_directions_flipped = {k: False for k in self._node_strs_keys}</p>
</dd>
<dt>else:</dt><dd><p>self._da_directions_flipped = {k: da_directions[k] * v &lt; 0 for k, v in self._da_directions.items()}</p>
</dd>
<dt>if sum(self._da_directions_flipped.values()) == self._num_nodes:</dt><dd><p>self._da_directions.clear()
self._max_node_dim_step_size = max(int(round(self._max_node_dim_step_size / 2)), 1)</p>
</dd>
</dl>
</div></blockquote>
<p># percentage memory increase per unit dim
delta_percent_mems = {k: new_node_percent_mems[k] - self._node_percent_mems[k] for k in self._node_strs_keys}
self._percent_mem_inc_per_unit_da_dim =             {k: (((self._da_tune_count - 1) * self._percent_mem_inc_per_unit_da_dim[k] +</p>
<blockquote>
<div><blockquote>
<div><p>(delta_percent_mems[k]/delta_dim_size)) / self._da_tune_count)</p>
</div></blockquote>
<dl class="simple">
<dt>if delta_dim_size != 0 else self._percent_mem_inc_per_unit_da_dim[k]</dt><dd><p>for k, delta_dim_size in self._delta_da_dim_sizes.items()}</p>
</dd>
</dl>
</div></blockquote>
<p># percentage utility increase per unit dim
delta_utils = {k: new_node_utils[k] - self._node_utils[k] for k in self._node_strs_keys}
self._percent_util_inc_per_unit_da_dim =             {k: max((((self._da_tune_count - 1) * self._percent_util_inc_per_unit_da_dim[k] +</p>
<blockquote>
<div><blockquote>
<div><p>(delta_utils[k]/delta_dim_size)) / self._da_tune_count), 0.1)</p>
</div></blockquote>
<dl class="simple">
<dt>if delta_dim_size != 0 else self._percent_util_inc_per_unit_da_dim[k]</dt><dd><p>for k, delta_dim_size in self._delta_da_dim_sizes.items()}</p>
</dd>
</dl>
</div></blockquote>
<p># shift the node splits
desired_percent_increases = {k: highest_util - new_node_utils[k] for k in self._node_strs_keys}
raw_deltas = {k: int(round(desired_percent_increases[k] / self._percent_util_inc_per_unit_da_dim[k]))</p>
<blockquote>
<div><p>for k in self._node_strs_keys}</p>
</div></blockquote>
<dl class="simple">
<dt>permissable_steps =             {k: min(math.floor(((100-new_node_percent_mems[k]) / max(self._percent_mem_inc_per_unit_da_dim[k], 0.1))</dt><dd><p>/ self._safety_factor), self._dim_size) for k in self._node_strs_keys}</p>
</dd>
</dl>
<p>deltas = {k: min(v, pm) for (k, v), pm in zip(raw_deltas.items(), permissable_steps.values())}
self._shift_da_splits(new_node_utils_keys, deltas)</p>
<p># update node utilizations and percentage memory usages
self._node_utils = new_node_utils
self._node_percent_mems = new_node_percent_mems</p>
<p># increment count, update ratios and tune step
self._compute_node_da_ratios()
self._da_tune_count += 1
if self._tune_ns:</p>
<blockquote>
<div><p>self._tune_step = self.ns_tune_step</p>
</div></blockquote>
<p># if step size is 1, check if tuning is complete, and return if so
if self._max_node_dim_step_size == 1:</p>
<blockquote>
<div><p># check if da tuning is complete
if self.repeated_config_check() and self._unit_da_tune_count &gt;= self._min_unit_node_tune_steps and                     not self._tune_ns or (self._ns_tune_count &gt;= self._min_sf_tune_steps):</p>
<blockquote>
<div><p>self._observed_configs.clear()
self._percent_mem_inc_per_unit_da_dim.clear()
self._delta_da_dim_sizes.clear()
self._node_percent_mems.clear()
self._tuned = True</p>
</div></blockquote>
<p>self._unit_da_tune_count += 1</p>
</div></blockquote>
<p># log time
now = time.perf_counter()
self._da_step_time = now - self._da_time
self._da_time = now</p>
</dd>
</dl>
<p># Node Splitting #</p>
<dl>
<dt>def _shift_ns(self, deltas):</dt><dd><dl>
<dt>for ns, delta in deltas.items():</dt><dd><p>clipped_delta = min(delta, self._max_split_factor_step_size)
self._node_strs_ns[ns] = min(self._node_strs_ns[ns] + clipped_delta, 1)
self._delta_sfs[ns] = clipped_delta
if not self._with_node_mappig:</p>
<blockquote>
<div><p>ivy.set_split_factor(min(self._node_strs_ns[ns] + clipped_delta, 1), ns)</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>def ns_tune_step(self):</dt><dd><dl class="simple">
<dt>if self._tuned:</dt><dd><p>return</p>
</dd>
<dt>new_node_percent_mems = dict(sorted({k: percent_used_mem_on_node(k) for k in self._node_strs_keys}.items(),</dt><dd><p>key=lambda item: item[1]))</p>
</dd>
</dl>
<p># first step
if self._first_ns_tune_step:</p>
<blockquote>
<div><p># shift the node splits by 1%
self._shift_ns({k: 0.01 for k in self._node_strs_keys})</p>
<p># update node percentage memory usages and utilizations
self._node_percent_mems = new_node_percent_mems</p>
<p># increment count, update ratios and tune step, and return
self._ns_tune_count += 1
self._first_ns_tune_step = False
if self._tune_da:</p>
<blockquote>
<div><p>self._tune_step = self.da_tune_step</p>
</div></blockquote>
<p>self._ns_time = time.perf_counter()
return</p>
</div></blockquote>
<p># otherwise</p>
<p># percentage memory increase per unit dim
delta_percent_mems = {k: new_node_percent_mems[k] - self._node_percent_mems[k] for k in self._node_strs_keys}
self._percent_mem_inc_per_sf =             {k: (((self._ns_tune_count - 1) * self._percent_mem_inc_per_sf[k] +</p>
<blockquote>
<div><blockquote>
<div><p>(delta_percent_mems[k]/delta_sf)) / self._ns_tune_count)</p>
</div></blockquote>
<dl class="simple">
<dt>if delta_sf != 0 else self._percent_mem_inc_per_sf[k]</dt><dd><p>for k, delta_sf in self._delta_sfs.items()}</p>
</dd>
</dl>
</div></blockquote>
<p># shift the node splits
deltas =            {k: min((max(100/self._safety_factor-new_node_percent_mems[k], 0)) / max(self._percent_mem_inc_per_sf[k], 1),</p>
<blockquote>
<div><p>self._max_split_factor_step_size) for k in self._node_strs_keys}</p>
</div></blockquote>
<p>self._shift_ns(deltas)</p>
<p># update node percentage memory usages
self._node_percent_mems = new_node_percent_mems</p>
<p># increment count, update ratios and tune step
self._ns_tune_count += 1
if self._tune_da:</p>
<blockquote>
<div><p>self._tune_step = self.da_tune_step</p>
</div></blockquote>
<p># check whether node allocation tuning is ready to terminate
da_can_terminate = not self._tune_da or self._max_node_dim_step_size == 1</p>
<p># check if ns tuning is complete
if da_can_terminate and self.repeated_config_check() and self._ns_tune_count &gt;= self._min_sf_tune_steps and                 not self._tune_da or (self._unit_da_tune_count &gt;= self._min_unit_node_tune_steps):</p>
<blockquote>
<div><p>self._observed_configs.clear()
self._percent_mem_inc_per_sf.clear()
self._node_percent_mems.clear()
self._tuned = True</p>
</div></blockquote>
<p># log time
now = time.perf_counter()
self._ns_step_time = now - self._ns_time
self._ns_time = now</p>
</dd>
</dl>
<p># Repeated Config Checking #</p>
<p>def repeated_config_check(self):</p>
<blockquote>
<div><p># check if ns tuning is complete, and return if so
config_list = list()
if self._tune_da:</p>
<blockquote>
<div><p>config_list += list(self._node_strs_da.values())</p>
</div></blockquote>
<dl class="simple">
<dt>if self._tune_ns:</dt><dd><p>config_list += [self._node_strs_ns[ns] for ns in self._node_strs_keys]</p>
</dd>
</dl>
<p>config = tuple(config_list)
if config in self._observed_configs:</p>
<blockquote>
<div><p>return True</p>
</div></blockquote>
<p># otherwise add the current config to those observed
self._observed_configs.add(config)</p>
<p>return False</p>
</div></blockquote>
<p># Mapping #</p>
<dl>
<dt>def map(self, cloned=None, to_clone=None, distributed=None, to_distribute=None):</dt><dd><p>“””
Map the function fn to each of the MultiNode args and kwargs, running each function in parallel with CUDA-safe
multiprocessing.</p>
<dl class="field-list simple">
<dt class="field-odd">param cloned</dt>
<dd class="field-odd"><p>The MutliNode keyword arguments which are already cloned. Default is None.</p>
</dd>
<dt class="field-even">type cloned</dt>
<dd class="field-even"><p>dict of any, optional</p>
</dd>
<dt class="field-odd">param to_clone</dt>
<dd class="field-odd"><p>The MutliNode keyword arguments to clone and map to the function. Default is None.</p>
</dd>
<dt class="field-even">type to_clone</dt>
<dd class="field-even"><p>dict of any, optional</p>
</dd>
<dt class="field-odd">param distributed</dt>
<dd class="field-odd"><p>The MutliNode keyword arguments which already distributed. Default is None.</p>
</dd>
<dt class="field-even">type distributed</dt>
<dd class="field-even"><p>dict of any, optional</p>
</dd>
<dt class="field-odd">param to_distribute</dt>
<dd class="field-odd"><p>The MutliNode keyword arguments to distribute and map to the function. Default is None.</p>
</dd>
<dt class="field-even">type to_distribute</dt>
<dd class="field-even"><p>dict of any, optional</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The results of the function, returned as a MultiNode instance.</p>
</dd>
</dl>
<p>“””
used_node_strs_dict = {k: v for k, v in self._node_strs_da.items() if v &gt; 0}
used_node_strs = list(used_node_strs_dict.keys())
cloned = ivy.default(cloned, {})
if ivy.exists(to_clone):</p>
<blockquote>
<div><p>to_clone = {k: ivy.node_clone(v, used_node_strs) for k, v in to_clone.items()}</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>to_clone = {}</p>
</dd>
</dl>
<p>distributed = ivy.default(distributed, {})
if ivy.exists(to_distribute):</p>
<blockquote>
<div><p>to_distribute = {k: ivy.node_dist(v, used_node_strs_dict) for k, v in to_distribute.items()}</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>to_distribute = {}</p>
</dd>
<dt>if self._tune_ns:</dt><dd><dl class="simple">
<dt>ret = self._node_mapper.map(<a href="#id19"><span class="problematic" id="id20">**</span></a>cloned, <a href="#id21"><span class="problematic" id="id22">**</span></a>to_clone, <a href="#id23"><span class="problematic" id="id24">**</span></a>distributed, <a href="#id25"><span class="problematic" id="id26">**</span></a>to_distribute,</dt><dd><p>used_node_strs=used_node_strs, split_factors=self._node_strs_ns)</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>ret = self._node_mapper.map(<a href="#id27"><span class="problematic" id="id28">**</span></a>cloned, <a href="#id29"><span class="problematic" id="id30">**</span></a>to_clone, <a href="#id31"><span class="problematic" id="id32">**</span></a>distributed, <a href="#id33"><span class="problematic" id="id34">**</span></a>to_distribute,</dt><dd><p>used_node_strs=used_node_strs)</p>
</dd>
</dl>
</dd>
<dt>if self._tuned:</dt><dd><p>return ret</p>
</dd>
</dl>
<p>self._tune_step()
return ret</p>
</dd>
<dt>def __del__(self):</dt><dd><dl class="simple">
<dt>if ivy.exists(self._node_mapper):</dt><dd><p>self._node_mapper.__del__()
del self._node_mapper</p>
</dd>
</dl>
</dd>
</dl>
<p>&#64;property
def dim_size(self):</p>
<blockquote>
<div><p>return self._dim_size</p>
</div></blockquote>
<p>&#64;dim_size.setter
def dim_size(self, batch_size):</p>
<blockquote>
<div><p>self._dim_size = batch_size
if self._tune_da:</p>
<blockquote>
<div><p>self._max_node_dim_step_size = max(int(round(self._max_node_dim_step_ratio * self._dim_size)), 1)
self._compute_node_strs_da()</p>
</div></blockquote>
</div></blockquote>
<p>&#64;property
def tune_step(self):</p>
<blockquote>
<div><p>return self._tune_step</p>
</div></blockquote>
</div></blockquote>
<p># Profiler #
# ———#</p>
<p>class Profiler(abc.ABC):</p>
<blockquote>
<div><dl class="simple">
<dt>def __init__(self, save_dir):</dt><dd><p>self._save_dir = save_dir</p>
</dd>
</dl>
<p>&#64;abc.abstractmethod
def start(self):</p>
<blockquote>
<div><p>raise NotImplementedError</p>
</div></blockquote>
<p>&#64;abc.abstractmethod
def stop(self):</p>
<blockquote>
<div><p>raise NotImplementedError</p>
</div></blockquote>
<p>&#64;abc.abstractmethod
def __enter__(self):</p>
<blockquote>
<div><p>raise NotImplementedError</p>
</div></blockquote>
<p>&#64;abc.abstractmethod
def __exit__(self, exc_type, exc_val, exc_tb):</p>
<blockquote>
<div><p>raise NotImplementedError</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<div class="toctree-wrapper compound">
<p class="caption"><span class="caption-text">Multi node</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node.html">node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_str.html">node_str</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_to_str.html">node_to_str</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/str_to_node.html">str_to_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/total_mem_on_node.html">total_mem_on_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/used_mem_on_node.html">used_mem_on_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/percent_used_mem_on_node.html">percent_used_mem_on_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_util.html">node_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/gpu_is_available.html">gpu_is_available</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/num_gpus.html">num_gpus</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/tpu_is_available.html">tpu_is_available</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/default_node.html">default_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/set_default_node.html">set_default_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/to_node.html">to_node</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/split_factor.html">split_factor</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/set_split_factor.html">set_split_factor</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/split_func_call.html">split_func_call</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_dist_array.html">node_dist_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_dist.html">node_dist</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/node_dist_iter.html">node_dist_iter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/distribute_nest.html">distribute_nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/clone_array.html">clone_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/clone.html">clone</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/clone_iter.html">clone_iter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/clone_nest.html">clone_nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/unify_array.html">unify_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/unify.html">unify</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/unify_iter.html">unify_iter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/unify_nest.html">unify_nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/MultiNodeItem.html">MultiNodeItem</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/MultiNodeIter.html">MultiNodeIter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/MultiNodeNest.html">MultiNodeNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/NodeDistItem.html">NodeDistItem</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/NodeDistIter.html">NodeDistIter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/NodeDistNest.html">NodeDistNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/ClonedItem.html">ClonedItem</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/ClonedIter.html">ClonedIter</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/ClonedNest.html">ClonedNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/NodeMapper.html">NodeMapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/NodeMapperMultiProc.html">NodeMapperMultiProc</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_node/Profiler.html">Profiler</a></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ivy Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>