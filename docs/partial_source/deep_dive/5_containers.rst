Containers
==========

.. _`ivy.Container`: https://github.com/unifyai/ivy/blob/e47a7b18628aa73ba0c064d3d07352a7ab672bd1/ivy/container/container.py#L25
.. _`dict`: https://github.com/unifyai/ivy/blob/e47a7b18628aa73ba0c064d3d07352a7ab672bd1/ivy/container/base.py#L56
.. _`ivy.Container.map`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L4030
.. _`ivy.Container.all_true`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L1490
.. _`ivy.Container.to_iterator`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L3019
.. _`ContainerBase`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L56
.. _`ivy.Container.multi_map`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L593
.. _`ivy.Container.diff`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L396
.. _`ivy.Container.common_key_chains`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L663
.. _`ivy.Container.multi_map_in_static_method`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/base.py#L167
.. _`ivy.Container.static_add`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/elementwise.py#L71
.. _`ivy.Container.static_tan`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/elementwise.py#L1240
.. _`ivy.Container.static_roll`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/manipulation.py#L135
.. _`ivy.Container.add`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/elementwise.py#L92
.. _`ivy.Container.tan`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/elementwise.py#L1259
.. _`ivy.Container.roll`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/container/manipulation.py#L158
.. _`static method is added`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/__init__.py#L199
.. _`instance method is added`: https://github.com/unifyai/ivy/blob/8d1eef71522be7f98b601e5f97bb2c54142795b3/ivy/__init__.py#L173
.. _`inherits`: https://github.com/unifyai/ivy/blob/8cbffbda9735cf16943f4da362ce350c74978dcb/ivy/container/container.py#L25
.. _`ContainerWithElementwise`: https://github.com/unifyai/ivy/blob/8cbffbda9735cf16943f4da362ce350c74978dcb/ivy/container/elementwise.py#L12
.. _`__repr__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4588
.. _`__getattr__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4782
.. _`__setattr__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4790
.. _`__getitem__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4842
.. _`__setitem__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4884
.. _`__contains__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4904
.. _`__getstate__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4912
.. _`__setstate__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/base.py#L4927
.. _`implemented`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/container.py#L98
.. _`__add__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/container.py#L115
.. _`__sub__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/container.py#L121
.. _`__mul__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/container.py#L127
.. _`__truediv__`: https://github.com/unifyai/ivy/blob/36e32ca1f17ef1e4c1b986599b45974156c19737/ivy/container/container.py#L133
.. _`containers discussion`: https://github.com/unifyai/ivy/discussions/1316
.. _`repo`: https://github.com/unifyai/ivy
.. _`discord`: https://discord.gg/ZVQdvbzNQJ
.. _`containers channel`: https://discord.com/channels/799879767196958751/982738042886422598


The `ivy.Container`_ inherits from `dict`_, and is useful for storing nested data.
For example, the container is equally suitable for storing batches of training data,
or for storing the weights of a network.

The methods of the :code:`ivy.Container` class are more varied than those of the :code:`ivy.Array`.
All methods of the :code:`ivy.Array` are instance methods,
and almost all of them directly wrap a function in the functional API.

For the :code:`ivy.Container`, there are also methods which are specific to the container itself,
for performing nested operations on the leaves of the container for example.
In addition, there are also static methods.
Overall, this results in the following five mutually exclusive groups of :code:`ivy.Container` methods.
Each of these are explained in the following sub-sections.

#. Container instance methods
#. Container static methods
#. API instance methods
#. API special methods
#. API static methods

Container Instance Methods
--------------------------

Container instance methods are methods which are specific to the container itself.
A few examples include `ivy.Container.map`_ which is used for mapping a function to all leaves of the container,
`ivy.Container.all_true`_ which determines if all container leaves evaluate to boolean `True`,
and `ivy.Container.to_iterator`_ which returns an iterator for traversing the leaves of the container.

There are many more examples, check out the abstract `ContainerBase`_ class to see some more!

Container Static Methods
------------------------

Container static methods are also methods which are specific to containers,
but which generally operate across *multiple* containers rather than a single container.
This underpins the decision to not bind these method to a single container instance,
and instead implement them as *static* methods.

A few examples include `ivy.Container.multi_map`_
which is used for mapping a function to all leaves of *multiple* containers with the same nested structure,
`ivy.Container.diff`_ which displays the difference in nested structure between multiple containers,
and `ivy.Container.common_key_chains`_ which returns the nested structure that is common to all containers.

There are many more examples, check out the abstract `ContainerBase`_ class to see some more!

API Static Methods
------------------

Unlike the :code:`ivy.Array` class, the :code:`ivy.Container` also implements
**all nestable functions** in the functional API as *static* methods.
The main reason for this is to support the *nestable* property of all functions in the API,
which is explained in detail in the :ref:`Function Types` section.

To recap, what this means is that every function can arbitrarily accept :code:`ivy.Container` instances for **any**
of the arguments, and in such cases the function will automatically be mapped to the leaves of this container.
When multiple containers are passed, this mapping is only applied to their shared nested structure,
with the mapping applied to each of these leaves.

In such cases, the function in the functional API defers to this *static* :code:`ivy.Container` implementation.
Under the hood, `ivy.Container.multi_map_in_static_method`_ enables us to pass in arbitrary combinations of containers
and non-containers, and perform the correct mapping across the leaves.
Internally, :code:`ivy.Container.multi_map_in_static_method` calls `ivy.Container.multi_map`_.
In cases where there are no containers passed,
`ivy.Container.multi_map_in_static_method`_ will simply call the function once on the non-container arguments provided.

A few examples of :code:`ivy.Container` API static methods are
`ivy.Container.static_add`_, `ivy.Container.static_tan`_ and `ivy.Container.static_roll`_.

As with :code:`ivy.Array`,
given the simple set of rules which underpin how these static methods should all be implemented,
if a source-code implementation is not found,
then this `static method is added`_ programmatically.
This serves as a helpful backup in cases where some static methods are accidentally missed out.

The benefit of the source code implementations is that this makes the code much more readable,
with important methods not being entirely absent from the code.
It also enables other helpful perks, such as auto-completions in the IDE etc.

API Instance Methods
--------------------

The *API* instance methods serve a similar purpose to the instance methods of the :code:`ivy.Array` class.
They enable functions in Ivy's functional API to be called as instance methods on the :code:`ivy.Container` class.
The difference is that with the :code:`ivy.Container`,
the API function is applied recursively to all the leaves of the container.
The :code:`ivy.Container` instance methods should **exactly match** the instance methods
of the :code:`ivy.Array`, both in terms of the methods implemented and the argument
which :code:`self` replaces in the function being called. This means :code:`self` should
always replace the first array argument in the function.
`ivy.Container.add <https://github.com/unifyai/ivy/blob/1dba30aae5c087cd8b9ffe7c4b42db1904160873/ivy/container/elementwise.py#L158>`_
is a good example.

However, as with the :code:`ivy.Array` class,
it's important to bear in mind that this is *not necessarily the first argument*,
although in most cases it will be.
We also **do not** set the :code:`out` argument to :code:`self` for instance methods.
If the only array argument is the :code:`out` argument, then we do not implement this
instance method. For example, we do not implement an instance method for
`ivy.zeros <https://github.com/unifyai/ivy/blob/1dba30aae5c087cd8b9ffe7c4b42db1904160873/ivy/functional/ivy/creation.py#L116>`_.

Under the hood, every *instance* method calls the corresponding *static* method.
For example, `ivy.Container.add`_ calls :code:`ivy.Container.static_add`,
`ivy.Container.tan`_ calls :code:`ivy.Container.static_tan`,
and `ivy.Container.roll`_ calls :code:`ivy.Container.static_roll`.

As is the case for :code:`ivy.Array`,
the organization of these instance methods follows the same organizational structure as the
files in the functional API.
The :code:`ivy.Container` class `inherits`_ from many category-specific array classes,
such as `ContainerWithElementwise`_, each of which implement the category-specific instance methods.

Again, as with :code:`ivy.Array`,
given the simple set of rules which underpin how these instance methods should all be implemented,
if a source-code implementation is not found,
then this `instance method is added`_ programmatically.
Again, this serves as a helpful backup in cases where some static methods are accidentally missed out.

Again, the benefit of the source code implementations is that this makes the code much more readable,
with important methods not being entirely absent from the code.
It also enables other helpful perks, such as auto-completions in the IDE etc.

API Special Methods
--------------------

All non-operator special methods are implemented in `ContainerBase`_,
which is the abstract base class for all containers.
These special methods include
`__repr__`_ which controls how the container is printed in the terminal,
`__getattr__`_ that enables keys in the underlying :code:`dict` to be queried as attributes,
`__setattr__`_ that enables attribute setting to update the underlying :code:`dict`,
`__getitem__`_ that enables the underlying :code:`dict` to be queried via a chain of keys,
`__setitem__`_ that enables the underlying :code:`dict` to be set via a chain of keys,
`__contains__`_ that enables us to check for chains of keys in the underlying :code:`dict`,
and `__getstate__`_ and `__setstate__`_ which combined enable the container to be pickled and unpickled.

As for the special methods which are `implemented`_ in the main :code:`ivy.Container`
class, they all make calls to the corresponding standard operator functions.

As a result, the operator functions will make use of the special methods of the lefthand
passed input objects if available, otherwise it will make use of the reverse special
method of the righthand operand. For instance, if the lefthand operand at any given leaf
of the container in an :code:`ivy.Array`, then the operator function will make calls to
the special methods of this array object. As explained in the :ref:`Arrays` section of
the Deep Dive, these special methods will in turn call the corresponding functions from
the ivy functional API.
 
Examples include `__add__`_, `__sub__`_, `__mul__`_ and `__truediv__`_ which will make
calls to :code:`ivy.add`, :code:`ivy.subtract`, :code:`ivy.multiply` and
:code:`ivy.divide` respectively if the lefthand operand is an :code:`ivy.Array` object.
Otherwise, these special methods will be called on whatever objects are at the leaves of
the container, such as :code`int`, :code:`float`, :code`ivy.NativeArray` etc.

Nestable Functions
------------------

As introduced in the :ref:`Function Types` section, most functions in Ivy are
*nestable*, which means that they can accept :code:`ivy.Container` instances in place
of **any** of the arguments.

Here, we expand on this explanation.
Please check out the explanation in the :ref:`Function Types` section first.

**Explicitly Nestable Functions**

The *nestable* behaviour is added to any function which is decorated with the
`handle_nestable <https://github.com/unifyai/ivy/blob/5f58c087906a797b5cb5603714d5e5a532fc4cd4/ivy/func_wrapper.py#L407>`_
wrapper. This wrapper causes the function to be applied at each leaf of any containers
passed in the input. More information on this can be found in the `Function Wrapping <https://github.com/unifyai/ivy/commit/384963a6d41801e713ec3d203b42bf78d1d7aa0d>`_
section of the Deep Dive.

Additionally, any nestable function which returns multiple arrays, will return the same number of containers for it's container
counterpart. This property makes the function symmetric with regards to the input-output behavior, irrespective of whether
:code:`ivy.Array` or :code:`ivy.Container` instances are based used. Any argument in the input can be replaced with a container
without changing the number of inputs, and the presence or absence of ivy.Container instances in the input should not change the
number of return values of the function. In other words, if containers are detected in the input, then we should return a separate
container for each array that the function would otherwise return.

The current implementation checks if the leaves of the container have a list of arrays. If they do, this container is then
unstacked to multiple containers(as many as the number of arrays), which are then returned inside a list.

**Implicitly Nestable Functions**

*Compositional* functions are composed of other nestable functions, and hence are already **implicitly nestable**. So,
we do not need to explicitly wrap it at all.

Let's take the function :code:`ivy.cross_entropy` as an example.
The internally called functions are: :code:`ivy.clip`, :code:`ivy.log`, :code:`ivy.sum`
and :code:`ivy.negative`, each of which are themselves *nestable*.

.. code-block:: python

    def cross_entropy(
        true: Union[ivy.Array, ivy.NativeArray],
        pred: Union[ivy.Array, ivy.NativeArray],
        /,
        *,
        axis: Optional[int] = -1,
        epsilon: Optional[float] = 1e-7,
        out: Optional[ivy.Array] = None
    ) -> ivy.Array:
        pred = ivy.clip(pred, epsilon, 1 - epsilon)
        log_pred = ivy.log(pred)
        return ivy.negative(ivy.sum(log_pred * true, axis, out=out), out=out)

Therefore, when passing an :code:`ivy.Container` instance in the input,
each internal function will, in turn, correctly handle the container, and return
a new container with the correct operations having been performed. This makes it very
easy and intuitive to debug the code, as the code is stepped through chronologically.
In effect, all leaves of the input container are being processed concurrently,
during the computation steps of the :code:`ivy.cross_entropy` function.

However, what if we had added the
`handle_nestable <https://github.com/unifyai/ivy/blob/5f58c087906a797b5cb5603714d5e5a532fc4cd4/ivy/func_wrapper.py#L407>`_
wrapping as a decorator directly to the function :code:`ivy.cross_entropy`?

In this case, the :code:`ivy.cross_entropy` function would itself be called
multiple times, on each of the leaves of the container.
The functions :code:`ivy.clip`, :code:`ivy.log`, :code:`ivy.sum`
and :code:`ivy.negative` would each only consume and return arrays,
and debugging the :code:`ivy.cross_entropy` function
would then become less intuitively chronological,
with each leaf of the input container now processed sequentially,
rather than concurrently.

Therefore, our approach is to **not** wrap any compositional functions which are
already *implicitly nestable* as a result of the *nestable* functions called internally.

There may be some compositional functions which are not implicitly nestable for some
reason, and in such cases adding the explicit
`handle_nestable <https://github.com/unifyai/ivy/blob/5f58c087906a797b5cb5603714d5e5a532fc4cd4/ivy/func_wrapper.py#L407>`_
wrapping may be necessary. But we should try to avoid this,
in order to make the flow of computation as intuitive to the user as possible.

When compiling the code, the computation graph is **identical** in either case,
and there will be no implications on performance whatsoever.
The implicit nestable solution may be slightly less efficient in eager mode,
as the leaves of the container are traversed multiple times rather than once,
but if performance is of concern then the code should always be compiled in any case.
The distinction is only really relevant when stepping through and debugging with eager
mode execution, and for the reasons outlined above, the preference is to keep
compositional implicitly nestable where possible.

**Shared Nested Structure**

When the nested structures of the multiple containers are *shared* but not *identical*,
then the behaviour of the nestable function is a bit different.
Containers have *shared* nested structures if all unique leaves in any of the containers
are children of a nested structure which is shared by all other containers.

Take the example below, the nested structures of containers :code:`x` and :code:`y`
are shared but not identical.

.. code-block:: python

    x = ivy.Container(a={'b': 2, 'c': 4}, d={'e': 6, 'f': 8})
    y = ivy.Container(a=2, d=3)

The shared key chains (chains of keys, used for indexing the container)
are :code:`a` and :code:`d`. The key chains unique to :code:`x` are :code:`a/b`, :code:`a/c`,
:code:`d/e` and :code:`d/f`. The unique key chains all share the same base structure as
all other containers (in this case only one other container, :code:`y`).
Therefore, the containers :code:`x` and :code:`y` have shared nested structure.

When calling *nestable* functions on containers with non-identical structure,
then the shared leaves of the shallowest container are broadcast to the leaves of the
deepest container.

It's helpful to look at an example:

.. code-block:: python

    print(x / y)
    {
        a: {
          b: 1,
          c: 2
        },
        d: {
          e: 3,
          f: 2.67
        }
    }

In this case, the integer at :code:`y.a` is broadcast to the leaves :code:`x.a.b` and
:code:`x.a.c`, and the integer at :code:`y.d` is broadcast to the leaves :code:`x.d.e`
and :code:`x.d.f`.

Another example of containers with shared nested structure is given below:

.. code-block:: python

    x = ivy.Container(a={'b': 2, 'c': 4}, d={'e': 6, 'f': 8})
    y = ivy.Container(a=2, d=3)
    z = ivy.Container(a={'b': 10, 'c': {'g': 11, 'h': 12}}, d={'e': 13, 'f': 14})

Adding these containers together would result in the following:

.. code-block:: python

    print(x + y + z)
    {
        a: {
          b: 14,
          c: {
            g: 17,
            h: 18,
          }
        },
        d: {
          e: 22,
          f: 25
        }
    }

An example of containers which **do not** have shared nested structure is given below:

.. code-block:: python

    x = ivy.Container(a={'b': 2, 'c': 4}, d={'e': 6, 'f': 8})
    y = ivy.Container(a=2, d=3, g=4)
    z = ivy.Container(a={'b': 10, 'c': {'g': 11, 'h': 12}}, d={'e': 13, 'g': 14})

This is for three reasons, (a) the key chain :code:`g` is not shared by any container other
than :code:`y`, (b) the key chain :code:`d/f` for :code:`x` is not present in
:code:`z` despite :code:`d` not being a non-leaf node in :code:`z`,
and likewise the key chain :code:`d/g` for :code:`z` is not present in :code:`x`
despite :code:`d` not being a non-leaf node in :code:`x`.

**Round Up**

This should have hopefully given you a good feel for containers, and how these are handled in Ivy.

If you're ever unsure of how best to proceed,
please feel free to engage with the `containers discussion`_,
or reach out on `discord`_ in the `containers channel`_!


**Video**

.. raw:: html

    <iframe width="420" height="315"
    src="https://www.youtube.com/embed/oHcoYFi2rvI" class="video">
    </iframe>