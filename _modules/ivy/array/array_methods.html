
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ivy.array.array_methods &#8212; Ivy Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="icon" type="image/png" href="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/ivy_logo_only.png?raw=true">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/ivy/array/array_methods';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">

  
  
  
  
  
  
  

  
    <img src="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/logo.png?raw=true" class="logo__image only-light" alt="Logo image">
    <img src="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/logo_dark.png?raw=true" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  
  <div class=" navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/unifyai/ivy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://twitter.com/letsunifyai" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/unifyai/ivy" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://twitter.com/letsunifyai" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
    
  </div>

  
  <div class="sidebar-start-items sidebar-primary__section">
    <div class="sidebar-start-items__item"><nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../background.html">
                        Background
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../design.html">
                        Design
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../related_work.html">
                        Related Work
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../extensions.html">
                        Extensions
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../contributing.html">
                        Contributing
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../deep_dive.html">
                        Deep Dive
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../faq.html">
                        FAQ
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../glossary.html">
                        Glossary
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../functional/ivy/activations.html">
                        Functions
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../data_classes/container.html">
                        Container
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../data_classes/array.html">
                        Array
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/helpers.html">
                        Helpers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/module.html">
                        Module
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/optimizers.html">
                        Optimizers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/sequential.html">
                        Sequential
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/norms.html">
                        Norms
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/initializers.html">
                        Initializers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/layers.html">
                        Layers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/converters.html">
                        Converters
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../stateful/activations.html">
                        Activations
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../nested_array/nested_array.html">
                        Nested array
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/backend.html">
                        Backend
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/_importlib.html">
                        Importlib
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/assertions.html">
                        Assertions
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/dynamic_import.html">
                        Dynamic import
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/inspection.html">
                        Inspection
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../utils/verbosity.html">
                        Verbosity
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/assertions.html">
                        Assertions
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/available_frameworks.html">
                        Available frameworks
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/function_testing.html">
                        Function testing
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/globals.html">
                        Globals
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/hypothesis_helpers.html">
                        Hypothesis helpers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/structs.html">
                        Structs
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/test_parameter_flags.html">
                        Test parameter flags
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../testing/testing_helpers.html">
                        Testing helpers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../ivy"">
                        Ivy
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../mech"">
                        Ivy mech
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../vision"">
                        Ivy vision
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../robot"">
                        Ivy robot
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../gym"">
                        Ivy gym
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../memory"">
                        Ivy memory
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../builder"">
                        Ivy builder
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../models"">
                        Ivy models
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../ecosystem"">
                        Ivy ecosystem
                      </a>
                    </li>
                
    </ul>
</nav>
    </div>
  </div>
  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <h1>Source code for ivy.array.array_methods</h1><div class="highlight"><pre>
<span></span><span class="c1">#ivy.array.activations</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="relu"><a class="viewcode-back" href="../../../functional/ivy/activations/relu/relu_array.html#ivy.array.array_methods.relu">[docs]</a><span class="k">def</span> <span class="nf">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.relu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.relu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the relu activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="leaky_relu"><a class="viewcode-back" href="../../../functional/ivy/activations/leaky_relu/leaky_relu_array.html#ivy.array.array_methods.leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">leaky_relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.leaky_relu. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.leaky_relu also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    alpha</span>
<span class="sd">        the slope of the negative section.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the leaky relu activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.39, -0.85])</span>
<span class="sd">    &gt;&gt;&gt; y = x.leaky_relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.39, -0.17])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">leaky_relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="gelu"><a class="viewcode-back" href="../../../functional/ivy/activations/gelu/gelu_array.html#ivy.array.array_methods.gelu">[docs]</a><span class="k">def</span> <span class="nf">gelu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gelu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.gelu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    approximate</span>
<span class="sd">        whether to use the approximate version of the gelu function.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the gelu activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.2, -0.6, 1.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.gelu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.138, -0.165, 1.4])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gelu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="n">approximate</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sigmoid"><a class="viewcode-back" href="../../../functional/ivy/activations/sigmoid/sigmoid_array.html#ivy.array.array_methods.sigmoid">[docs]</a><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sigmoid.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.sigmoid also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array for writing the result to. It must have the same shape</span>
<span class="sd">        the input broadcast to default: None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the sigmoid activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sigmoid()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/softmax/softmax_array.html#ivy.array.array_methods.softmax">[docs]</a><span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.softmax. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.softmax also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the softmax activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="softplus"><a class="viewcode-back" href="../../../functional/ivy/activations/softplus/softplus_array.html#ivy.array.array_methods.softplus">[docs]</a><span class="k">def</span> <span class="nf">softplus</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.softplus. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.softplus also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    beta</span>
<span class="sd">        the beta parameter of the softplus function.</span>
<span class="sd">    threshold</span>
<span class="sd">        the threshold parameter of the softplus function.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the softplus activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-0.3461, -0.6491])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.535,0.42])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-0.3461, -0.6491])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus(beta=0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.22, 1.09])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.31, 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus(threshold=2, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([1.55, 2.13, 2.13])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">softplus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="log_softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/log_softmax/log_softmax_array.html#ivy.array.array_methods.log_softmax">[docs]</a><span class="k">def</span> <span class="nf">log_softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log_softmax.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for ivy.log_softmax also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the log_softmax should be computed</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the log_softmax activation function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0, -0.98, 2.3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-3.37, -3.35, -0.0719])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.0, 3.4, -4.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax(x)</span>
<span class="sd">    ivy.array([-1.62, -0.221, -7.82 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="mish"><a class="viewcode-back" href="../../../functional/ivy/activations/mish/mish_array.html#ivy.array.array_methods.mish">[docs]</a><span class="k">def</span> <span class="nf">mish</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.mish. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.mish also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.mish()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.30340147,  0.        ,  0.86509842])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">mish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.array</span>
<span class="c1"># flake8: noqa</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">.conversions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.activations</span> <span class="kn">import</span> <span class="n">_ArrayWithActivations</span>
<span class="kn">from</span> <span class="nn">.creation</span> <span class="kn">import</span> <span class="n">_ArrayWithCreation</span>
<span class="kn">from</span> <span class="nn">.data_type</span> <span class="kn">import</span> <span class="n">_ArrayWithDataTypes</span>
<span class="kn">from</span> <span class="nn">.device</span> <span class="kn">import</span> <span class="n">_ArrayWithDevice</span>
<span class="kn">from</span> <span class="nn">.elementwise</span> <span class="kn">import</span> <span class="n">_ArrayWithElementwise</span>
<span class="kn">from</span> <span class="nn">.general</span> <span class="kn">import</span> <span class="n">_ArrayWithGeneral</span>
<span class="kn">from</span> <span class="nn">.gradients</span> <span class="kn">import</span> <span class="n">_ArrayWithGradients</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">_ArrayWithImage</span>
<span class="kn">from</span> <span class="nn">.layers</span> <span class="kn">import</span> <span class="n">_ArrayWithLayers</span>
<span class="kn">from</span> <span class="nn">.linear_algebra</span> <span class="kn">import</span> <span class="n">_ArrayWithLinearAlgebra</span>
<span class="kn">from</span> <span class="nn">.losses</span> <span class="kn">import</span> <span class="n">_ArrayWithLosses</span>
<span class="kn">from</span> <span class="nn">.manipulation</span> <span class="kn">import</span> <span class="n">_ArrayWithManipulation</span>
<span class="kn">from</span> <span class="nn">.norms</span> <span class="kn">import</span> <span class="n">_ArrayWithNorms</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">_ArrayWithRandom</span>
<span class="kn">from</span> <span class="nn">.searching</span> <span class="kn">import</span> <span class="n">_ArrayWithSearching</span>
<span class="kn">from</span> <span class="nn">.set</span> <span class="kn">import</span> <span class="n">_ArrayWithSet</span>
<span class="kn">from</span> <span class="nn">.sorting</span> <span class="kn">import</span> <span class="n">_ArrayWithSorting</span>
<span class="kn">from</span> <span class="nn">.statistical</span> <span class="kn">import</span> <span class="n">_ArrayWithStatistical</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="n">_ArrayWithUtility</span>
<span class="kn">from</span> <span class="nn">ivy.func_wrapper</span> <span class="kn">import</span> <span class="n">handle_view_indexing</span>
<span class="kn">from</span> <span class="nn">.experimental</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_ArrayWithSearchingExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithActivationsExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithConversionsExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithCreationExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithData_typeExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithDeviceExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithElementWiseExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithGeneralExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithGradientsExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithImageExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithLayersExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithLinearAlgebraExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithLossesExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithManipulationExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithNormsExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithRandomExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithSetExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithSortingExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithStatisticalExperimental</span><span class="p">,</span>
    <span class="n">_ArrayWithUtilityExperimental</span><span class="p">,</span>
<span class="p">)</span>




<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dynamic_backend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">_ArrayWithActivations</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithCreation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithDataTypes</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithDevice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithElementwise</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithGeneral</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithGradients</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithImage</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithLayers</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithLinearAlgebra</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithLosses</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithManipulation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithNorms</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithRandom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithSearching</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithSorting</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithStatistical</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithUtility</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">_ArrayWithActivationsExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithConversionsExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithCreationExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithData_typeExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithDeviceExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithElementWiseExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithGeneralExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithGradientsExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithImageExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithLayersExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithLinearAlgebraExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithLossesExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithManipulationExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithNormsExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithRandomExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithSearchingExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithSetExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithSortingExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithStatisticalExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="n">_ArrayWithUtilityExperimental</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dynamic_backend</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_view_attributes</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dynamic_backend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>
    <span class="k">elif</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;data must be ivy array, native array or ndarray&quot;</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_dev_str</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">as_ivy_dev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pre_repr</span> <span class="o">=</span> <span class="s2">&quot;ivy.array&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;gpu&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dev_str</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_repr</span> <span class="o">=</span> <span class="s2">&quot;, dev=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dev_str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_repr</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dynamic_backend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_backend</span> <span class="o">=</span> <span class="n">dynamic_backend</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_backend</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_dynamic_backend</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_view_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;base&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">base</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;_base&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_base</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_view_refs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_manipulation_stack</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">dynamic_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_backend</span>


<span class="k">def</span> <span class="nf">dynamic_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">ivy.functional.ivy.gradients</span> <span class="kn">import</span> <span class="n">_variable</span>
    <span class="kn">from</span> <span class="nn">ivy.utils.backend.handler</span> <span class="kn">import</span> <span class="n">_determine_backend_from_args</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">_determine_backend_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">is_variable</span>
        <span class="n">to_numpy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">to_numpy</span>
        <span class="n">variable_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">variable_data</span>
        <span class="k">if</span> <span class="n">is_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">native_data</span> <span class="o">=</span> <span class="n">variable_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">np_data</span> <span class="o">=</span> <span class="n">to_numpy</span><span class="p">(</span><span class="n">native_data</span><span class="p">)</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_variable</span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np_data</span> <span class="o">=</span> <span class="n">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_data</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_backend</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The native array being wrapped in self.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>


<span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data type of the array elements&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>


<span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hardware device the array data resides on.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>


<span class="k">def</span> <span class="nf">mT</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose of a matrix (or a stack of matrices).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        array whose last two dimensions (axes) are permuted in reverse order</span>
<span class="sd">        relative to original array (i.e., for an array instance having shape</span>
<span class="sd">        ``(..., M, N)``, the returned array must have shape ``(..., N, M)``).</span>
<span class="sd">        The returned array must have the same data type as the original array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">allow_equal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of array dimensions (axes).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Array dimensions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of elements in the array.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>


<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        two-dimensional array whose first and last dimensions (axes) are</span>
<span class="sd">        permuted in reverse order relative to original array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_equal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s2">&quot;data must be native array&quot;</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__torch_function__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__ivy_array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Cannot handle items that have __ivy_array_function__ other than those of</span>
    <span class="c1"># ivy arrays or native arrays.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;__ivy_array_function__&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__ivy_array_function__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">__ivy_array_function__</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="s2">&quot;__ivy_array_function__&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">__ivy_array_function__</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="o">.</span><span class="n">__ivy_array_function__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="c1"># Arguments contain no overrides, so we can safely call the</span>
    <span class="c1"># overloaded function again.</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__array__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__array_prepare__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__array_namespace__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span>


<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">sig_fig</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array_significant_figures</span><span class="p">()</span>
    <span class="n">dec_vals</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array_decimal_values</span><span class="p">()</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="k">else</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">arr_np</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="n">rep</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vec_sig_fig</span><span class="p">(</span><span class="n">arr_np</span><span class="p">,</span> <span class="n">sig_fig</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_np</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">dec_vals</span><span class="p">):</span>
        <span class="nb">repr</span> <span class="o">=</span> <span class="n">rep</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;, dtype&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;, dev&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pre_repr</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">[</span><span class="nb">repr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="p">:]</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_repr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ivy</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">())</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>


<span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;torch&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">scatter_nd</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># only pickle the native array</span>
    <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
    <span class="c1"># also store the local ivy framework that created this array</span>
    <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span>
    <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;device_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">as_ivy_dev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_dict</span>


<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="c1"># we can construct other details of ivy.Array</span>
    <span class="c1"># just by re-creating the ivy.Array using the native array</span>
    <span class="c1"># get the required backend</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">set_backend</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
    <span class="n">ivy_array</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">unset_backend</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">ivy_array</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="c1"># TODO: what about placement of the array on the right device ?</span>
    <span class="c1"># device = backend.as_native_dev(state[&quot;device_str&quot;])</span>
    <span class="c1"># backend.to_device(self, device)</span>


<span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.pow. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.pow also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array or float.</span>
<span class="sd">    power</span>
<span class="sd">        Array or float power. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x ** 2</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 4, 9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.2, 2.1, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x ** 2.9</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1.69678056,  8.59876156, 37.82660675])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.add. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 9])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.add. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 6, 7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.subtract. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances only:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3, -3, -3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.subtract. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3, -4, -5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)])</span>


<span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)])</span>


<span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.divide. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.divide also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x / y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0.25      , 0.40000001, 0.5       ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__imatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.abs. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.abs</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the absolute value of each element</span>
<span class="sd">        in ``self``. The returned array must have the same data</span>
<span class="sd">        type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, -2, 0, -1])</span>
<span class="sd">    &gt;&gt;&gt; print(abs(x))</span>
<span class="sd">    ivy.array([6, 2, 0, 1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.2, 1.2])</span>
<span class="sd">    &gt;&gt;&gt; print(abs(x))</span>
<span class="sd">    ivy.array([1.2, 1.2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__float__</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;__int__&quot;</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__int__</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ivy</span><span class="o">.</span><span class="n">to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__bool__</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">__dlpack__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__dlpack__</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">__dlpack_device__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__dlpack_device__</span><span class="p">()</span>


<span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.less. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.less</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x &lt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ False, True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.less_equal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.less_equal</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x &lt;= y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ False, True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.equal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.equal</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 0, -1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1 == x2</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, True, False, False])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 0, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1 == x2</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.not_equal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.not_equal</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 0, -1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1 != x2</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, False, True, True])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 0, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1 != x2</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, True, True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.greater. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.greater</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([True,False,False])</span>
<span class="sd">    With mix of :class:`ivy.Array` and :class:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[5.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[4.], [5.1], [6.]]),b=ivy.array([[-3.6], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[True, False, False],</span>
<span class="sd">                      [False, False, False],</span>
<span class="sd">                      [False, False, False]]),</span>
<span class="sd">        b: ivy.array([[True, True, False],</span>
<span class="sd">                      [False, False, False],</span>
<span class="sd">                      [False, False, False]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.greater_equal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.bitwise_xor</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with x1 (with Broadcasting). May have any</span>
<span class="sd">        data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type of bool.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([6, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;= y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([True,False,False])</span>
<span class="sd">    With mix of :class:`ivy.Array` and :class:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[5.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[4.], [5.1], [6.]]),b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;= y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[True, False, False],</span>
<span class="sd">                      [True, False, False],</span>
<span class="sd">                      [False, False, False]]),</span>
<span class="sd">        b: ivy.array([[True, False, False],</span>
<span class="sd">                      [False, False, False],</span>
<span class="sd">                      [False, False, False]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__iand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.bitwise_xor. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.bitwise_xor</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``x1`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([3, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = a ^ b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2,0,2])</span>
<span class="sd">    With mix of :class:`ivy.Array` and :class:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([-67, 21]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([12, 13])</span>
<span class="sd">    &gt;&gt;&gt; z = x ^ y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {a: ivy.array([-79, 24])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_left_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_left_shift</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_left_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array special method variant of ivy.bitwise_right_shift. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.bitwise_right_shift</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``x1`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer data type. Each element must be greater than or equal</span>
<span class="sd">        to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances only:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_right_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array reverse special method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array. Must be compatible with ``x1`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer data type. Each element must be greater than or equal</span>
<span class="sd">        to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = 32</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([32, 16,  8])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_right_shift</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__irshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_right_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="n">memodict</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># ToDo: try and find more elegant solution to jax inability to</span>
        <span class="c1">#  deepcopy device arrays</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;jax&quot;</span><span class="p">:</span>
            <span class="n">np_array</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
            <span class="n">jax_array</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_array</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="n">jax_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_ivy</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>


<span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;iteration over a 0-d ivy.Array not supported&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="n">to_ivy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>


<span class="c1">#ivy.array.creation</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># Array API Standard #</span>
<span class="c1"># -------------------#</span>




<div class="viewcode-block" id="asarray"><a class="viewcode-back" href="../../../functional/ivy/creation/asarray/asarray_array.html#ivy.array.array_methods.asarray">[docs]</a><span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asarray. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asarray also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input data, in any form that can be converted to an array. This includes</span>
<span class="sd">        lists, lists of tuples, tuples, tuples of tuples, tuples of lists and</span>
<span class="sd">        ndarrays.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean, indicating whether or not to copy the input. Default: ``None``.</span>
<span class="sd">    dtype</span>
<span class="sd">        datatype, optional. Datatype is inferred from the input data.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array interpretation of ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With list of lists as input:</span>
<span class="sd">    &gt;&gt;&gt; ivy.asarray([[1,2],[3,4]])</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    With tuple of lists as input:</span>

<span class="sd">    &gt;&gt;&gt; ivy.asarray(([1.4,5.6,5.5],[3.1,9.1,7.5]))</span>
<span class="sd">    ivy.array([[1.39999998, 5.5999999 , 5.5       ],</span>
<span class="sd">           [3.0999999 , 9.10000038, 7.5       ]])</span>
<span class="sd">    With ndarray as input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.np.ndarray(shape=(2,2), order=&#39;C&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[6.90786433e-310, 6.90786433e-310],</span>
<span class="sd">           [6.90786433e-310, 6.90786433e-310]])</span>

<span class="sd">    &gt;&gt;&gt; ivy.asarray(x)</span>
<span class="sd">    ivy.array([[6.90786433e-310, 6.90786433e-310],</span>
<span class="sd">           [6.90786433e-310, 6.90786433e-310]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../functional/ivy/creation/full_like/full_like_array.html#ivy.array.array_methods.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.full_like. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.full_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and where every element is equal</span>
<span class="sd">        to ``fill_value``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`int` datatype:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 0</span>
<span class="sd">    &gt;&gt;&gt; x.full_like(fill_value)</span>
<span class="sd">    ivy.array([0, 0, 0])</span>
<span class="sd">    With float datatype:</span>

<span class="sd">    &gt;&gt;&gt; fill_value = 0.000123</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array(ivy.ones(5))</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.000123, 0.000123, 0.000123, 0.000123, 0.000123])</span>
<span class="sd">    With :class:`ivy.Array` input:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 1</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 1, 1, 1, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../../functional/ivy/creation/ones_like/ones_like_array.html#ivy.array.array_methods.ones_like">[docs]</a><span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.ones_like. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.ones_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and filled with ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../../functional/ivy/creation/zeros_like/zeros_like_array.html#ivy.array.array_methods.zeros_like">[docs]</a><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.zeros_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.zeros_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and filled with ``zeros``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="tril"><a class="viewcode-back" href="../../../functional/ivy/creation/tril/tril_array.html#ivy.array.array_methods.tril">[docs]</a><span class="k">def</span> <span class="nf">tril</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tril. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tril also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, N) and whose innermost two dimensions form</span>
<span class="sd">        MxN matrices.</span>
<span class="sd">    k</span>
<span class="sd">        diagonal above which to zero elements. If k = 0, the diagonal is the main</span>
<span class="sd">        diagonal. If k &lt; 0, the diagonal is below the main diagonal. If k &gt; 0, the</span>
<span class="sd">        diagonal is above the main diagonal. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the lower triangular part(s). The returned array must</span>
<span class="sd">        have the same shape and data type as ``self``. All elements above the</span>
<span class="sd">        specified diagonal k must be zeroed. The returned array should be allocated</span>
<span class="sd">        on the same device as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="triu"><a class="viewcode-back" href="../../../functional/ivy/creation/triu/triu_array.html#ivy.array.array_methods.triu">[docs]</a><span class="k">def</span> <span class="nf">triu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.triu. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.triu also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, N) and whose innermost two dimensions form</span>
<span class="sd">        MxN matrices.    *,</span>
<span class="sd">    k</span>
<span class="sd">        diagonal below which to zero elements. If k = 0, the diagonal is the main</span>
<span class="sd">        diagonal. If k &lt; 0, the diagonal is below the main diagonal. If k &gt; 0, the</span>
<span class="sd">        diagonal is above the main diagonal. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the upper triangular part(s). The returned array must</span>
<span class="sd">        have the same shape and data type as ``self``. All elements below the</span>
<span class="sd">        specified diagonal k must be zeroed. The returned array should be allocated</span>
<span class="sd">        on the same device as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../../functional/ivy/creation/empty_like/empty_like_array.html#ivy.array.array_methods.empty_like">[docs]</a><span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.empty_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.empty_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If dtype is None, the output array data type must be</span>
<span class="sd">        inferred from ``self``. Deafult: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is None, the output</span>
<span class="sd">        array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and containing uninitialized</span>
<span class="sd">        data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../../functional/ivy/creation/meshgrid/meshgrid_array.html#ivy.array.array_methods.meshgrid">[docs]</a><span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.meshgrid. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.meshgrid also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        one-dimensional input array.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of one-dimensional arrays representing grid coordinates.</span>
<span class="sd">        Each array should have the same numeric data type.</span>
<span class="sd">    sparse</span>
<span class="sd">        if True, a sparse grid is returned in order to conserve memory. Default:</span>
<span class="sd">        ``False``.</span>
<span class="sd">    indexing</span>
<span class="sd">        Cartesian ``&#39;xy&#39;`` or matrix ``&#39;ij&#39;`` indexing of output. If provided zero</span>
<span class="sd">        or one one-dimensional vector(s) (i.e., the zero- and one-dimensional cases,</span>
<span class="sd">        respectively), the ``indexing`` keyword has no effect and should be ignored.</span>
<span class="sd">        Default: ``&#39;xy&#39;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        list of N arrays, where ``N`` is the number of provided one-dimensional</span>
<span class="sd">        input arrays. Each returned array must have rank ``N``. For ``N``</span>
<span class="sd">        one-dimensional arrays having lengths ``Ni = len(xi)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span><span class="p">),</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="n">indexing</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_dlpack"><a class="viewcode-back" href="../../../functional/ivy/creation/from_dlpack/from_dlpack_array.html#ivy.array.array_methods.from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.from_dlpack. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.from_dlpack also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the data in ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="copy_array"><a class="viewcode-back" href="../../../functional/ivy/creation/copy_array/copy_array_array.html#ivy.array.array_methods.copy_array">[docs]</a><span class="k">def</span> <span class="nf">copy_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">to_ivy_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.copy_array. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.copy_array also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    to_ivy_array</span>
<span class="sd">        boolean, if True the returned array will be an ivy.Array object otherwise</span>
<span class="sd">        returns an ivy.NativeArray object (i.e. a torch.tensor, np.array, etc.,</span>
<span class="sd">        depending on the backend), defaults to True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a copy of the input array ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ivy_array</span><span class="o">=</span><span class="n">to_ivy_array</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="native_array"><a class="viewcode-back" href="../../../functional/ivy/creation/native_array/native_array_array.html#ivy.array.array_methods.native_array">[docs]</a><span class="k">def</span> <span class="nf">native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.native_array. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.native_array also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    dtype</span>
<span class="sd">        datatype, optional. Datatype is inferred from the input data.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A native array interpretation of ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">native_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span></div>


<div class="viewcode-block" id="one_hot"><a class="viewcode-back" href="../../../functional/ivy/creation/one_hot/one_hot_array.html#ivy.array.array_methods.one_hot">[docs]</a><span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">on_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">off_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.one_hot. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.one_hot also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the indices for which the ones should be scattered</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    on_value</span>
<span class="sd">        Value to fill in output when ``indices[j] == i``. Default 1.</span>
<span class="sd">    off_value</span>
<span class="sd">        Value to fill in output when ``indices[j] != i``. Default 0.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis to scatter on. The default is ``-1`` which is the last axis.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output array. If None, the data type of the on_value is</span>
<span class="sd">        used, or if that is None, the data type of the off_value is used. Default</span>
<span class="sd">        float32.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        Same as x if None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Tensor of zeros with the same shape and type as a, unless dtype provided</span>
<span class="sd">        which overrides.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = 5</span>
<span class="sd">    &gt;&gt;&gt; z = x.one_hot(5)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[0., 0., 0., 1., 0.],</span>
<span class="sd">    ...    [0., 1., 0., 0., 0.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; y = 5</span>
<span class="sd">    &gt;&gt;&gt; ivy.one_hot(x, y)</span>
<span class="sd">    ivy.array([[1., 0., 0., 0., 0.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; y = 5</span>
<span class="sd">    &gt;&gt;&gt; ivy.one_hot(x, 5, out=z)</span>
<span class="sd">    ivy.array([[1., 0., 0., 0., 0.]])</span>

<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[1., 0., 0., 0., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">,</span>
        <span class="n">on_value</span><span class="o">=</span><span class="n">on_value</span><span class="p">,</span>
        <span class="n">off_value</span><span class="o">=</span><span class="n">off_value</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="linspace"><a class="viewcode-back" href="../../../functional/ivy/creation/linspace/linspace_array.html#ivy.array.array_methods.linspace">[docs]</a><span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logspace"><a class="viewcode-back" href="../../../functional/ivy/creation/logspace/logspace_array.html#ivy.array.array_methods.logspace">[docs]</a><span class="k">def</span> <span class="nf">logspace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logspace. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.logspace also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First value in the range in log space. base ** start is the starting value</span>
<span class="sd">        in the sequence. Can be an array or a float.</span>
<span class="sd">    stop</span>
<span class="sd">        Last value in the range in log space. base ** stop is the final value in the</span>
<span class="sd">        sequence. Can be an array or a float.</span>
<span class="sd">    num</span>
<span class="sd">        Number of values to generate.</span>
<span class="sd">    base</span>
<span class="sd">        The base of the log space. Default is 10.0</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the operation is performed. Relevant only if start or stop</span>
<span class="sd">        are array-like. Default is 0.</span>
<span class="sd">    endpoint</span>
<span class="sd">        If True, stop is the last sample. Otherwise, it is not included. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output tensor. If None, the dtype of on_value is used</span>
<span class="sd">        or if that is None, the dtype of off_value is used, or if that is None,</span>
<span class="sd">        defaults to float32. Default is None.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc. Default</span>
<span class="sd">        is None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Tensor of evenly-spaced values in log space.</span>
<span class="sd">    Both the description and the type hints above assumes an array input for</span>
<span class="sd">    simplicity, but this function is *nestable*, and therefore also accepts</span>
<span class="sd">    :class:`ivy.Container` instances in place of any of the arguments.</span>

<span class="sd">    Functional Examples</span>
<span class="sd">    -------------------</span>
<span class="sd">    With float input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5])</span>
<span class="sd">    &gt;&gt;&gt; x.logspace(y, 4)</span>
<span class="sd">    ivy.array([[1.e+01, 1.e+02],</span>
<span class="sd">               [1.e+02, 1.e+03],</span>
<span class="sd">               [1.e+03, 1.e+04],</span>
<span class="sd">               [1.e+04, 1.e+05])</span>
<span class="sd">    &gt;&gt;&gt; x.logspace(y, 4, axis = 1)</span>
<span class="sd">    ivy.array([[[1.e+01, 1.e+02, 1.e+03, 1.e+04],</span>
<span class="sd">               [1.e+02, 1.e+03, 1.e+04, 1.e+05]]])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4])      # Broadcasting example</span>
<span class="sd">    &gt;&gt;&gt; x.logspace(y, 4)</span>
<span class="sd">    ivy.array([[10., 100.]</span>
<span class="sd">               [100., 464.15888336]</span>
<span class="sd">               [1000., 2154.43469003]</span>
<span class="sd">               [10000., 10000.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.data_type</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="n">Finfo</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">Iinfo</span> <span class="o">=</span> <span class="kc">None</span>




<div class="viewcode-block" id="astype"><a class="viewcode-back" href="../../../functional/ivy/data_type/astype/astype_array.html#ivy.array.array_methods.astype">[docs]</a><span class="k">def</span> <span class="nf">astype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of</span>
<span class="sd">    :ref:`type-promotion` rules.</span>
<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types</span>
<span class="sd">    is not specified and is implementation-dependent.</span>
<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>
<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches</span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated</span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have</span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, -2], [0, 2]])</span>
<span class="sd">    &gt;&gt;&gt; print(x.astype(ivy.float64))</span>
<span class="sd">    ivy.array([[-1., -2.],  [0.,  2.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="broadcast_arrays"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_arrays/broadcast_arrays_array.html#ivy.array.array_methods.broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An input array to be broadcasted against other input arrays.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        Each array must have the same dtype as its</span>
<span class="sd">        corresponding input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list containing broadcasted arrays of type `ivy.Array`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0.2, 0.])</span>
<span class="sd">    &gt;&gt;&gt; x3 = ivy.zeros(2)</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2, x3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([1, 2]), ivy.array([0.2, 0. ]), ivy.array([0., 0.])]</span>
<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([-1., 3.4])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.4, 5.1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([-1., 3.4]), ivy.array([2.4, 5.1])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span></div>


<div class="viewcode-block" id="broadcast_to"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_to/broadcast_to_array.html#ivy.array.array_methods.broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.broadcast_to((3,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1, 2, 3],</span>
<span class="sd">               [1, 2, 3],</span>
<span class="sd">               [1, 2, 3]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="can_cast"><a class="viewcode-back" href="../../../functional/ivy/data_type/can_cast/can_cast_array.html#ivy.array.array_methods.can_cast">[docs]</a><span class="k">def</span> <span class="nf">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.can_cast`. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for `ivy.can_cast` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">    float32</span>

<span class="sd">    &gt;&gt;&gt; print(x.can_cast(ivy.float64))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">to</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dtype()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span>


<div class="viewcode-block" id="finfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/finfo/finfo_array.html#ivy.array.array_methods.finfo">[docs]</a><span class="k">def</span> <span class="nf">finfo</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Finfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Array instance method variant of `ivy.finfo`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An instance of the `Finfo` class, containing information</span>
<span class="sd">        about the floating point data type of the input array.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.7,8.4,3.14], dtype=ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(x.finfo())</span>
<span class="sd">    finfo(resolution=1e-06, min=-3.4028235e+38, max=3.4028235e+38, dtype=float32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="iinfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/iinfo/iinfo_array.html#ivy.array.array_methods.iinfo">[docs]</a><span class="k">def</span> <span class="nf">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iinfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.iinfo`. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for `ivy.iinfo` also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An instance of the `Iinfo` class, containing information</span>
<span class="sd">        about the integer data type of the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-119,122,14], dtype=ivy.int8))</span>
<span class="sd">    &gt;&gt;&gt; x.iinfo()</span>
<span class="sd">    iinfo(min=-128, max=127, dtype=int8)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-12,54,1,9,-1220], dtype=ivy.int16))</span>
<span class="sd">    &gt;&gt;&gt; x.iinfo()</span>
<span class="sd">    iinfo(min=-32768, max=32767, dtype=int16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_bool_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_bool_dtype/is_bool_dtype_array.html#ivy.array.array_methods.is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_float_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_float_dtype/is_float_dtype_array.html#ivy.array.array_methods.is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.is_float_dtype`. This method simply</span>
<span class="sd">    checks to see if the array is of type `float`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to check for float dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean value of whether the array is of type `float`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3], dtype=ivy.int8)</span>
<span class="sd">    &gt;&gt;&gt; x.is_float_dtype()</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_int_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_int_dtype/is_int_dtype_array.html#ivy.array.array_methods.is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_int_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_int_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_uint_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_uint_dtype/is_uint_dtype_array.html#ivy.array.array_methods.is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_uint_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_uint_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="result_type"><a class="viewcode-back" href="../../../functional/ivy/data_type/result_type/result_type_array.html#ivy.array.array_methods.result_type">[docs]</a><span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Array` instance method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">    int32</span>

<span class="sd">    &gt;&gt;&gt; x.result_type(ivy.float64)</span>
<span class="sd">    &lt;dtype:&#39;float64&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">)</span></div>


<span class="c1">#ivy.array.device</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="dev"><a class="viewcode-back" href="../../../functional/ivy/device/dev/dev_array.html#ivy.array.array_methods.dev">[docs]</a><span class="k">def</span> <span class="nf">dev</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dev. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array for which to get the device handle.</span>
<span class="sd">    as_native</span>
<span class="sd">        Whether or not to return the dev in native format. Default is ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 5, 4, 1], [3, 1, 5, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dev(as_native=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    cpu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span></div>


<div class="viewcode-block" id="to_device"><a class="viewcode-back" href="../../../functional/ivy/device/to_device/to_device_array.html#ivy.array.array_methods.to_device">[docs]</a><span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_device. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_device also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to be moved to the desired device</span>
<span class="sd">    device</span>
<span class="sd">        device to move the input array `x` to</span>
<span class="sd">    stream</span>
<span class="sd">        stream object to use during copy. In addition to the types</span>
<span class="sd">        supported in array.__dlpack__(), implementations may choose to</span>
<span class="sd">        support any library-specific stream object with the caveat that</span>
<span class="sd">        any code using such an object would not be portable.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2, 5, 4, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_device(&#39;cpu&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.device)</span>
<span class="sd">    cpu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.elementwise</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># noinspection PyUnresolvedReferences</span>




<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../functional/ivy/elementwise/abs/abs_array.html#ivy.array.array_methods.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the absolute value of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.6, -6.6, 1.6, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.abs()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 2.6, 6.6, 1.6, 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="acosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acosh/acosh_array.html#ivy.array.array_methods.acosh">[docs]</a><span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.acosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.acosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic cosine</span>
<span class="sd">        of each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 10.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.acosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.32, 2.99, 0.  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="acos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acos/acos_array.html#ivy.array.array_methods.acos">[docs]</a><span class="k">def</span> <span class="nf">acos</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.acos. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.acos also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse cosine of each element in ``self``.</span>
<span class="sd">        The  returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.0, -0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.acos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.  , 1.57, 2.69])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../functional/ivy/elementwise/add/add_array.html#ivy.array.array_methods.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.add. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.add(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.add(y, alpha=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([9, 12, 15])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="asin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asin/asin_array.html#ivy.array.array_methods.asin">[docs]</a><span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asin. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asin also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse sine of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 1., 4., 0.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.57, 1.57, nan, 0.927])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-3., -0.9, 1.5, 2.8])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; x.asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, -1.12, nan, nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="asinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asinh/asinh_array.html#ivy.array.array_methods.asinh">[docs]</a><span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.asinh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.asinh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic sine of each element in ``self``.</span>
<span class="sd">        The returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.asinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.881,  0.   ,  1.82 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">asinh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="atan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan/atan_array.html#ivy.array.array_methods.atan">[docs]</a><span class="k">def</span> <span class="nf">atan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse tangent of each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.5, -0.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.atan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.785,  0.464, -0.464])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="atan2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan2/atan2_array.html#ivy.array.array_methods.atan2">[docs]</a><span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atan2. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan2 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``self``(see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse tangent of the quotient ``self/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 0.5, 0.0, -0.5, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1.0, 2.0, -1.5, 0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 0.785,  0.245,  3.14 , -1.57 ,  0.   ])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([-2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.zeros(2)</span>
<span class="sd">    &gt;&gt;&gt; x.atan2(y, out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([2.68 , 0.588])</span>

<span class="sd">    &gt;&gt;&gt; nan = float(&quot;nan&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([nan, 1.0, 1.0, -1.0, -1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1.0, +0, -0, +0, -0])</span>
<span class="sd">    &gt;&gt;&gt; x.atan2(y)</span>
<span class="sd">    ivy.array([  nan,  1.57,  1.57, -1.57, -1.57])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([+0, +0, +0, +0, -0, -0, -0, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1.0, +0, -0, -1.0, 1.0, +0, -0, -1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.atan2(y)</span>
<span class="sd">    ivy.array([0.  , 0.  , 0.  , 3.14, 0.  , 0.  , 0.  , 3.14])</span>

<span class="sd">    &gt;&gt;&gt; y.atan2(x)</span>
<span class="sd">    ivy.array([ 1.57,  0.  ,  0.  , -1.57,  1.57,  0.  ,  0.  , -1.57])</span>

<span class="sd">    &gt;&gt;&gt; inf = float(&quot;infinity&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([inf, -inf, inf, inf, -inf, -inf])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1.0, 1.0, inf, -inf, inf, -inf])</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 1.57 , -1.57 ,  0.785,  2.36 , -0.785, -2.36 ])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.5, -1.75, 3.2, 0, -1.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([-3.5, 2, 0, 0, 5])</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 2.52 , -0.719,  1.57 ,  0.   , -0.197])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3], [-4.4, -5.5, -6.6]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.atan2(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 0.785,  0.785,  0.785],</span>
<span class="sd">        [-2.36 , -2.36 , -2.36 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="atanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atanh/atanh_array.html#ivy.array.array_methods.atanh">[docs]</a><span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atanh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atanh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent the area of a hyperbolic sector.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the inverse hyperbolic tangent of each element</span>
<span class="sd">        in ``self``. The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.0, 0.5, -0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.atanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.   ,  0.549, -1.47 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atanh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_and/bitwise_and_array.html#ivy.array.array_methods.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True])</span>
<span class="sd">    &gt;&gt;&gt; x.bitwise_and(y, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[7],[8],[9]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.native_array([[10],[11],[12]])</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_and(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[2],[8],[8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_left_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_left_shift/bitwise_left_shift_array.html#ivy.array.array_methods.bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_left_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_left_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_invert"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_invert/bitwise_invert_array.html#ivy.array.array_methods.bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">bitwise_invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitiwse_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 6, 9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.bitwise_invert()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-2, -7, -10])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([False, True])</span>
<span class="sd">    &gt;&gt;&gt; y = x.bitwise_invert()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_or/bitwise_or_array.html#ivy.array.array_methods.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([5, 7, 7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_right_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_right_shift/bitwise_right_shift_array.html#ivy.array.array_methods.bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_right_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[2, 3, 4], [5, 10, 64]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_right_shift(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 2,  1,  1],</span>
<span class="sd">                [ 5,  5, 16]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_right_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_xor/bitwise_xor_array.html#ivy.array.array_methods.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.bitwise_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[89, 51, 32], [14, 18, 19]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([[[19, 26, 27], [22, 23, 20]]])</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_xor(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[74,41,59],[24,5,7]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../functional/ivy/elementwise/ceil/ceil_array.html#ivy.array.array_methods.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ceil also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.ceil()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 6., -2.,  2.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cos/cos_array.html#ivy.array.array_methods.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cos. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cos also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are each expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the cosine of each element in ``self``. The returned</span>
<span class="sd">        array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 0., 2.,])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.54, 1., -0.416])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-3., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; x.cos(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0.99,  1.  , -0.99])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1.,], [2., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 0.540], [-0.416, -0.990]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cosh/cosh_array.html#ivy.array.array_methods.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cosh. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cosh also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic cosine of each element in ``self``.</span>
<span class="sd">        The returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.cosh())</span>
<span class="sd">        ivy.array([1.54, 3.76, 10.1])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; print(x.cosh(out=y))</span>
<span class="sd">        ivy.array([1.03, 10.1, 1.81])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/divide/divide_array.html#ivy.array.array_methods.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 3.5, 4.5])</span>
<span class="sd">    With mixed :class:`ivy.Array` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 3.5, 4.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/equal/equal_array.html#ivy.array.array_methods.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True, True])</span>
<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 2.9, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False,  True])</span>
<span class="sd">    With mixed :class:`ivy.Array` and `float` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = 7.3</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True, False])</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/exp/exp_array.html#ivy.array.array_methods.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.exp. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated exponential function result for</span>
<span class="sd">        each element in ``self``. The returned array must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.exp())</span>
<span class="sd">    ivy.array([ 2.71828198,  7.38905573, 20.08553696])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../functional/ivy/elementwise/expm1/expm1_array.html#ivy.array.array_methods.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.expm1. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.expm1 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.expm1()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([244.   ,  -0.918,   3.48 ,   0.   ])</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5., 0.])</span>
<span class="sd">    &gt;&gt;&gt; _ = x.expm1(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([147.,   0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor/floor_array.html#ivy.array.array_methods.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.floor. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.floor also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.5, -2.5, 1.5, -0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.floor()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 5., -3.,  1.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="floor_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor_divide/floor_divide_array.html#ivy.array.array_methods.floor_divide">[docs]</a><span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.floor_divide</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([13., 7., 8.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 7.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4., 3., 1.])</span>
<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([13., 7., 8.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([3., 2., 7.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4., 3., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater/greater_array.html#ivy.array.array_methods.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.greater(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False,  True,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater_equal/greater_equal_array.html#ivy.array.array_methods.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.greater_equal(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([False,False,False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="isfinite"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isfinite/isfinite_array.html#ivy.array.array_methods.isfinite">[docs]</a><span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, ivy.nan, -ivy.inf, float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.isfinite()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="isinf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isinf/isinf_array.html#ivy.array.array_methods.isinf">[docs]</a><span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">detect_positive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">detect_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isinf. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isinf also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    detect_positive</span>
<span class="sd">        if ``True``, positive infinity is detected.</span>
<span class="sd">    detect_negative</span>
<span class="sd">        if ``True``, negative infinity is detected.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.isinf()</span>
<span class="sd">    ivy.array([False, False, False])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; x.isinf()</span>
<span class="sd">    ivy.array([[False, False, False]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1.1], [float(&#39;inf&#39;)], [-6.3]]])</span>
<span class="sd">    &gt;&gt;&gt; x.isinf()</span>
<span class="sd">    ivy.array([[[False],[True],[False]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-float(&#39;inf&#39;), float(&#39;inf&#39;), 0.0]])</span>
<span class="sd">    &gt;&gt;&gt; x.isinf()</span>
<span class="sd">    ivy.array([[ True, True, False]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.zeros((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; x.isinf()</span>
<span class="sd">    ivy.array([[False, False, False],</span>
<span class="sd">        [False, False, False],</span>
<span class="sd">        [False, False, False]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">detect_positive</span><span class="o">=</span><span class="n">detect_positive</span><span class="p">,</span>
        <span class="n">detect_negative</span><span class="o">=</span><span class="n">detect_negative</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isnan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isnan/isnan_array.html#ivy.array.array_methods.isnan">[docs]</a><span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isnan. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isnan also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([False, False, False])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([[False, False, False]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1.1], [float(&#39;inf&#39;)], [-6.3]]])</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([[[False],</span>
<span class="sd">            [False],</span>
<span class="sd">            [False]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-float(&#39;nan&#39;), float(&#39;nan&#39;), 0.0]])</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([[ True, True, False]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-float(&#39;nan&#39;), float(&#39;inf&#39;), float(&#39;nan&#39;), 0.0]])</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([[ True, False,  True, False]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.zeros((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; x.isnan()</span>
<span class="sd">    ivy.array([[False, False, False],</span>
<span class="sd">        [False, False, False],</span>
<span class="sd">        [False, False, False]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less/less_array.html#ivy.array.array_methods.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.less. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.less also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ True, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="less_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less_equal/less_equal_array.html#ivy.array.array_methods.less_equal">[docs]</a><span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:&#39;ivy.Array&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, True, False])</span>
<span class="sd">    With mixed :code:&#39;ivy.Array&#39; and :code:&#39;ivy.NativeArray&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 3.3, 9.24])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 1.1, 9.24])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, True])</span>
<span class="sd">    With mixed :code:&#39;ivy.Container&#39; and :code:&#39;ivy.Array&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.8])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([2., 1., 0.7]), b=ivy.array([3., 0.6, 1.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([True, False, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log/log_array.html#ivy.array.array_methods.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.log also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4.0, 1, -0.0, -5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.39, 0., -inf, nan])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;), -5.0, -0.0, 1.0, 5.0, float(&#39;+inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, nan, -inf, 0., 1.61, inf])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[float(&#39;nan&#39;), 1, 5.0, float(&#39;+inf&#39;)],</span>
<span class="sd">    ...                [+0, -1.0, -5, float(&#39;-inf&#39;)]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[nan, 0., 1.61, inf],</span>
<span class="sd">               [-inf, nan, nan, nan]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log1p/log1p_array.html#ivy.array.array_methods.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 2 ,3 ])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log1p()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.693, 1.1  , 1.39 ])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1 , .001 ])</span>
<span class="sd">    &gt;&gt;&gt; x.log1p(out = x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([0.0953, 0.001 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log2/log2_array.html#ivy.array.array_methods.log2">[docs]</a><span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated base ``2`` logarithm for each element</span>
<span class="sd">        in ``self``. The returned array must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="log10"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log10/log10_array.html#ivy.array.array_methods.log10">[docs]</a><span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.log10. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.log10 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated base ``10`` logarithm for each element</span>
<span class="sd">        in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4.0, 1, -0.0, -5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.602, 0., -inf, nan])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;), -5.0, -0.0, 1.0, 5.0, float(&#39;+inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([nan, nan, -inf, 0., 0.699, inf])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[float(&#39;nan&#39;), 1, 5.0, float(&#39;+inf&#39;)],</span>
<span class="sd">    ...                [+0, -1.0, -5, float(&#39;-inf&#39;)]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[nan, 0., 0.699, inf],</span>
<span class="sd">               [-inf, nan, nan, nan]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logaddexp/logaddexp_array.html#ivy.array.array_methods.logaddexp">[docs]</a><span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logaddexp.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logaddexp also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logaddexp(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 3.31,  5.05, 15.  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_and/logical_and_array.html#ivy.array.array_methods.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Array&#39; instance:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True, False, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_and(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([True, False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_not/logical_not_array.html#ivy.array.array_methods.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([0,1,1,0])</span>
<span class="sd">    &gt;&gt;&gt; x.logical_not()</span>
<span class="sd">    ivy.array([ True, False, False,  True])</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([2,0,3,9])</span>
<span class="sd">    &gt;&gt;&gt; x.logical_not()</span>
<span class="sd">    ivy.array([False,  True, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_or/logical_or_array.html#ivy.array.array_methods.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.elementwise_functions.logical_or.html&gt;`_ </span>
<span class="sd">    in the standard.</span>
<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :class:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([False, 3, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([2, True, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ True,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_xor/logical_xor_array.html#ivy.array.array_methods.logical_xor">[docs]</a><span class="k">def</span> <span class="nf">logical_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([True, True, False, False])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_xor(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([False,  True,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../functional/ivy/elementwise/multiply/multiply_array.html#ivy.array.array_methods.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.multiply also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with the first input array.</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 5., 7.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([4., 6., 8.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([12., 30., 56.])</span>
<span class="sd">    With mixed :code:`ivy.Array` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([8., 6., 7.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 8., 12., 21.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/maximum/maximum_array.html#ivy.array.array_methods.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the maximum. If ``False``, the</span>
<span class="sd">        maximum is calculated using the ``(x + y + |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([7, 9, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([9, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.maximum(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([9, 9, 5])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 5, 9, 8, 3, 7])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([[9], [3], [2]])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.zeros((3, 6))</span>
<span class="sd">    &gt;&gt;&gt; x.maximum(y, out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[9.,9.,9.,9.,9.,9.],</span>
<span class="sd">               [3.,5.,9.,8.,3.,7.],</span>
<span class="sd">               [2.,5.,9.,8.,3.,7.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[7, 3]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0, 7])</span>
<span class="sd">    &gt;&gt;&gt; x.maximum(y, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[7, 7]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/minimum/minimum_array.html#ivy.array.array_methods.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.minimum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.minimum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing minimum values, must be broadcastable to x1.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the minimum. If ``False``, the</span>
<span class="sd">        minimum is calculated using the ``(x + y - |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not exceed the x2 values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([7, 9, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([9, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.minimum(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([7, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 5, 9, 8, 3, 7])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([[9], [3], [2]])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.zeros((3, 6))</span>
<span class="sd">    &gt;&gt;&gt; x.minimum(y, out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[1.,5.,9.,8.,3.,7.],</span>
<span class="sd">               [1.,3.,3.,3.,3.,3.],</span>
<span class="sd">               [1.,2.,2.,2.,2.,2.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[7, 3]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0, 7])</span>
<span class="sd">    &gt;&gt;&gt; x.minimum(y, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[0, 3]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../../functional/ivy/elementwise/negative/negative_array.html#ivy.array.array_methods.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2, 3 ,5, 7])</span>
<span class="sd">    &gt;&gt;&gt; y = x.negative()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-2, -3, -5, -7])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0,-1,-0.5,2,3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(5)</span>
<span class="sd">    &gt;&gt;&gt; x.negative(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-0. ,  1. ,  0.5, -2. , -3. ])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3],</span>
<span class="sd">    ...                [-4.4, -5.5, -6.6]])</span>
<span class="sd">    &gt;&gt;&gt; x.negative(out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[ -1.1, -2.2, -3.3],</span>
<span class="sd">    [4.4, 5.5, 6.6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/not_equal/not_equal_array.html#ivy.array.array_methods.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results. The returned</span>
<span class="sd">        array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, False])</span>
<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2.5, 2.9, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([False, True,  False])</span>
<span class="sd">    With mixed :class:`ivy.Array` and `float` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2.5, 7.3, 9.375])</span>
<span class="sd">    &gt;&gt;&gt; x2 = 7.3</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([True, False, True])</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="positive"><a class="viewcode-back" href="../../../functional/ivy/elementwise/positive/positive_array.html#ivy.array.array_methods.positive">[docs]</a><span class="k">def</span> <span class="nf">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2, 3 ,5, 7])</span>
<span class="sd">    &gt;&gt;&gt; y = x.positive()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 3, 5, 7])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, -1, -0.5, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(5)</span>
<span class="sd">    &gt;&gt;&gt; x.positive(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., -1., -0.5,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3],</span>
<span class="sd">    ...                [-4.4, -5.5, -6.6]])</span>
<span class="sd">    &gt;&gt;&gt; x.positive(out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[ 1.1,  2.2,  3.3],</span>
<span class="sd">    [-4.4, -5.5, -6.6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="pow"><a class="viewcode-back" href="../../../functional/ivy/elementwise/pow/pow_array.html#ivy.array.array_methods.pow">[docs]</a><span class="k">def</span> <span class="nf">pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.pow. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.pow also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array whose elements correspond to the exponentiation base.</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array whose elements correspond to the exponentiation</span>
<span class="sd">        exponent. Must be compatible with ``self`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.pow(3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 8, 27])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.5, -0.8, 0.3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; x.pow(2, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2.25, 0.64, 0.09])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="remainder"><a class="viewcode-back" href="../../../functional/ivy/elementwise/remainder/remainder_array.html#ivy.array.array_methods.remainder">[docs]</a><span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        Each element-wise result must have the same sign as the respective</span>
<span class="sd">        element ``x2_i``. The returned array must have a data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 5., 15.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 1., 3.])</span>
<span class="sd">    With mixed :class:`ivy.Array` and :class:`ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([11., 4., 18.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([2., 5., 8.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 4., 2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../functional/ivy/elementwise/round/round_array.html#ivy.array.array_methods.round">[docs]</a><span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.round. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.round also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([6.3, -8.1, 0.5, -4.2, 6.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 6., -8.,  0., -4.,  7.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-94.2, 256.0, 0.0001, -5.5, 36.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-94., 256., 0., -6., 37.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; x.round(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 0.,  3., -1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[ -1., -67.,  0.,  15.5,  1.], [3, -45, 24.7, -678.5, 32.8]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1., -67., 0., 16., 1.],</span>
<span class="sd">    [3., -45., 25., -678., 33.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sign/sign_array.html#ivy.array.array_methods.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sign. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sign also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the evaluated result for each element in ``self``. The</span>
<span class="sd">        returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, -7.1, 0, -0, 6.8])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1., -1.,  0.,  0.,  1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-94.2, 256.0, 0.0001, -0.0001, 36.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.,  1.,  1., -1.,  1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[ -1., -67.,  0.,  15.5,  1.], [3, -45, 24.7, -678.5, 32.8]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1., -1.,  0.,  1.,  1.],</span>
<span class="sd">    [ 1., -1.,  1., -1.,  1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sin/sin_array.html#ivy.array.array_methods.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sin. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sin also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are each expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the sine of each element in ``self``. The returned</span>
<span class="sd">        array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.841, 0.909, 0.141])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sinh/sinh_array.html#ivy.array.array_methods.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sinh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sinh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic sine of each element in ``self``. The</span>
<span class="sd">        returned array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; print(x.sinh())</span>
<span class="sd">        ivy.array([1.18, 3.63, 10.])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.23, 3., -1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; print(x.sinh(out=y))</span>
<span class="sd">        ivy.array([0.232, 10., -1.51])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../functional/ivy/elementwise/square/square_array.html#ivy.array.array_methods.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the square of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.square()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 4, 9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.2, 2, 3.1], [-1, -2.5, -9]])</span>
<span class="sd">    &gt;&gt;&gt; x.square(out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[1.44,4.,9.61],[1.,6.25,81.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sqrt/sqrt_array.html#ivy.array.array_methods.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sqrt. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sqrt also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the square root of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.],  [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sqrt()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1.  , 1.41],</span>
<span class="sd">               [1.73, 2.  ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../functional/ivy/elementwise/subtract/subtract_array.html#ivy.array.array_methods.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise differences. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.subtract(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([4, 0, -3])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5., 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; z = x.subtract(y, alpha=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([-3., -5., -9.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tan/tan_array.html#ivy.array.array_methods.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the tangent of each element in ``self``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 1.56, -2.19])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="tanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tanh/tanh_array.html#ivy.array.array_methods.tanh">[docs]</a><span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tanh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tanh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the hyperbolic tangent of each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.762, 0.964])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc/trunc_array.html#ivy.array.array_methods.trunc">[docs]</a><span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trunc. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.trunc also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0.54, 3.67, -0.025])</span>
<span class="sd">    &gt;&gt;&gt; y = x.trunc()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1.,  0.,  3., -0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="erf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/erf/erf_array.html#ivy.array.array_methods.erf">[docs]</a><span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.erf. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.erf also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to compute exponential for.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Gauss error of ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 0.3, 0.7, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.erf()</span>
<span class="sd">    ivy.array([0., 0.328, 0.677, 0.842])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="reciprocal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/reciprocal/reciprocal_array.html#ivy.array.array_methods.reciprocal">[docs]</a><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.reciprocal.This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reciprocal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to compute the element-wise reciprocal for.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise reciprocal of ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.reciprocal()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 0.5, 0.333])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="deg2rad"><a class="viewcode-back" href="../../../functional/ivy/elementwise/deg2rad/deg2rad_array.html#ivy.array.array_methods.deg2rad">[docs]</a><span class="k">def</span> <span class="nf">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.deg2rad.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.deg2rad also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. to be converted from degrees to radians.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise conversion from degrees to radians.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([90,180,270,360])</span>
<span class="sd">    &gt;&gt;&gt; y=x.deg2rad()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.57, 3.14, 4.71, 6.28])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="rad2deg"><a class="viewcode-back" href="../../../functional/ivy/elementwise/rad2deg/rad2deg_array.html#ivy.array.array_methods.rad2deg">[docs]</a><span class="k">def</span> <span class="nf">rad2deg</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.rad2deg.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.rad2deg also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. to be converted from degrees to radians.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise conversion from radians to degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.array([1,5,8,10])</span>
<span class="sd">    &gt;&gt;&gt; y=x.rad2deg()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 57.3, 286. , 458. , 573. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="trunc_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc_divide/trunc_divide_array.html#ivy.array.array_methods.trunc_divide">[docs]</a><span class="k">def</span> <span class="nf">trunc_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trunc_divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.trunc_divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise results.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2., 7., 9.])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., -2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.trunc_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1., -3.,  4.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">trunc_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="isreal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isreal/isreal_array.html#ivy.array.array_methods.isreal">[docs]</a><span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isreal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isreal also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is real number and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1j, 2+5j, 3.7-6j])</span>
<span class="sd">    &gt;&gt;&gt; x.isreal()</span>
<span class="sd">    ivy.array([False, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.experimental</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy</span> <span class="kn">import</span> <span class="n">handle_view</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>




<div class="viewcode-block" id="dirichlet"><a class="viewcode-back" href="../../../functional/ivy/experimental/dirichlet/dirichlet_array.html#ivy.array.array_methods.dirichlet">[docs]</a><span class="k">def</span> <span class="nf">dirichlet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.dirichlet. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.shuffle also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Sequence of floats of length k</span>
<span class="sd">    size</span>
<span class="sd">        optional int or tuple of ints, Output shape. If the given shape is,</span>
<span class="sd">        e.g., (m, n), then m * n * k samples are drawn. Default is None,</span>
<span class="sd">        in which case a vector of length k is returned.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The drawn samples, of shape (size, k).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; alpha = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; alpha.dirichlet()</span>
<span class="sd">    ivy.array([0.10598304, 0.21537054, 0.67864642])</span>

<span class="sd">    &gt;&gt;&gt; alpha = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; alpha.dirichlet(size = (2,3))</span>
<span class="sd">    ivy.array([[[0.48006698, 0.07472073, 0.44521229],</span>
<span class="sd">        [0.55479872, 0.05426367, 0.39093761],</span>
<span class="sd">        [0.19531053, 0.51675832, 0.28793114]],</span>
<span class="sd">    [[0.12315625, 0.29823365, 0.5786101 ],</span>
<span class="sd">        [0.15564976, 0.50542368, 0.33892656],</span>
<span class="sd">        [0.1325352 , 0.44439589, 0.42306891]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dirichlet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="beta"><a class="viewcode-back" href="../../../functional/ivy/experimental/beta/beta_array.html#ivy.array.array_methods.beta">[docs]</a><span class="k">def</span> <span class="nf">beta</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.beta. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.beta also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input Array.</span>
<span class="sd">    alpha</span>
<span class="sd">        The first parameter of the beta distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The second parameter of the beta distribution.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array.</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized beta distribution with the shape of</span>
<span class="sd">        the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gamma"><a class="viewcode-back" href="../../../functional/ivy/experimental/gamma/gamma_array.html#ivy.array.array_methods.gamma">[docs]</a><span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.gamma. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gamma also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input Array.</span>
<span class="sd">    alpha</span>
<span class="sd">        The first parameter of the gamma distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The second parameter of the gamma distribution.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array.</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized gamma distribution with the shape of</span>
<span class="sd">        the input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="poisson"><a class="viewcode-back" href="../../../functional/ivy/experimental/poisson/poisson_array.html#ivy.array.array_methods.poisson">[docs]</a><span class="k">def</span> <span class="nf">poisson</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input Array of rate paramter(s). It must have a shape that is broadcastable</span>
<span class="sd">        to the requested shape</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g &#39;(m, n, k)&#39;, then &#39;m * n * k&#39; samples are drawn.</span>
<span class="sd">        (Default value = &#39;None&#39;, where &#39;ivy.shape(lam)&#39; samples are drawn)</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized poisson distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; lam = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; lam.poisson()</span>
<span class="sd">    ivy.array([1., 4., 4.])</span>

<span class="sd">    &gt;&gt;&gt; lam = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; lam.poisson(shape=(2,3))</span>
<span class="sd">    ivy.array([[0., 2., 2.],</span>
<span class="sd">               [1., 2., 3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bernoulli"><a class="viewcode-back" href="../../../functional/ivy/experimental/bernoulli/bernoulli_array.html#ivy.array.array_methods.bernoulli">[docs]</a><span class="k">def</span> <span class="nf">bernoulli</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">logits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">         An N-D Array representing the probability of a 1 event.</span>
<span class="sd">         Each entry in the Array parameterizes an independent Bernoulli</span>
<span class="sd">         distribution. Only one of logits or probs should be passed in</span>
<span class="sd">    logits</span>
<span class="sd">        An N-D Array representing the log-odds of a 1 event.</span>
<span class="sd">        Each entry in the Array parameterizes an independent Bernoulli</span>
<span class="sd">        distribution where the probability of an event is sigmoid</span>
<span class="sd">        (logits). Only one of logits or probs should be passed in.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g &#39;(m, n, k)&#39;, then &#39;m * n * k&#39; samples are drawn.</span>
<span class="sd">        (Default value = &#39;None&#39;, where &#39;ivy.shape(logits)&#39; samples are drawn)</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the Bernoulli distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logits</span><span class="o">=</span><span class="n">logits</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sinc"><a class="viewcode-back" href="../../../functional/ivy/experimental/sinc/sinc_array.html#ivy.array.array_methods.sinc">[docs]</a><span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sinc. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sinc also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are each expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the sinc of each element in ``self``. The returned</span>
<span class="sd">        array must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.5, 1.5, 2.5, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sinc()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.637,-0.212,0.127,-0.0909])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="lcm"><a class="viewcode-back" href="../../../functional/ivy/experimental/lcm/lcm_array.html#ivy.array.array_methods.lcm">[docs]</a><span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.lcm. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.lcm also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array that includes the element-wise least common multiples</span>
<span class="sd">        of &#39;self&#39; and x2</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1=ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x2=ivy.array([5, 8, 15])</span>
<span class="sd">    &gt;&gt;&gt; x1.lcm(x2)</span>
<span class="sd">    ivy.array([10, 21, 60])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmod"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmod/fmod_array.html#ivy.array.array_methods.fmod">[docs]</a><span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.fmod. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fmod also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with element-wise remainder of divisions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 5, 2])</span>
<span class="sd">    &gt;&gt;&gt; x1.fmod(x2)</span>
<span class="sd">    ivy.array([ 0,  3,  0])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([ivy.nan, 0, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, ivy.nan, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x1.fmod(x2)</span>
<span class="sd">    ivy.array([ nan,  nan,  nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmax"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmax/fmax_array.html#ivy.array.array_methods.fmax">[docs]</a><span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.fmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fmax also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with element-wise maximums.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 5, 2])</span>
<span class="sd">    &gt;&gt;&gt; ivy.fmax(x1, x2)</span>
<span class="sd">    ivy.array([ 2.,  5.,  4.])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([ivy.nan, 0, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, ivy.nan, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x1.fmax(x2)</span>
<span class="sd">    ivy.array([ 0,  0,  nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmin"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmin/fmin_array.html#ivy.array.array_methods.fmin">[docs]</a><span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.fmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fmin also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with element-wise minimums.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 5, 2])</span>
<span class="sd">    &gt;&gt;&gt; ivy.fmin(x1, x2)</span>
<span class="sd">    ivy.array([1, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([ivy.nan, 0, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, ivy.nan, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x1.fmin(x2)</span>
<span class="sd">    ivy.array([ 0.,  0., nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="trapz"><a class="viewcode-back" href="../../../functional/ivy/experimental/trapz/trapz_array.html#ivy.array.array_methods.trapz">[docs]</a><span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.trapz. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.trapz also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array that should be integrated.</span>
<span class="sd">    x</span>
<span class="sd">        The sample points corresponding to the input array values.</span>
<span class="sd">        If x is None, the sample points are assumed to be evenly spaced</span>
<span class="sd">        dx apart. The default is None.</span>
<span class="sd">    dx</span>
<span class="sd">        The spacing between sample points when x is None. The default is 1.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to integrate.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Definite integral of n-dimensional array as approximated along</span>
<span class="sd">        a single axis by the trapezoidal rule. If the input array is a</span>
<span class="sd">        1-dimensional array, then the result is a float. If n is greater</span>
<span class="sd">        than 1, then the result is an n-1 dimensional array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ivy.trapz(y)</span>
<span class="sd">    4.0</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 6, 8])</span>
<span class="sd">    &gt;&gt;&gt; ivy.trapz(y, x=x)</span>
<span class="sd">    8.0</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ivy.trapz(y, dx=2)</span>
<span class="sd">    8.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="float_power"><a class="viewcode-back" href="../../../functional/ivy/experimental/float_power/float_power_array.html#ivy.array.array_methods.float_power">[docs]</a><span class="k">def</span> <span class="nf">float_power</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.float_power. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.float_power also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array-like with elements to raise in power.</span>
<span class="sd">    x2</span>
<span class="sd">        Array-like of exponents. If x1.shape != x2.shape,</span>
<span class="sd">        they must be broadcastable to a common shape</span>
<span class="sd">        (which becomes the shape of the output).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The bases in x1 raised to the exponents in x2.</span>
<span class="sd">        This is a scalar if both x1 and x2 are scalars</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; x1.float_power(3)</span>
<span class="sd">    ivy.array([1.,    8.,   27.,   64.,  125.])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 3, 3, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; x1.float_power(x2)</span>
<span class="sd">    ivy.array([1.,   8.,  27.,  16.,   5.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">float_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="exp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/exp2/exp2_array.html#ivy.array.array_methods.exp2">[docs]</a><span class="k">def</span> <span class="nf">exp2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.exp2. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp2 also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array-like input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Element-wise 2 to the power x. This is a scalar if x is a scalar.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.exp2()</span>
<span class="sd">    ivy.array([2.,    4.,   8.])</span>

<span class="sd">    &gt;&gt;&gt; x = [5, 6, 7]</span>
<span class="sd">    &gt;&gt;&gt; x.exp2()</span>
<span class="sd">    ivy.array([32.,   64.,  128.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exp2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="copysign"><a class="viewcode-back" href="../../../functional/ivy/experimental/copysign/copysign_array.html#ivy.array.array_methods.copysign">[docs]</a><span class="k">def</span> <span class="nf">copysign</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">Number</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">Number</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.copysign. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.copysign also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Array or scalar to change the sign of</span>
<span class="sd">    x2</span>
<span class="sd">        Array or scalar from which the new signs are applied</span>
<span class="sd">        Unsigned zeroes are considered positive.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        x1 with the signs of x2.</span>
<span class="sd">        This is a scalar if both x1 and x2 are scalars.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([-1, 1, -2, 2])</span>
<span class="sd">    &gt;&gt;&gt; x1.copysign(x2)</span>
<span class="sd">    ivy.array([-0.,  1., -2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; x2.copysign(-1)</span>
<span class="sd">    ivy.array([-1., -1., -2., -2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_nonzero"><a class="viewcode-back" href="../../../functional/ivy/experimental/count_nonzero/count_nonzero_array.html#ivy.array.array_methods.count_nonzero">[docs]</a><span class="k">def</span> <span class="nf">count_nonzero</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.count_nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.count_nonzero also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array for which to count non-zeros.</span>
<span class="sd">    axis</span>
<span class="sd">        optional axis or tuple of axes along which to count non-zeros. Default is</span>
<span class="sd">        None, meaning that non-zeros will be counted along a flattened</span>
<span class="sd">        version of the input array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional, if this is set to True, the axes that are counted are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the input array.</span>
<span class="sd">    dtype</span>
<span class="sd">        optional output dtype. Default is of type integer.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       Number of non-zero values in the array along a given axis. Otherwise,</span>
<span class="sd">       the total number of non-zero values in the array is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero()</span>
<span class="sd">    ivy.array(3)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero(axis=0)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">           [2, 2]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero(axis=(0,1), keepdims=True)</span>
<span class="sd">    ivy.array([[[3, 4]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nansum"><a class="viewcode-back" href="../../../functional/ivy/experimental/nansum/nansum_array.html#ivy.array.array_methods.nansum">[docs]</a><span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.nansum. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nansum also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the sum is computed.</span>
<span class="sd">        The default is to compute the sum of the flattened array.</span>
<span class="sd">    dtype</span>
<span class="sd">        The type of the returned array and of the accumulator in</span>
<span class="sd">        which the elements are summed. By default, the dtype of input is used.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[ 2.1,  3.4,  ivy.nan], [ivy.nan, 2.4, 2.1]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.nansum(a)</span>
<span class="sd">    10.0</span>

<span class="sd">    &gt;&gt;&gt; ivy.nansum(a, axis=0)</span>
<span class="sd">    ivy.array([2.1, 5.8, 2.1])</span>

<span class="sd">    &gt;&gt;&gt; ivy.nansum(a, axis=1)</span>
<span class="sd">    ivy.array([5.5, 4.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gcd"><a class="viewcode-back" href="../../../functional/ivy/experimental/gcd/gcd_array.html#ivy.array.array_methods.gcd">[docs]</a><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.gcd. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gcd also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First array-like input.</span>
<span class="sd">    x2</span>
<span class="sd">        Second array-like input</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Element-wise gcd of |x1| and |x2|.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; x1.gcd(x2)</span>
<span class="sd">    ivy.array([1.,    1.,   3.])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x1.gcd(10)</span>
<span class="sd">    ivy.array([1.,   2.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="isclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/isclose/isclose_array.html#ivy.array.array_methods.isclose">[docs]</a><span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.isclose. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.isclose also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    b</span>
<span class="sd">        Second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in a will be</span>
<span class="sd">        considered equal to NaN&#39;s in b in the output array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[ 2.1,  3.4,  ivy.nan], [ivy.nan, 2.4, 2.1]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([[ 2.1,  3.4,  ivy.nan], [ivy.nan, 2.4, 2.1]])</span>
<span class="sd">    &gt;&gt;&gt; a.isclose(b)</span>
<span class="sd">    ivy.array([[True, True, False],</span>
<span class="sd">           [False, True, True]])</span>

<span class="sd">    &gt;&gt;&gt; a.isclose(b, equal_nan=True)</span>
<span class="sd">    ivy.array([[True, True, True],</span>
<span class="sd">           [True, True, True]])</span>

<span class="sd">    &gt;&gt;&gt; a=ivy.array([1.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; b=ivy.array([1.0, 2.001])</span>
<span class="sd">    &gt;&gt;&gt; a.isclose(b, atol=0.0)</span>
<span class="sd">    ivy.array([True, False])</span>

<span class="sd">    &gt;&gt;&gt; a.isclose(b, rtol=0.01, atol=0.0)</span>
<span class="sd">    ivy.array([True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../../functional/ivy/experimental/angle/angle_array.html#ivy.array.array_methods.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.angle. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.angle also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z</span>
<span class="sd">        Array-like input.</span>
<span class="sd">    deg</span>
<span class="sd">        optional bool.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array of angles for each complex number in the input.</span>
<span class="sd">        If def is False(default), angle is calculated in radian and if</span>
<span class="sd">        def is True, then angle is calculated in degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ivy.set_backend(&#39;tensorflow&#39;)</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.array([-1 + 1j, -2 + 2j, 3 - 3j])</span>
<span class="sd">    &gt;&gt;&gt; z</span>
<span class="sd">    ivy.array([-1.+1.j, -2.+2.j,  3.-3.j])</span>

<span class="sd">    &gt;&gt;&gt; ivy.angle(z)</span>
<span class="sd">    ivy.array([ 2.35619449,  2.35619449, -0.78539816])</span>

<span class="sd">    &gt;&gt;&gt; ivy.set_backend(&#39;numpy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ivy.angle(z,deg=True)</span>
<span class="sd">    ivy.array([135., 135., -45.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="imag"><a class="viewcode-back" href="../../../functional/ivy/experimental/imag/imag_array.html#ivy.array.array_methods.imag">[docs]</a><span class="k">def</span> <span class="nf">imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.imag. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.imag also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array-like input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the imaginary part of complex numbers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array(np.array([1+2j, 3+4j, 5+6j]))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    ivy.array([1.+2.j, 3.+4.j, 5.+6.j])</span>

<span class="sd">    &gt;&gt;&gt; ivy.imag(b)</span>
<span class="sd">    ivy.array([2., 4., 6.])</span>

<span class="sd">    &gt;&gt;&gt; b.imag()</span>
<span class="sd">    ivy.array([2., 4., 6.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="nan_to_num"><a class="viewcode-back" href="../../../functional/ivy/experimental/nan_to_num/nan_to_num_array.html#ivy.array.array_methods.nan_to_num">[docs]</a><span class="k">def</span> <span class="nf">nan_to_num</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">nan</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">posinf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neginf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.nan_to_num. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nan_to_num also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array input.</span>
<span class="sd">    copy</span>
<span class="sd">        Whether to create a copy of x (True) or to replace values in-place (False).</span>
<span class="sd">        The in-place operation only occurs if casting to an array does not require</span>
<span class="sd">        a copy. Default is True.</span>
<span class="sd">    nan</span>
<span class="sd">        Value to be used to fill NaN values. If no value is passed then NaN values</span>
<span class="sd">        will be replaced with 0.0.</span>
<span class="sd">    posinf</span>
<span class="sd">        Value to be used to fill positive infinity values. If no value is passed</span>
<span class="sd">        then positive infinity values will be replaced with a very large number.</span>
<span class="sd">    neginf</span>
<span class="sd">        Value to be used to fill negative infinity values.</span>
<span class="sd">        If no value is passed then negative infinity values</span>
<span class="sd">        will be replaced with a very small (or negative) number.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with the non-finite values replaced.</span>
<span class="sd">        If copy is False, this may be x itself.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, nan])</span>
<span class="sd">    &gt;&gt;&gt; x.nan_to_num()</span>
<span class="sd">    ivy.array([1.,    1.,   3.,   0.0])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, inf])</span>
<span class="sd">    &gt;&gt;&gt; x.nan_to_num(posinf=5e+100)</span>
<span class="sd">    ivy.array([1.,   2.,   3.,   5e+100])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/logaddexp2/logaddexp2_array.html#ivy.array.array_methods.logaddexp2">[docs]</a><span class="k">def</span> <span class="nf">logaddexp2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.logaddexp2. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.logaddexp2 also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First array-like input.</span>
<span class="sd">    x2</span>
<span class="sd">        Second array-like input</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Element-wise logaddexp2 of x1 and x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; x1.logaddexp2(x2)</span>
<span class="sd">    ivy.array([4.169925, 5.169925, 6.169925])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logaddexp2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="signbit"><a class="viewcode-back" href="../../../functional/ivy/experimental/signbit/signbit_array.html#ivy.array.array_methods.signbit">[docs]</a><span class="k">def</span> <span class="nf">signbit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.signbit. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.signbit also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array-like input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Element-wise signbit of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, -2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.signbit()</span>
<span class="sd">    ivy.array([False, True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="hypot"><a class="viewcode-back" href="../../../functional/ivy/experimental/hypot/hypot_array.html#ivy.array.array_methods.hypot">[docs]</a><span class="k">def</span> <span class="nf">hypot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.hypot. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.hypot also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array containing the hypotenuse computed from each element of the</span>
<span class="sd">        input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([3.0, 4.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([4.0, 5.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; x.hypot(y)</span>
<span class="sd">    ivy.array([5.0, 6.4031, 7.8102])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="allclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/allclose/allclose_array.html#ivy.array.array_methods.allclose">[docs]</a><span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.allclose. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.allclose also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in a will be</span>
<span class="sd">        considered equal to NaN&#39;s in b in the output array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns True if the two arrays are equal within the given tolerance;</span>
<span class="sd">        False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1e10, 1e-7])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1.00001e10, 1e-8])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.allclose(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(False)</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1.0, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1.0, ivy.nan])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.allclose(x2, equal_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(True)</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1e-10, 1e-10])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1.00001e-10, 1e-10])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.allclose(x2, rtol=0.005, atol=0.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../functional/ivy/experimental/diff/diff_array.html#ivy.array.array_methods.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">prepend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">append</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.diff. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.diff also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array-like input.</span>
<span class="sd">    n</span>
<span class="sd">        The number of times values are differenced. If zero, the input is returned</span>
<span class="sd">        as-is.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which the difference is taken, default is the last axis.</span>
<span class="sd">    prepend,append</span>
<span class="sd">        Values to prepend/append to x along given axis prior to performing the</span>
<span class="sd">        difference. Scalar values are expanded to arrays with length 1 in the</span>
<span class="sd">        direction of axis and the shape of the input array in along all other</span>
<span class="sd">        axes. Otherwise the dimension and shape must match x except along axis.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the n-th discrete difference along the given axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 4, 7, 0])</span>
<span class="sd">    &gt;&gt;&gt; x.diff()</span>
<span class="sd">    ivy.array([ 1,  2,  3, -7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fix"><a class="viewcode-back" href="../../../functional/ivy/experimental/fix/fix_array.html#ivy.array.array_methods.fix">[docs]</a><span class="k">def</span> <span class="nf">fix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.fix. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.fix also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array of floats with elements corresponding to input elements</span>
<span class="sd">        rounded to nearest integer towards zero, element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([2.1, 2.9, -2.1])</span>
<span class="sd">    &gt;&gt;&gt; x.fix()</span>
<span class="sd">    ivy.array([ 2.,  2., -2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="nextafter"><a class="viewcode-back" href="../../../functional/ivy/experimental/nextafter/nextafter_array.html#ivy.array.array_methods.nextafter">[docs]</a><span class="k">def</span> <span class="nf">nextafter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.nextafter. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nextafter also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Second input array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The next representable values of x1 in the direction of x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1.0e-50, 2.0e+50])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x1.nextafter(x2)</span>
<span class="sd">    ivy.array([1.4013e-45., 3.4028e+38])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="zeta"><a class="viewcode-back" href="../../../functional/ivy/experimental/zeta/zeta_array.html#ivy.array.array_methods.zeta">[docs]</a><span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.zeta. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeta also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    q</span>
<span class="sd">        Second input array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with values computed from zeta function from</span>
<span class="sd">        input arrays&#39; values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; q = ivy.array([2.0])</span>
<span class="sd">    &gt;&gt;&gt; x.zeta(q)</span>
<span class="sd">    ivy.array([0.0369, 0.2021])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="gradient"><a class="viewcode-back" href="../../../functional/ivy/experimental/gradient/gradient_array.html#ivy.array.array_methods.gradient">[docs]</a><span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">spacing</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">edge_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates gradient of x with respect to (w.r.t.) spacing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array representing outcomes of the function</span>
<span class="sd">    spacing</span>
<span class="sd">        if not given, indices of x will be used</span>
<span class="sd">        if scalar indices of x will be scaled with this value</span>
<span class="sd">        if array gradient of x w.r.t. spacing</span>
<span class="sd">    edge_order</span>
<span class="sd">        1 or 2, for &#39;first order&#39; and &#39;second order&#39; estimation</span>
<span class="sd">        of boundary values of gradient respectively.</span>
<span class="sd">        Note: jax supports edge_order=1 case only</span>
<span class="sd">    axis</span>
<span class="sd">        dimension(s) to approximate the gradient over</span>
<span class="sd">        by default partial gradient is computed in every dimention</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with values computed from gradient function from</span>
<span class="sd">        inputs</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; spacing = (ivy.array([-2., -1., 1., 4.]),)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4., 1., 1., 16.], )</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x, spacing=spacing)</span>
<span class="sd">    ivy.array([-3., -2.,  2.,  5.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 4, 8], [10, 20, 40, 80]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x)</span>
<span class="sd">    [ivy.array([[ 9., 18., 36., 72.],</span>
<span class="sd">       [ 9., 18., 36., 72.]]), ivy.array([[ 1. ,  1.5,  3. ,  4. ],</span>
<span class="sd">       [10. , 15. , 30. , 40. ]])]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 4, 8], [10, 20, 40, 80]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x, spacing=2.0)</span>
<span class="sd">    [ivy.array([[ 4.5,  9. , 18. , 36. ],</span>
<span class="sd">       [ 4.5,  9. , 18. , 36. ]]), ivy.array([[ 0.5 ,  0.75,  1.5 ,  2.  ],</span>
<span class="sd">       [ 5.  ,  7.5 , 15.  , 20.  ]])]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 4, 8], [10, 20, 40, 80]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x, axis=1)</span>
<span class="sd">    ivy.array([[ 1. ,  1.5,  3. ,  4. ],</span>
<span class="sd">       [10. , 15. , 30. , 40. ]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 4, 8], [10, 20, 40, 80]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x, spacing=[3., 2.])</span>
<span class="sd">    [ivy.array([[ 3.,  6., 12., 24.],</span>
<span class="sd">       [ 3.,  6., 12., 24.]]), ivy.array([[ 0.5 ,  0.75,  1.5 ,  2.  ],</span>
<span class="sd">       [ 5.  ,  7.5 , 15.  , 20.  ]])]</span>

<span class="sd">    &gt;&gt;&gt; spacing = (ivy.array([0, 2]), ivy.array([0, 3, 6, 9]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.gradient(x, spacing=spacing)</span>
<span class="sd">    [ivy.array([[ 4.5,  9. , 18. , 36. ],</span>
<span class="sd">       [ 4.5,  9. , 18. , 36. ]]), ivy.array([[ 0.33333333,  0.5,  1., 1.33333333],</span>
<span class="sd">       [ 3.33333333,  5.        , 10.        , 13.33333333]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="xlogy"><a class="viewcode-back" href="../../../functional/ivy/experimental/xlogy/xlogy_array.html#ivy.array.array_methods.xlogy">[docs]</a><span class="k">def</span> <span class="nf">xlogy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.xlogy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.xlogy also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        First input array.</span>
<span class="sd">    y</span>
<span class="sd">        Second input array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The next representable values of x1 in the direction of x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([-1.0, 0.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.xlogy(y)</span>
<span class="sd">    ivy.array([0.0, 0.0, 0.0])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.xlogy(y)</span>
<span class="sd">    ivy.array([1.0986, 1.3863, 0.0000])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">xlogy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="real"><a class="viewcode-back" href="../../../functional/ivy/experimental/real/real_array.html#ivy.array.array_methods.real">[docs]</a><span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.real. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.real also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a real-valued floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing test results. If input in an</span>
<span class="sd">        array is real then, it is returned unchanged. on the</span>
<span class="sd">        other hand, if it is complex then, it returns real part from it</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4+3j, 6+2j, 1-6j])</span>
<span class="sd">    &gt;&gt;&gt; x.real()</span>
<span class="sd">    ivy.array([4., 6., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="binarizer"><a class="viewcode-back" href="../../../functional/ivy/experimental/binarizer/binarizer_array.html#ivy.array.array_methods.binarizer">[docs]</a><span class="k">def</span> <span class="nf">binarizer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps the values of the input tensor to either 0 or 1, element-wise, based on</span>
<span class="sd">    the outcome of a comparison against a threshold value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">         Data to be binarized</span>
<span class="sd">    threshold</span>
<span class="sd">         Values greater than this are</span>
<span class="sd">         mapped to 1, others to 0.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Binarized output data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">binarizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="conj"><a class="viewcode-back" href="../../../functional/ivy/experimental/conj/conj_array.html#ivy.array.array_methods.conj">[docs]</a><span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.conj. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.conj also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the complex conjugates of values in the input array,</span>
<span class="sd">        with the same dtype as the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4+3j, 6+2j, 1-6j])</span>
<span class="sd">    &gt;&gt;&gt; x.conj()</span>
<span class="sd">    ivy.array([4-3j, 6-2j, 1+6j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="ldexp"><a class="viewcode-back" href="../../../functional/ivy/experimental/ldexp/ldexp_array.html#ivy.array.array_methods.ldexp">[docs]</a><span class="k">def</span> <span class="nf">ldexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.ldexp. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.ldexp also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    x2</span>
<span class="sd">        The array of exponents.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The next representable values of x1 in the direction of x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.ldexp(y)</span>
<span class="sd">    ivy.array([8.0, 8.0, 6.0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ldexp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="frexp"><a class="viewcode-back" href="../../../functional/ivy/experimental/frexp/frexp_array.html#ivy.array.array_methods.frexp">[docs]</a><span class="k">def</span> <span class="nf">frexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.frexp. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.frexp also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The next representable values of x1 in the direction of x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1.0, 2.0, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; x.frexp()</span>
<span class="sd">    ivy.array([[0.5, 0.5, 0.75], [1, 2, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">frexp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="isin"><a class="viewcode-back" href="../../../functional/ivy/experimental/isin/isin_array.html#ivy.array.array_methods.isin">[docs]</a><span class="k">def</span> <span class="nf">isin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">test_elements</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">assume_unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.isin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.isin also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    test_elements</span>
<span class="sd">        values against which to test for each input element</span>
<span class="sd">    assume_unique</span>
<span class="sd">        If True, assumes both elements and test_elements contain unique elements,</span>
<span class="sd">        which can speed up the calculation. Default value is False.</span>
<span class="sd">    invert</span>
<span class="sd">        If True, inverts the boolean return array, resulting in True values for</span>
<span class="sd">        elements not in test_elements. Default value is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        output a boolean array of the same shape as elements that is True for</span>
<span class="sd">        elements in test_elements and False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.isin(y)</span>
<span class="sd">    ivy.array([[False, False, False], [ True,  True,  True]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3, 2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x.isin(y, invert=True)</span>
<span class="sd">    ivy.array([False, False, False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="n">assume_unique</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="n">invert</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool1d/max_pool1d_array.html#ivy.array.array_methods.max_pool1d">[docs]</a><span class="k">def</span> <span class="nf">max_pool1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.max_pool1d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.max_pool1d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window for each dimension of the input tensor.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the max pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(0, 24.).reshape((2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool1d(2, 2, &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[ 4.,  5.,  6.,  7.],</span>
<span class="sd">            [ 8.,  9., 10., 11.]],</span>
<span class="sd">           [[16., 17., 18., 19.],</span>
<span class="sd">            [20., 21., 22., 23.]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(0, 24.).reshape((2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool1d(2, 2, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[ 4.,  5.,  6.,  7.]],</span>
<span class="sd">       [[16., 17., 18., 19.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">max_pool1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool2d/max_pool2d_array.html#ivy.array.array_methods.max_pool2d">[docs]</a><span class="k">def</span> <span class="nf">max_pool2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ceil_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.max_pool2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.max_pool2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window for each dimension of the input tensor.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the max pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(12.).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool2d((2, 2), (1, 1), &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[[ 2,  3],</span>
<span class="sd">             [ 4,  5],</span>
<span class="sd">             [ 4,  5]]],</span>
<span class="sd">           [[[ 8,  9],</span>
<span class="sd">             [10, 11],</span>
<span class="sd">             [10, 11]]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(48.).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool2d(3, 1, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[[16, 17]],</span>
<span class="sd">            [[22, 23]]],</span>
<span class="sd">           [[[40, 41]],</span>
<span class="sd">            [[46, 47]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">max_pool2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">,</span>
        <span class="n">ceil_mode</span><span class="o">=</span><span class="n">ceil_mode</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool3d/max_pool3d_array.html#ivy.array.array_methods.max_pool3d">[docs]</a><span class="k">def</span> <span class="nf">max_pool3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a 3-D max pool given 5-D input x.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(48.).reshape((2, 3, 2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool3d(2, 2, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[[[14., 15.]]]],</span>
<span class="sd">       [[[[38., 39.]]]]])</span>

<span class="sd">    &gt;&gt;&gt; print(x.max_pool3d(2, 2, &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[[[14., 15.]]],</span>
<span class="sd">        [[[22., 23.]]]],</span>
<span class="sd">       [[[[38., 39.]]],</span>
<span class="sd">        [[[46., 47.]]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">max_pool3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool1d/avg_pool1d_array.html#ivy.array.array_methods.avg_pool1d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.avg_pool1d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.avg_pool1d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window for each dimension of the input tensor.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the max pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(0, 24.).reshape((2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; print(x.avg_pool1d(2, 2, &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[ 2.,  3.,  4.,  5.],</span>
<span class="sd">            [ 8.,  9., 10., 11.]],</span>
<span class="sd">           [[14., 15., 16., 17.],</span>
<span class="sd">            [20., 21., 22., 23.]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(0, 24.).reshape((2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; print(x.avg_pool1d(2, 2, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[ 2.,  3.,  4.,  5.]],</span>
<span class="sd">           [[14., 15., 16., 17.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">avg_pool1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool2d/avg_pool2d_array.html#ivy.array.array_methods.avg_pool2d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.avg_pool2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.avg_pool2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window for each dimension of the input tensor.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the max pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(12.).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool2d((2, 2), (1, 1), &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[[ 2,  3],</span>
<span class="sd">    [ 4,  5],</span>
<span class="sd">    [ 4,  5]]],</span>
<span class="sd">    [[[ 8,  9],</span>
<span class="sd">    [10, 11],</span>
<span class="sd">    [10, 11]]]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(48.).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool2d(3, 1, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[[16, 17]],</span>
<span class="sd">    [[22, 23]]],</span>
<span class="sd">    [[[40, 41]],</span>
<span class="sd">    [[46, 47]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">avg_pool2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool3d/avg_pool3d_array.html#ivy.array.array_methods.avg_pool3d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a 3-D max pool given 5-D input x.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.arange(48.).reshape((2, 3, 2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; print(x.avg_pool3d(2, 2, &#39;VALID&#39;))</span>
<span class="sd">    ivy.array([[[[[ 7.,  8.]]]],</span>
<span class="sd">           [[[[31., 32.]]]]])</span>

<span class="sd">    &gt;&gt;&gt; print(x.avg_pool3d(2, 2, &#39;SAME&#39;))</span>
<span class="sd">    ivy.array([[[[[ 7.,  8.]]],</span>
<span class="sd">            [[[19., 20.]]]],</span>
<span class="sd">           [[[[31., 32.]]],</span>
<span class="sd">            [[[43., 44.]]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">avg_pool3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dct"><a class="viewcode-back" href="../../../functional/ivy/experimental/dct/dct_array.html#ivy.array.array_methods.dct">[docs]</a><span class="k">def</span> <span class="nf">dct</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ortho&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.dct. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dct also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input signal.</span>
<span class="sd">    type</span>
<span class="sd">        The type of the dct. Must be 1, 2, 3 or 4.</span>
<span class="sd">    n</span>
<span class="sd">        The lenght of the transform. If n is less than the input signal lenght,</span>
<span class="sd">        then x is truncated, if n is larger than x is zero-padded.</span>
<span class="sd">    norm</span>
<span class="sd">        The type of normalization to be applied. Must be either None or &quot;ortho&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the transformed input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([8., 16., 24., 32., 40., 48., 56., 64.])</span>
<span class="sd">    &gt;&gt;&gt; x.dct(type=2, norm=&quot;ortho&quot;)</span>
<span class="sd">    ivy.array([ 102.,  -51.5,   0.,  -5.39,   0.,  -1.61,   0., -0.406])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fft"><a class="viewcode-back" href="../../../functional/ivy/experimental/fft/fft_array.html#ivy.array.array_methods.fft">[docs]</a><span class="k">def</span> <span class="nf">fft</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;backward&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.ifft. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ifft also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[...,d_in,...]*,</span>
<span class="sd">        where d_in indicates the dimension that needs FFT.</span>
<span class="sd">    dim</span>
<span class="sd">        The dimension along which to take the one dimensional FFT.</span>
<span class="sd">    norm</span>
<span class="sd">        Optional argument, &quot;backward&quot;, &quot;ortho&quot; or &quot;forward&quot;. Defaults to be</span>
<span class="sd">        &quot;backward&quot;.</span>
<span class="sd">        &quot;backward&quot; indicates no normalization.</span>
<span class="sd">        &quot;ortho&quot; indicates normalization by 1/sqrt(n).</span>
<span class="sd">        &quot;forward&quot; indicates normalization by 1/n.</span>
<span class="sd">    n</span>
<span class="sd">        Optional argument indicating the sequence length, if given, the input</span>
<span class="sd">        would be padded with zero or truncated to length n before performing FFT.</span>
<span class="sd">        Should be a integer greater than 1.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the transformed input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array((np.exp(2j * np.pi * np.arange(8) / 8)))</span>
<span class="sd">    &gt;&gt;&gt; a.fft(0)</span>
<span class="sd">    ivy.array([-3.44509285e-16+1.14423775e-17j,  8.00000000e+00-8.11483250e-16j,</span>
<span class="sd">                2.33486982e-16+1.22464680e-16j,  0.00000000e+00+1.22464680e-16j,</span>
<span class="sd">                9.95799250e-17+2.33486982e-16j,  0.00000000e+00+7.66951701e-17j,</span>
<span class="sd">                1.14423775e-17+1.22464680e-16j,  0.00000000e+00+1.22464680e-16j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ifft"><a class="viewcode-back" href="../../../functional/ivy/experimental/ifft/ifft_array.html#ivy.array.array_methods.ifft">[docs]</a><span class="k">def</span> <span class="nf">ifft</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;backward&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.ifft. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ifft also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[...,d_in,...]*,</span>
<span class="sd">        where d_in indicates the dimension that needs IFFT.</span>
<span class="sd">    dim</span>
<span class="sd">        The dimension along which to take the one dimensional IFFT.</span>
<span class="sd">    norm</span>
<span class="sd">        Optional argument, &quot;backward&quot;, &quot;ortho&quot; or &quot;forward&quot;. Defaults to be</span>
<span class="sd">        &quot;backward&quot;.</span>
<span class="sd">        &quot;backward&quot; indicates no normalization.</span>
<span class="sd">        &quot;ortho&quot; indicates normalization by 1/sqrt(n).</span>
<span class="sd">        &quot;forward&quot; indicates normalization by 1/n.</span>
<span class="sd">    n</span>
<span class="sd">        Optional argument indicating the sequence length, if given, the input</span>
<span class="sd">        would be padded with zero or truncated to length n before performing IFFT.</span>
<span class="sd">        Should be a integer greater than 1.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the transformed input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array((np.exp(2j * np.pi * np.arange(8) / 8)))</span>
<span class="sd">    &gt;&gt;&gt; a.ifft(0)</span>
<span class="sd">    ivy.array([-4.30636606e-17+1.43029718e-18j,  0.00000000e+00+1.53080850e-17j,</span>
<span class="sd">                1.43029718e-18+1.53080850e-17j,  0.00000000e+00+9.58689626e-18j,</span>
<span class="sd">                1.24474906e-17+2.91858728e-17j,  0.00000000e+00+1.53080850e-17j,</span>
<span class="sd">                2.91858728e-17+1.53080850e-17j,  1.00000000e+00-1.01435406e-16j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="embedding"><a class="viewcode-back" href="../../../functional/ivy/experimental/embedding/embedding_array.html#ivy.array.array_methods.embedding">[docs]</a><span class="k">def</span> <span class="nf">embedding</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">max_norm</span><span class="o">=</span><span class="n">max_norm</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="dft"><a class="viewcode-back" href="../../../functional/ivy/experimental/dft/dft_array.html#ivy.array.array_methods.dft">[docs]</a><span class="k">def</span> <span class="nf">dft</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">inverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">onesided</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dft_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;backward&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the discrete Fourier transform of input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[...,d_in,...]*,</span>
<span class="sd">        where d_in indicates the dimension that needs FFT.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis on which to perform the DFT. By default this</span>
<span class="sd">        value is  set to 1, which corresponds to the first dimension</span>
<span class="sd">        after the batch index.</span>
<span class="sd">    inverse</span>
<span class="sd">        Whether to perform the inverse discrete fourier transform.</span>
<span class="sd">        By default this value is set to False.</span>
<span class="sd">    onesided</span>
<span class="sd">        If onesided is True, only values for w in [0, 1, 2, , floor(n_fft/2) + 1]</span>
<span class="sd">        are returned because the real-to-complex Fourier transform satisfies the</span>
<span class="sd">        conjugate symmetry, i.e., X[m, w] = X[m,w]=X[m,n_fft-w]*. Note if the</span>
<span class="sd">        input or window tensors are complex, then onesided output is not possible.</span>
<span class="sd">        Enabling onesided with real inputs performs a Real-valued fast Fourier</span>
<span class="sd">        transform (RFFT). When invoked with real or complex valued input, the</span>
<span class="sd">        default value is False. Values can be True or False.</span>
<span class="sd">    dft_length</span>
<span class="sd">        The length of the signal.If greater than the axis dimension,</span>
<span class="sd">        the signal will be zero-padded up to dft_length. If less than</span>
<span class="sd">        the axis dimension, only the first dft_length values will be</span>
<span class="sd">        used as the signal. Its an optional value.</span>
<span class="sd">    norm</span>
<span class="sd">        Optional argument, &quot;backward&quot;, &quot;ortho&quot; or &quot;forward&quot;. Defaults to be</span>
<span class="sd">        &quot;backward&quot;.</span>
<span class="sd">        &quot;backward&quot; indicates no normalization.</span>
<span class="sd">        &quot;ortho&quot; indicates normalization by 1/sqrt(n).</span>
<span class="sd">        &quot;forward&quot; indicates normalization by 1/n.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The Fourier Transform of the input vector.If onesided is False,</span>
<span class="sd">        the following shape is expected: [batch_idx][signal_dim1][signal_dim2]</span>
<span class="sd">        [signal_dimN][2]. If axis=0 and onesided is True, the following shape</span>
<span class="sd">        is expected: [batch_idx][floor(signal_dim1/2)+1][signal_dim2]</span>
<span class="sd">        [signal_dimN][2]. If axis=1 and onesided is True, the following</span>
<span class="sd">        shape is expected: [batch_idx][signal_dim1] [floor(signal_dim2/2)+1]</span>
<span class="sd">        [signal_dimN][2]. If axis=N-1 and onesided is True, the following</span>
<span class="sd">        shape is expected: [batch_idx][signal_dim1][signal_dim2]</span>
<span class="sd">        [floor(signal_dimN/2)+1][2]. The signal_dim at the specified axis</span>
<span class="sd">        is equal to the dft_length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dft</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">inverse</span><span class="o">=</span><span class="n">inverse</span><span class="p">,</span>
        <span class="n">onesided</span><span class="o">=</span><span class="n">onesided</span><span class="p">,</span>
        <span class="n">dft_length</span><span class="o">=</span><span class="n">dft_length</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="interpolate"><a class="viewcode-back" href="../../../functional/ivy/experimental/interpolate/interpolate_array.html#ivy.array.array_methods.interpolate">[docs]</a><span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
            <span class="s2">&quot;trilinear&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
            <span class="s2">&quot;area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nearest_exact&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tf_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">scale_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recompute_scale_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">antialias</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Down/up samples the input to the given size.</span>
<span class="sd">    The algorithm used for interpolation is determined by mode.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array, Must have the shape</span>
<span class="sd">        [batch x channels x [optional depth] x [optional height] x width].</span>
<span class="sd">    size</span>
<span class="sd">        Output size.</span>
<span class="sd">    mode</span>
<span class="sd">        Interpolation mode. Can be one of the following:</span>
<span class="sd">        - linear</span>
<span class="sd">        - bilinear</span>
<span class="sd">        - trilinear</span>
<span class="sd">        - nearest</span>
<span class="sd">        - area</span>
<span class="sd">        - tf_area</span>
<span class="sd">        - bicubic</span>
<span class="sd">        - mitchellcubic</span>
<span class="sd">        - lanczos3</span>
<span class="sd">        - lanczos5</span>
<span class="sd">        - gaussian</span>
<span class="sd">    scale_factor</span>
<span class="sd">        Multiplier for spatial size that defines the output size</span>
<span class="sd">        (overwriting `size`).</span>
<span class="sd">    align_corners</span>
<span class="sd">        If True, the corner pixels of the input and output tensors are aligned,</span>
<span class="sd">        and thus preserving the values at the corner pixels. If False, the corner</span>
<span class="sd">        pixels are not aligned, and the interpolation uses edge value padding for</span>
<span class="sd">        out-of-boundary values.</span>
<span class="sd">        only has an effect when mode is &#39;linear&#39;, &#39;bilinear&#39;,</span>
<span class="sd">        &#39;bicubic&#39; or &#39;trilinear&#39;. Default: False</span>
<span class="sd">    antialias</span>
<span class="sd">        If True, antialiasing is applied when downsampling an image.</span>
<span class="sd">        Supported modes: &#39;bilinear&#39;, &#39;bicubic&#39;.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        resized array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">scale_factor</span><span class="o">=</span><span class="n">scale_factor</span><span class="p">,</span>
        <span class="n">recompute_scale_factor</span><span class="o">=</span><span class="n">recompute_scale_factor</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
        <span class="n">antialias</span><span class="o">=</span><span class="n">antialias</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="adaptive_avg_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/adaptive_avg_pool1d/adaptive_avg_pool1d_array.html#ivy.array.array_methods.adaptive_avg_pool1d">[docs]</a><span class="k">def</span> <span class="nf">adaptive_avg_pool1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">output_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a 1D adaptive average pooling over an input signal composed of several</span>
<span class="sd">    input planes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Must have shape (N, C, L_in) or (C, L_in) where N is</span>
<span class="sd">        the batch dimension, C is the feature dimension, and L_in is the spatial</span>
<span class="sd">        dimension.</span>
<span class="sd">    output_size</span>
<span class="sd">        Spatial output size.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The result of the pooling operation. Will have shape (N, C, L_out) or</span>
<span class="sd">        (C, L_out), where L_out = `output_size`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adaptive_avg_pool1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">output_size</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="adaptive_avg_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/adaptive_avg_pool2d/adaptive_avg_pool2d_array.html#ivy.array.array_methods.adaptive_avg_pool2d">[docs]</a><span class="k">def</span> <span class="nf">adaptive_avg_pool2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">output_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a 2D adaptive average pooling over an input signal composed of several</span>
<span class="sd">    input planes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Must have shape (N, C, H_in, W_in) or (C, H_in, W_in) where N</span>
<span class="sd">        is the batch dimension, C is the feature dimension, and H_in and W_in are</span>
<span class="sd">        the 2 spatial dimensions.</span>
<span class="sd">    output_size</span>
<span class="sd">        Spatial output size.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The result of the pooling operation. Will have shape (N, C, S_0, S_1) or</span>
<span class="sd">        (C, S_0, S_1), where S = `output_size`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adaptive_avg_pool2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">output_size</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="eigh_tridiagonal"><a class="viewcode-back" href="../../../functional/ivy/experimental/eigh_tridiagonal/eigh_tridiagonal_array.html#ivy.array.array_methods.eigh_tridiagonal">[docs]</a><span class="k">def</span> <span class="nf">eigh_tridiagonal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">eigvals_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">select</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">select_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eigh_tridiagonal. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.eigh_tridiagonal also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An array of real or complex arrays each of shape (n),</span>
<span class="sd">        the diagonal elements of the matrix.</span>
<span class="sd">    beta</span>
<span class="sd">        An array or of real or complex arrays each of shape (n-1),</span>
<span class="sd">        containing the elements of the first super-diagonal of the matrix.</span>
<span class="sd">    eigvals_only</span>
<span class="sd">        If False, both eigenvalues and corresponding eigenvectors are computed.</span>
<span class="sd">        If True, only eigenvalues are computed. Default is True.</span>
<span class="sd">    select</span>
<span class="sd">        Optional string with values in {&#39;a&#39;, &#39;v&#39;, &#39;i&#39;}</span>
<span class="sd">        (default is &#39;a&#39;) that determines which eigenvalues</span>
<span class="sd">        to calculate: &#39;a&#39;: all eigenvalues. &#39;v&#39;: eigenvalues</span>
<span class="sd">        in the interval (min, max] given by select_range.</span>
<span class="sd">        &#39;i&#39;: eigenvalues with indices min &lt;= i &lt;= max.</span>
<span class="sd">    select_range</span>
<span class="sd">        Size 2 tuple or list or array specifying the range of</span>
<span class="sd">        eigenvalues to compute together with select. If select</span>
<span class="sd">        is &#39;a&#39;, select_range is ignored.</span>
<span class="sd">    tol</span>
<span class="sd">        Optional scalar. Ignored when backend is not Tensorflow. The</span>
<span class="sd">        absolute tolerance to which each eigenvalue is required. An</span>
<span class="sd">        eigenvalue (or cluster) is considered to have converged if</span>
<span class="sd">        it lies in an interval of this width. If tol is None (default),</span>
<span class="sd">        the value eps*|T|_2 is used where eps is the machine precision,</span>
<span class="sd">        and |T|_2 is the 2-norm of the matrix T.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eig_vals</span>
<span class="sd">        The eigenvalues of the matrix in non-decreasing order.</span>
<span class="sd">    eig_vectors</span>
<span class="sd">        If eigvals_only is False the eigenvectors are returned in the second</span>
<span class="sd">        output argument.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; alpha = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; beta = ivy.array([0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = alpha.eigh_tridiagonal(beta)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.38196, 2.61803])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigh_tridiagonal</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">eigvals_only</span><span class="o">=</span><span class="n">eigvals_only</span><span class="p">,</span>
        <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span>
        <span class="n">select_range</span><span class="o">=</span><span class="n">select_range</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diagflat"><a class="viewcode-back" href="../../../functional/ivy/experimental/diagflat/diagflat_array.html#ivy.array.array_methods.diagflat">[docs]</a><span class="k">def</span> <span class="nf">diagflat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">padding_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">align</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RIGHT_LEFT&quot;</span><span class="p">,</span>
    <span class="n">num_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">num_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.diagflat.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.diagflat also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1,2])</span>
<span class="sd">    &gt;&gt;&gt; x.diagflat(k=1)</span>
<span class="sd">    ivy.array([[0, 1, 0],</span>
<span class="sd">               [0, 0, 2],</span>
<span class="sd">               [0, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">padding_value</span><span class="o">=</span><span class="n">padding_value</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span>
        <span class="n">num_cols</span><span class="o">=</span><span class="n">num_cols</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="kron"><a class="viewcode-back" href="../../../functional/ivy/experimental/kron/kron_array.html#ivy.array.array_methods.kron">[docs]</a><span class="k">def</span> <span class="nf">kron</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.kron.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.kron also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([1,2])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([3,4])</span>
<span class="sd">    &gt;&gt;&gt; a.diagflat(b)</span>
<span class="sd">    ivy.array([3, 4, 6, 8])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="matrix_exp"><a class="viewcode-back" href="../../../functional/ivy/experimental/matrix_exp/matrix_exp_array.html#ivy.array.array_methods.matrix_exp">[docs]</a><span class="k">def</span> <span class="nf">matrix_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.kron.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_exp also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1., 0.],</span>
<span class="sd">                        [0., 1.]],</span>
<span class="sd">                        [[2., 0.],</span>
<span class="sd">                        [0., 2.]]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_exp(x)</span>
<span class="sd">    ivy.array([[[2.7183, 1.0000],</span>
<span class="sd">                [1.0000, 2.7183]],</span>
<span class="sd">                [[7.3891, 1.0000],</span>
<span class="sd">                [1.0000, 7.3891]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">eig</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eig.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eig also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; x.eig()</span>
<span class="sd">    (</span>
<span class="sd">    ivy.array([-0.37228132+0.j,  5.37228132+0.j]),</span>
<span class="sd">    ivy.array([[-0.82456484+0.j, -0.41597356+0.j],</span>
<span class="sd">               [ 0.56576746+0.j, -0.90937671+0.j]])</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<div class="viewcode-block" id="eigvals"><a class="viewcode-back" href="../../../functional/ivy/experimental/eigvals/eigvals_array.html#ivy.array.array_methods.eigvals">[docs]</a><span class="k">def</span> <span class="nf">eigvals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eigvals.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eigvals also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; x.eigvals()</span>
<span class="sd">    ivy.array([-0.37228132+0.j,  5.37228132+0.j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="adjoint"><a class="viewcode-back" href="../../../functional/ivy/experimental/adjoint/adjoint_array.html#ivy.array.array_methods.adjoint">[docs]</a><span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.adjoint.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.adjoint also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1.-1.j, 2.+2.j],</span>
<span class="sd">                      [3.+3.j, 4.-4.j]])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array(x)</span>
<span class="sd">    &gt;&gt;&gt; x.adjoint()</span>
<span class="sd">    ivy.array([[1.+1.j, 3.-3.j],</span>
<span class="sd">               [2.-2.j, 4.+4.j]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multi_dot"><a class="viewcode-back" href="../../../functional/ivy/experimental/multi_dot/multi_dot_array.html#ivy.array.array_methods.multi_dot">[docs]</a><span class="k">def</span> <span class="nf">multi_dot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.multi_dot.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.multi_dot also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = ivy.arange(2 * 3).reshape((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; B = ivy.arange(3 * 2).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; C = ivy.arange(2 * 2).reshape((2, 2))</span>
<span class="sd">    &gt;&gt;&gt; A.multi_dot((B, C))</span>
<span class="sd">    ivy.array([[ 26,  49],</span>
<span class="sd">               [ 80, 148]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multi_dot</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="l2_normalize"><a class="viewcode-back" href="../../../functional/ivy/experimental/l2_normalize/l2_normalize_array.html#ivy.array.array_methods.l2_normalize">[docs]</a><span class="k">def</span> <span class="nf">l2_normalize</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalizes the array to have unit L2 norm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which to normalize. If ``None``, the whole array</span>
<span class="sd">        is normalized.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The normalized array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; x.l2_normalize(axis=1)</span>
<span class="sd">    ivy.array([[0.4472, 0.8944],</span>
<span class="sd">               [0.6, 0.8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">l2_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="instance_norm"><a class="viewcode-back" href="../../../functional/ivy/experimental/instance_norm/instance_norm_array.html#ivy.array.array_methods.instance_norm">[docs]</a><span class="k">def</span> <span class="nf">instance_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">momentum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NCHW&quot;</span><span class="p">,</span>
    <span class="n">running_mean</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">running_stddev</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">affine</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">track_running_stats</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Applies Instance Normalization over a 4D input along C dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    scale</span>
<span class="sd">        Scale parameter for the normalization.</span>
<span class="sd">    bias</span>
<span class="sd">        Bias parameter for the normalization.</span>
<span class="sd">    eps</span>
<span class="sd">        Small constant to avoid division by zero.</span>
<span class="sd">    momentum</span>
<span class="sd">        Momentum parameter for running statistics</span>
<span class="sd">    data_format</span>
<span class="sd">        Format of the input data, either &#39;NCHW&#39; or &#39;NHWC&#39;.</span>
<span class="sd">    running_mean</span>
<span class="sd">        The running mean of the input array.</span>
<span class="sd">    running_stddev</span>
<span class="sd">        The running standard deviation of the input array.</span>
<span class="sd">    affine</span>
<span class="sd">        Whether to use affine transformation for the output.</span>
<span class="sd">    track_running_stats</span>
<span class="sd">        Whether to track the running statistics of the input array.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The normalized array.</span>
<span class="sd">        OR</span>
<span class="sd">        The normalized array, Running mean, Running stddev</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`track_running_stats=False`:</span>
<span class="sd">    ret : The normalized array.</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.eye(3, 3).reshape((1, 3, 3, 1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.instance_norm(x, scale=[2., 1, 0.5], bias=[2., 1, 0.5],</span>
<span class="sd">    ...                   data_format=&#39;NCHW&#39;, affine=True,</span>
<span class="sd">    ...                   track_running_stats=False)</span>
<span class="sd">    ivy.array([[[[4.82836342],[0.58581817],[0.58581817]],</span>
<span class="sd">            [[0.29290909],[2.41418171],[0.29290909]],</span>
<span class="sd">            [[0.14645454],[0.14645454],[1.20709085]]]])</span>
<span class="sd">    With :class:`track_running_stats=True`:</span>
<span class="sd">    ret : The normalized array, Running mean, Running stddev.</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.eye(3, 3).reshape((1, 3, 3, 1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.instance_norm(x, scale=[2., 1, 0.5], bias=[2., 1, 0.5],</span>
<span class="sd">    ...                   data_format=&#39;NCHW&#39;,affine=True,</span>
<span class="sd">    ...                   track_running_stats=False)</span>
<span class="sd">    (ivy.array([[[[4.82836342],[0.58581817],[0.58581817]],</span>
<span class="sd">            [[0.29290909],[2.41418171],[0.29290909]],</span>
<span class="sd">            [[0.14645454],[0.14645454],[1.20709085]]]]),</span>
<span class="sd">     ivy.array([[[[0.30000001]],[[0.30000001]],[[0.30000001]]]]),</span>
<span class="sd">     ivy.array([[[[0.52426404]],[[0.52426404]],[[0.52426404]]]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">instance_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
        <span class="n">momentum</span><span class="o">=</span><span class="n">momentum</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">running_mean</span><span class="o">=</span><span class="n">running_mean</span><span class="p">,</span>
        <span class="n">running_stddev</span><span class="o">=</span><span class="n">running_stddev</span><span class="p">,</span>
        <span class="n">affine</span><span class="o">=</span><span class="n">affine</span><span class="p">,</span>
        <span class="n">track_running_stats</span><span class="o">=</span><span class="n">track_running_stats</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lp_normalize"><a class="viewcode-back" href="../../../functional/ivy/experimental/lp_normalize/lp_normalize_array.html#ivy.array.array_methods.lp_normalize">[docs]</a><span class="k">def</span> <span class="nf">lp_normalize</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalizes the array to have Lp norm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    p</span>
<span class="sd">        p-norm to use for normalization.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which to normalize. If ``None``, the whole array</span>
<span class="sd">        is normalized.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The normalized array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; x.lp_normalize(p=2, axis=1)</span>
<span class="sd">    ivy.array([[0.4472, 0.8944],</span>
<span class="sd">           [0.6, 0.8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lp_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="eye_like"><a class="viewcode-back" href="../../../functional/ivy/experimental/eye_like/eye_like_array.html#ivy.array.array_methods.eye_like">[docs]</a><span class="k">def</span> <span class="nf">eye_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eye_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.eye_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    k</span>
<span class="sd">        index of the diagonal. A positive value refers to an upper diagonal,</span>
<span class="sd">        a negative value to a lower diagonal, and 0 to the main diagonal.</span>
<span class="sd">        Default: ``0``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the same shape as ``self`` and filled with ``ones``</span>
<span class="sd">        in diagonal ``k`` and ``zeros`` elsewhere.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 3, 8],[1, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.eye_like()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 0., 0.],</span>
<span class="sd">                0., 1., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eye_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="moveaxis"><a class="viewcode-back" href="../../../functional/ivy/experimental/moveaxis/moveaxis_array.html#ivy.array.array_methods.moveaxis">[docs]</a><span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.moveaxis. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unstack also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        The array whose axes should be reordered.</span>
<span class="sd">    source</span>
<span class="sd">        Original positions of the axes to move. These must be unique.</span>
<span class="sd">    destination</span>
<span class="sd">        Destination positions for each of the original axes.</span>
<span class="sd">        These must also be unique.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with moved axes. This array is a view of the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.zeros((3, 4, 5))</span>
<span class="sd">    &gt;&gt;&gt; x.moveaxis(0, -1).shape</span>
<span class="sd">    (4, 5, 3)</span>

<span class="sd">    &gt;&gt;&gt; x.moveaxis(-1, 0).shape</span>
<span class="sd">    (5, 3, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="heaviside"><a class="viewcode-back" href="../../../functional/ivy/experimental/heaviside/heaviside_array.html#ivy.array.array_methods.heaviside">[docs]</a><span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.heaviside. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.heaviside also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    x2</span>
<span class="sd">        values to use where x1 is zero.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        output array with element-wise Heaviside step function of x1.</span>
<span class="sd">        This is a scalar if both x1 and x2 are scalars.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([-1.5, 0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0.5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.heaviside(x1, x2)</span>
<span class="sd">    ivy.array([0.0000, 0.5000, 1.0000])</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([-1.5, 0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1.2, -2.0, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.heaviside(x1, x2)</span>
<span class="sd">    ivy.array([0., -2., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">heaviside</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="flipud"><a class="viewcode-back" href="../../../functional/ivy/experimental/flipud/flipud_array.html#ivy.array.array_methods.flipud">[docs]</a><span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.flipud. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flipud also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array to be flipped.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array corresponding to input array with elements</span>
<span class="sd">        order reversed along axis 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.diag([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; m.flipud()</span>
<span class="sd">    ivy.array([[ 0.,  0.,  3.],</span>
<span class="sd">        [ 0.,  2.,  0.],</span>
<span class="sd">        [ 1.,  0.,  0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="vstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/vstack/vstack_array.html#ivy.array.array_methods.vstack">[docs]</a><span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.vstack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.vstack also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = [ivy.array([[5, 6]]), ivy.array([[7, 8]])]</span>
<span class="sd">    &gt;&gt;&gt; print(x.vstack(y))</span>
<span class="sd">        ivy.array([[1, 2],</span>
<span class="sd">                   [5, 6],</span>
<span class="sd">                   [7, 8]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="hstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/hstack/hstack_array.html#ivy.array.array_methods.hstack">[docs]</a><span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.hstack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.hstack also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = [ivy.array([[5, 6]]), ivy.array([[7, 8]])]</span>
<span class="sd">    &gt;&gt;&gt; print(x.vstack(y))</span>
<span class="sd">    ivy.array([1, 2, 5, 6, 7, 8])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="rot90"><a class="viewcode-back" href="../../../functional/ivy/experimental/rot90/rot90_array.html#ivy.array.array_methods.rot90">[docs]</a><span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.rot90.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.rot90 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array of two or more dimensions.</span>
<span class="sd">    k</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>
<span class="sd">    axes</span>
<span class="sd">        The array is rotated in the plane defined by the axes. Axes must be</span>
<span class="sd">        different.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with a rotated view of input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; m.rot90()</span>
<span class="sd">    ivy.array([[2, 4],</span>
<span class="sd">           [1, 3]])</span>

<span class="sd">    &gt;&gt;&gt; m = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; m.rot90(k=2)</span>
<span class="sd">    ivy.array([[4, 3],</span>
<span class="sd">           [2, 1]])</span>

<span class="sd">    &gt;&gt;&gt; m = ivy.array([[[0, 1],\</span>
<span class="sd">                        [2, 3]],\</span>
<span class="sd">                       [[4, 5],\</span>
<span class="sd">                        [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; m.rot90(k=2, axes=(1,2))</span>
<span class="sd">    ivy.array([[[3, 2],</span>
<span class="sd">            [1, 0]],</span>
<span class="sd">           [[7, 6],</span>
<span class="sd">            [5, 4]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="top_k"><a class="viewcode-back" href="../../../functional/ivy/experimental/top_k/top_k_array.html#ivy.array.array_methods.top_k">[docs]</a><span class="k">def</span> <span class="nf">top_k</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">largest</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.top_k. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.top_k also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array to compute top_k for.</span>
<span class="sd">    k</span>
<span class="sd">        Number of top elements to retun must not exceed the array size.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which we must return the top elements default value is 1.</span>
<span class="sd">    largest</span>
<span class="sd">        If largest is set to False we return k smallest elements of the array.</span>
<span class="sd">    out:</span>
<span class="sd">        Optional output tuple, for writing the result to. Must have two arrays,</span>
<span class="sd">        with a shape that the returned tuple broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A named tuple with values and indices of top k elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 1., -3., 5., 9., 0., -4])</span>
<span class="sd">    &gt;&gt;&gt; y = x.top_k(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    top_k(values=ivy.array([9., 5.]), indices=ivy.array([4, 3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="n">largest</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="fliplr"><a class="viewcode-back" href="../../../functional/ivy/experimental/fliplr/fliplr_array.html#ivy.array.array_methods.fliplr">[docs]</a><span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.fliplr. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fliplr also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array to be flipped. Must be at least 2-D.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array corresponding to input array with elements</span>
<span class="sd">        order reversed along axis 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.diag([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; m.fliplr()</span>
<span class="sd">    ivy.array([[0, 0, 1],</span>
<span class="sd">           [0, 2, 0],</span>
<span class="sd">           [3, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="i0"><a class="viewcode-back" href="../../../functional/ivy/experimental/i0/i0_array.html#ivy.array.array_methods.i0">[docs]</a><span class="k">def</span> <span class="nf">i0</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.i0. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.i0 also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array with modified Bessel function of the first kind, order 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; x.i0()</span>
<span class="sd">    ivy.array([1.26606588, 2.2795853 , 4.88079259])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">i0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="flatten"><a class="viewcode-back" href="../../../functional/ivy/experimental/flatten/flatten_array.html#ivy.array.array_methods.flatten">[docs]</a><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">start_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.flatten. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flatten also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to flatten.</span>
<span class="sd">    start_dim</span>
<span class="sd">        first dim to flatten. If not set, defaults to 0.</span>
<span class="sd">    end_dim</span>
<span class="sd">        last dim to flatten. If not set, defaults to -1.</span>
<span class="sd">    order</span>
<span class="sd">        Read the elements of the input container using this index order,</span>
<span class="sd">        and place the elements into the reshaped array using this index order.</span>
<span class="sd">        C means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first axis index</span>
<span class="sd">        changing slowest.</span>
<span class="sd">        F means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the C and F options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        Default order is &#39;C&#39;.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the flattened array over the specified dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; x.flatten()</span>
<span class="sd">    ivy.array([1, 2, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1,2], [3,4]])</span>
<span class="sd">    &gt;&gt;&gt; x.flatten(order=&#39;F&#39;)</span>
<span class="sd">    ivy.array([1, 3, 2, 4])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array(</span>
<span class="sd">        [[[[ 5,  5,  0,  6],</span>
<span class="sd">        [17, 15, 11, 16],</span>
<span class="sd">        [ 6,  3, 13, 12]],</span>
<span class="sd">        [[ 6, 18, 10,  4],</span>
<span class="sd">        [ 5,  1, 17,  3],</span>
<span class="sd">        [14, 14, 18,  6]]],</span>
<span class="sd">    [[[12,  0,  1, 13],</span>
<span class="sd">        [ 8,  7,  0,  3],</span>
<span class="sd">        [19, 12,  6, 17]],</span>
<span class="sd">        [[ 4, 15,  6, 15],</span>
<span class="sd">        [ 0,  5, 17,  9],</span>
<span class="sd">        [ 9,  3,  6, 19]]],</span>
<span class="sd">    [[[17, 13, 11, 16],</span>
<span class="sd">        [ 4, 18, 17,  4],</span>
<span class="sd">        [10, 10,  9,  1]],</span>
<span class="sd">        [[19, 17, 13, 10],</span>
<span class="sd">        [ 4, 19, 16, 17],</span>
<span class="sd">        [ 2, 12,  8, 14]]]]</span>
<span class="sd">        )</span>

<span class="sd">    &gt;&gt;&gt; x.flatten(start_dim = 1, end_dim = 2)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">        [[[ 5,  5,  0,  6],</span>
<span class="sd">        [17, 15, 11, 16],</span>
<span class="sd">        [ 6,  3, 13, 12],</span>
<span class="sd">        [ 6, 18, 10,  4],</span>
<span class="sd">        [ 5,  1, 17,  3],</span>
<span class="sd">        [14, 14, 18,  6]],</span>
<span class="sd">        [[12,  0,  1, 13],</span>
<span class="sd">        [ 8,  7,  0,  3],</span>
<span class="sd">        [19, 12,  6, 17],</span>
<span class="sd">        [ 4, 15,  6, 15],</span>
<span class="sd">        [ 0,  5, 17,  9],</span>
<span class="sd">        [ 9,  3,  6, 19]],</span>
<span class="sd">        [[17, 13, 11, 16],</span>
<span class="sd">        [ 4, 18, 17,  4],</span>
<span class="sd">        [10, 10,  9,  1],</span>
<span class="sd">        [19, 17, 13, 10],</span>
<span class="sd">        [ 4, 19, 16, 17],</span>
<span class="sd">        [ 2, 12,  8, 14]]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="n">start_dim</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="n">end_dim</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../../../functional/ivy/experimental/pad/pad_array.html#ivy.array.array_methods.pad">[docs]</a><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
            <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
            <span class="s2">&quot;linear_ramp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;median&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
            <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span>
            <span class="s2">&quot;wrap&quot;</span><span class="p">,</span>
            <span class="s2">&quot;empty&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">Callable</span><span class="p">,</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">stat_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">constant_values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">reflect_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;even&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.pad also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">stat_length</span><span class="o">=</span><span class="n">stat_length</span><span class="p">,</span>
        <span class="n">constant_values</span><span class="o">=</span><span class="n">constant_values</span><span class="p">,</span>
        <span class="n">end_values</span><span class="o">=</span><span class="n">end_values</span><span class="p">,</span>
        <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/vsplit/vsplit_array.html#ivy.array.array_methods.vsplit">[docs]</a><span class="k">def</span> <span class="nf">vsplit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.vsplit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.vsplit also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n</span>
<span class="sd">        equal sections, provided that n must be a divisor of the split axis.</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array split vertically.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.array(</span>
<span class="sd">        [[[0.,  1.],</span>
<span class="sd">          [2.,  3.]],</span>
<span class="sd">         [[4.,  5.],</span>
<span class="sd">          [6.,  7.]]]</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ary.vsplit(2)</span>
<span class="sd">    [ivy.array([[[0., 1.], [2., 3.]]]), ivy.array([[[4., 5.], [6., 7.]]])])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">)</span></div>


<div class="viewcode-block" id="dsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/dsplit/dsplit_array.html#ivy.array.array_methods.dsplit">[docs]</a><span class="k">def</span> <span class="nf">dsplit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dsplit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dsplit also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n</span>
<span class="sd">        equal sections, provided that n must be a divisor of the split axis.</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array split along the 3rd axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.array(</span>
<span class="sd">        [[[ 0.,   1.,   2.,   3.],</span>
<span class="sd">          [ 4.,   5.,   6.,   7.]],</span>
<span class="sd">         [[ 8.,   9.,  10.,  11.],</span>
<span class="sd">          [12.,  13.,  14.,  15.]]]</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; ary.dsplit(2)</span>
<span class="sd">    [ivy.array([[[ 0.,  1.], [ 4.,  5.]], [[ 8.,  9.], [12., 13.]]]),</span>
<span class="sd">    ivy.array([[[ 2.,  3.], [ 6.,  7.]], [[10., 11.], [14., 15.]]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">)</span></div>


<div class="viewcode-block" id="atleast_1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/atleast_1d/atleast_1d_array.html#ivy.array.array_methods.atleast_1d">[docs]</a><span class="k">def</span> <span class="nf">atleast_1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Number</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atleast_1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.atleast_1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Cannot be a scalar input.</span>
<span class="sd">    arys</span>
<span class="sd">        An arbitrary number of input arrays.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, each with a.ndim &gt;= 1. Copies are made</span>
<span class="sd">        only if necessary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a1 = ivy.array([[1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; a2 = ivy.array(4)</span>
<span class="sd">    &gt;&gt;&gt; a1.atleast_1d(a2,5,6)</span>
<span class="sd">    [ivy.array([[1, 2, 3]]), ivy.array([4]), ivy.array([5]), ivy.array([6])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">)</span></div>


<div class="viewcode-block" id="dstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/dstack/dstack_array.html#ivy.array.array_methods.dstack">[docs]</a><span class="k">def</span> <span class="nf">dstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dstack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dstack also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x.dstack(y)</span>
<span class="sd">    ivy.array([[[1, 2],</span>
<span class="sd">                [2, 3],</span>
<span class="sd">                [3, 4]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="atleast_2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/atleast_2d/atleast_2d_array.html#ivy.array.array_methods.atleast_2d">[docs]</a><span class="k">def</span> <span class="nf">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atleast_2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.atleast_2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Cannot be a scalar input.</span>
<span class="sd">    arys</span>
<span class="sd">        An arbitrary number of input arrays.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, each with a.ndim &gt;= 2. Copies are made</span>
<span class="sd">        only if necessary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a1 = ivy.array([[1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; a2 = ivy.array(4)</span>
<span class="sd">    &gt;&gt;&gt; a1.atleast_2d(a2,5,6)</span>
<span class="sd">    [ivy.array([[1, 2, 3]]), ivy.array([[4]]), ivy.array([[5]]), ivy.array([[6]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">)</span></div>


<div class="viewcode-block" id="atleast_3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/atleast_3d/atleast_3d_array.html#ivy.array.array_methods.atleast_3d">[docs]</a><span class="k">def</span> <span class="nf">atleast_3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Number</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.atleast_3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.atleast_3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Cannot be a scalar input.</span>
<span class="sd">    arys</span>
<span class="sd">        An arbitrary number of input arrays.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, each with a.ndim &gt;= 3. Copies are made only if necessary</span>
<span class="sd">        and views with three or more dimensions are returned. For example, a 1-D</span>
<span class="sd">        array of shape (N,) becomes a view of shape (1, N, 1), and a 2-D array</span>
<span class="sd">        of shape (M, N) becomes a view of shape (M, N, 1).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a1 = ivy.array([[1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; a2 = ivy.array([4,8])</span>
<span class="sd">    &gt;&gt;&gt; a1.atleast_3d(a2,5,6)</span>
<span class="sd">    [ivy.array([[[1],</span>
<span class="sd">            [2],</span>
<span class="sd">            [3]]]), ivy.array([[[4],</span>
<span class="sd">            [8]]]), ivy.array([[[5]]]), ivy.array([[[6]]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="o">*</span><span class="n">arys</span><span class="p">)</span></div>


<div class="viewcode-block" id="take_along_axis"><a class="viewcode-back" href="../../../functional/ivy/experimental/take_along_axis/take_along_axis_array.html#ivy.array.array_methods.take_along_axis">[docs]</a><span class="k">def</span> <span class="nf">take_along_axis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;fill&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.take_along_axis. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.take_along_axis also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The source array.</span>
<span class="sd">    indices</span>
<span class="sd">        The indices of the values to extract.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis over which to select values.</span>
<span class="sd">    mode</span>
<span class="sd">        One of: &#39;clip&#39;, &#39;fill&#39;, &#39;drop&#39;. Parameter controlling how out-of-bounds</span>
<span class="sd">        indices will be handled.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The returned array has the same shape as indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = ivy.array([[4, 3, 5], [1, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([[0, 1, 1], [2, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; y = arr.take_along_axis(indices, 1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[4, 3, 3], [1, 1, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="hsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/hsplit/hsplit_array.html#ivy.array.array_methods.hsplit">[docs]</a><span class="k">def</span> <span class="nf">hsplit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.hsplit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.hsplit also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n</span>
<span class="sd">        equal sections, provided that n must be a divisor of the split axis.</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        list of arrays split horizontally from input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.array(</span>
<span class="sd">        [[0.,  1., 2., 3.],</span>
<span class="sd">         [4.,  5., 6,  7.],</span>
<span class="sd">         [8.,  9., 10., 11.],</span>
<span class="sd">         [12., 13., 14., 15.]]</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ary.hsplit(2)</span>
<span class="sd">    [ivy.array([[ 0.,  1.],</span>
<span class="sd">                [ 4.,  5.],</span>
<span class="sd">                [ 8.,  9.],</span>
<span class="sd">                [12., 13.]]),</span>
<span class="sd">     ivy.array([[ 2.,  3.],</span>
<span class="sd">                [ 6.,  7.],</span>
<span class="sd">                [10., 11.],</span>
<span class="sd">                [14., 15.]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">)</span></div>


<div class="viewcode-block" id="expand"><a class="viewcode-back" href="../../../functional/ivy/experimental/expand/expand_array.html#ivy.array.array_methods.expand">[docs]</a><span class="k">def</span> <span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast the input Array following the given shape</span>
<span class="sd">    and the broadcast rule.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array input.</span>
<span class="sd">    shape</span>
<span class="sd">        A 1-D Array indicates the shape you want to expand to,</span>
<span class="sd">        following the broadcast rule</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Output Array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="msort"><a class="viewcode-back" href="../../../functional/ivy/experimental/msort/msort_array.html#ivy.array.array_methods.msort">[docs]</a><span class="k">def</span> <span class="nf">msort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.msort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.msort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        sorted array of the same type and shape as a</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.asarray([[8, 9, 6],[6, 2, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a.msort()</span>
<span class="sd">    ivy.array(</span>
<span class="sd">        [[6, 2, 6],</span>
<span class="sd">        [8, 9, 6]]</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">msort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="lexsort"><a class="viewcode-back" href="../../../functional/ivy/experimental/lexsort/lexsort_array.html#ivy.array.array_methods.lexsort">[docs]</a><span class="k">def</span> <span class="nf">lexsort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.lexsort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.lexsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis of each key to be indirectly sorted.</span>
<span class="sd">        By default, sort over the last axis of each key.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        array of integer indices with shape N, that sort the input array as keys.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column</span>
<span class="sd">    &gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column</span>
<span class="sd">    &gt;&gt;&gt; keys = ivy.asarray([b,a])</span>
<span class="sd">    &gt;&gt;&gt; keys.lexsort() # Sort by a, then by b</span>
<span class="sd">    array([2, 0, 4, 6, 5, 3, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../functional/ivy/experimental/median/median_array.html#ivy.array.array_methods.median">[docs]</a><span class="k">def</span> <span class="nf">median</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.median. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.median also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the medians are computed. The default is to compute</span>
<span class="sd">        the median along a flattened version of the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The median of the array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a.median()</span>
<span class="sd">    3.5</span>

<span class="sd">    &gt;&gt;&gt; a.median(axis=0)</span>
<span class="sd">    ivy.array([6.5, 4.5, 2.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanmean"><a class="viewcode-back" href="../../../functional/ivy/experimental/nanmean/nanmean_array.html#ivy.array.array_methods.nanmean">[docs]</a><span class="k">def</span> <span class="nf">nanmean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.nanmean. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nanmean also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the means are computed.</span>
<span class="sd">        The default is to compute the mean of the flattened array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the original a. If the value is anything but the default,</span>
<span class="sd">        then keepdims will be passed through to the mean or sum methods of</span>
<span class="sd">        sub-classes of ndarray. If the sub-classes methods does not implement</span>
<span class="sd">        keepdims any exceptions will be raised.</span>
<span class="sd">    dtype</span>
<span class="sd">        The desired data type of returned tensor. Default is None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The nanmean of the array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[1, ivy.nan], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; a.nanmean()</span>
<span class="sd">    2.6666666666666665</span>

<span class="sd">    &gt;&gt;&gt; a.nanmean(axis=0)</span>
<span class="sd">    ivy.array([2.,  4.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unravel_index"><a class="viewcode-back" href="../../../functional/ivy/experimental/unravel_index/unravel_index_array.html#ivy.array.array_methods.unravel_index">[docs]</a><span class="k">def</span> <span class="nf">unravel_index</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.unravel_index. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unravel_index also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the array to use for unraveling indices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Tuple with arrays that have the same shape as the indices array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([22, 41, 37])</span>
<span class="sd">    &gt;&gt;&gt; indices.unravel_index((7,6))</span>
<span class="sd">    (ivy.array([3, 6, 6]), ivy.array([4, 5, 1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="quantile"><a class="viewcode-back" href="../../../functional/ivy/experimental/quantile/quantile_array.html#ivy.array.array_methods.quantile">[docs]</a><span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.quantile.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.quantile also applies to this method with minimal</span>
<span class="sd">    changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    q</span>
<span class="sd">        Quantile or sequence of quantiles to compute, which must be</span>
<span class="sd">        between 0 and 1 inclusive.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the quantiles are computed. The default</span>
<span class="sd">        is to compute the quantile(s) along a flattened version of the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the original array a.</span>
<span class="sd">    interpolation</span>
<span class="sd">        {&#39;nearest&#39;, &#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;}. Default value:</span>
<span class="sd">        &#39;linear&#39;.</span>
<span class="sd">        This specifies the interpolation method to use when the desired quantile</span>
<span class="sd">        lies between two data points i &lt; j:</span>
<span class="sd">        - linear: i + (j - i) * fraction, where fraction is the fractional part of</span>
<span class="sd">        the index surrounded by i and j.</span>
<span class="sd">        - lower: i.</span>
<span class="sd">        - higher: j.</span>
<span class="sd">        - nearest: i or j, whichever is nearest.</span>
<span class="sd">        - midpoint: (i + j) / 2. linear and midpoint interpolation do not work with</span>
<span class="sd">        integer dtypes.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A (rank(q) + N - len(axis)) dimensional array of same dtype as a, or,</span>
<span class="sd">        if axis is None, a rank(q) array. The first rank(q) dimensions index</span>
<span class="sd">        quantiles for different values of q.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[10., 7., 4.], [3., 2., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; q = ivy.array(0.5)</span>
<span class="sd">    &gt;&gt;&gt; a.quantile(q)</span>
<span class="sd">    ivy.array(3.5)</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([[10., 7., 4.], [3., 2., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; q = 0.5</span>
<span class="sd">    &gt;&gt;&gt; a.quantile(q)</span>
<span class="sd">    ivy.array(3.5)</span>

<span class="sd">    &gt;&gt;&gt; a.quantile(q, axis=0)</span>
<span class="sd">    ivy.array([6.5, 4.5, 2.5])</span>

<span class="sd">    &gt;&gt;&gt; a.quantile(q, axis=1)</span>
<span class="sd">    ivy.array([7.,  2.])</span>

<span class="sd">    &gt;&gt;&gt; a.quantile(q, axis=1, keepdims=True)</span>
<span class="sd">    ivy.array([[7.],[2.]])</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([1., 2., 3., 4.])</span>
<span class="sd">    &gt;&gt;&gt; q = ivy.array([0.3, 0.7])</span>
<span class="sd">    &gt;&gt;&gt; a.quantile(q, interpolation=&#39;lower&#39;)</span>
<span class="sd">    ivy.array([1., 3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="corrcoef"><a class="viewcode-back" href="../../../functional/ivy/experimental/corrcoef/corrcoef_array.html#ivy.array.array_methods.corrcoef">[docs]</a><span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rowvar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.corrcoef. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.corrcoef also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    y</span>
<span class="sd">        An additional input array.</span>
<span class="sd">        `y` has the same shape as `x`.</span>
<span class="sd">    rowvar</span>
<span class="sd">        If rowvar is True (default), then each row represents a variable, with</span>
<span class="sd">        observations in the columns. Otherwise, the relationship is transposed:</span>
<span class="sd">        each column represents a variable, while the rows contain observations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The corrcoef of the array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([[0., 1., 2.], [2., 1., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; a.corrcoef()</span>
<span class="sd">        ivy.array([[ 1., -1.],</span>
<span class="sd">                   [-1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; a.corrcoef(rowvar=False)</span>
<span class="sd">        ivy.array([[ 1., nan, -1.],</span>
<span class="sd">                   [nan, nan, nan],</span>
<span class="sd">                   [-1., nan,  1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="n">rowvar</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanmedian"><a class="viewcode-back" href="../../../functional/ivy/experimental/nanmedian/nanmedian_array.html#ivy.array.array_methods.nanmedian">[docs]</a><span class="k">def</span> <span class="nf">nanmedian</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">overwrite_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.nanmedian. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nanmedian also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis or axes along which the means are computed.</span>
<span class="sd">        The default is to compute the mean of the flattened array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the original input array. If the value is anything</span>
<span class="sd">        but the default, then keepdims will be passed through to the mean or</span>
<span class="sd">        sum methods of sub-classes of ndarray. If the sub-classes methods does</span>
<span class="sd">        not implement keepdims any exceptions will be raised.</span>
<span class="sd">    overwrite_input</span>
<span class="sd">        If True, then allow use of memory of input array a for calculations.</span>
<span class="sd">        The input array will be modified by the call to median. This will</span>
<span class="sd">        save memory when you do not need to</span>
<span class="sd">        preserve the contents of the input array.</span>
<span class="sd">        Treat the input as undefined, but it will</span>
<span class="sd">        probably be fully or partially sorted.</span>
<span class="sd">        Default is False. If overwrite_input</span>
<span class="sd">        is True and input array is not already an ndarray,</span>
<span class="sd">        an error will be raised.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result. If the input contains integers</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Array([[10.0, ivy.nan, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a.nanmedian(a)</span>
<span class="sd">        3.0</span>
<span class="sd">    &gt;&gt;&gt; a.nanmedian(a, axis=0)</span>
<span class="sd">        array([6.5, 2. , 2.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bincount"><a class="viewcode-back" href="../../../functional/ivy/experimental/bincount/bincount_array.html#ivy.array.array_methods.bincount">[docs]</a><span class="k">def</span> <span class="nf">bincount</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">minlength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.bincount. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bincount also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. The array is flattened if it is not already 1-dimensional.</span>
<span class="sd">    weights</span>
<span class="sd">        Optional weights, array of the same shape as self.</span>
<span class="sd">    minlength</span>
<span class="sd">        A minimum number of bins for the output array.</span>
<span class="sd">    out</span>
<span class="sd">        An array of the same shape as the returned array, or of the shape</span>
<span class="sd">        (minlength,) if minlength is specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of binning the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.array([0, 1, 1, 3, 2, 1, 7])</span>
<span class="sd">    &gt;&gt;&gt; a.bincount()</span>
<span class="sd">        ivy.array([1, 3, 1, 1, 0, 0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; a.bincount(minlength=10)</span>
<span class="sd">        ivy.array([1, 3, 1, 1, 0, 0, 0, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; a.bincount(weights=ivy.array([0.3, 0.5, 0.2, 0.7, 1., 0.6, 1.]))</span>
<span class="sd">        ivy.array([0.3, 1.3, 1. , 0.7, 0. , 0. , 0. , 1. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
        <span class="n">minlength</span><span class="o">=</span><span class="n">minlength</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logit"><a class="viewcode-back" href="../../../functional/ivy/experimental/logit/logit_array.html#ivy.array.array_methods.logit">[docs]</a><span class="k">def</span> <span class="nf">logit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.logit. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.logit</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    eps</span>
<span class="sd">        When eps is None the function outpus NaN where x &lt; 0 or x &gt; 1.</span>
<span class="sd">        and inf or -inf where x = 1 or x = 0, respectively.</span>
<span class="sd">        Otherwise if eps is defined, x is clamped to [eps, 1 - eps]</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing elementwise logits of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 0, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logit()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([       inf,       -inf, 2.19722438])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, -0.9])</span>
<span class="sd">    &gt;&gt;&gt; z = x.logit(eps=0.2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 1.38629448,  1.38629448, -1.38629436])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="thresholded_relu"><a class="viewcode-back" href="../../../functional/ivy/experimental/thresholded_relu/thresholded_relu_array.html#ivy.array.array_methods.thresholded_relu">[docs]</a><span class="k">def</span> <span class="nf">thresholded_relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.thresholded_relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.thresholded_relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    threshold</span>
<span class="sd">        threshold value above which the activation is linear. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array with the relu activation function applied element-wise</span>
<span class="sd">        with custom threshold.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., .2, 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.thresholded_relu(threshold=0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">thresholded_relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="prelu"><a class="viewcode-back" href="../../../functional/ivy/experimental/prelu/prelu_array.html#ivy.array.array_methods.prelu">[docs]</a><span class="k">def</span> <span class="nf">prelu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">slope</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prelu takes input data (Array) and slope array as input,</span>
<span class="sd">    and produces one output data (array) where the function</span>
<span class="sd">    f(x) = slope * x for x &lt; 0, f(x) = x for x &gt;= 0., is applied</span>
<span class="sd">    to the data array elementwise. This operator supports unidirectional</span>
<span class="sd">    broadcasting (array slope should be unidirectional broadcastable to</span>
<span class="sd">    input tensor X);</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    slope</span>
<span class="sd">        Slope Array. The shape of slope can be smaller than first input X;</span>
<span class="sd">        if so, its shape must be unidirectional broadcastable to X.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array with prelu applied elementwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">prelu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="relu6"><a class="viewcode-back" href="../../../functional/ivy/experimental/relu6/relu6_array.html#ivy.array.array_methods.relu6">[docs]</a><span class="k">def</span> <span class="nf">relu6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Applies the rectified linear unit 6 function element-wise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the rectified linear unit 6 activation</span>
<span class="sd">        of each element in input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.,  0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.relu6(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 2., 3., 4., 5., 6., 6.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.,  0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros(9)</span>
<span class="sd">    &gt;&gt;&gt; ivy.relu6(x, out = y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 2., 3., 4., 5., 6., 6.])</span>
<span class="sd">    With :class:`ivy.Container` input:</span>


<span class="sd">    &gt;&gt;&gt; x = {</span>
<span class="sd">                a: ivy.array([-3., -2., -1., 0., 1., 2., 3., 4., 5.]),</span>
<span class="sd">                b: ivy.array([1., 2., 3., 4., 5., 6., 7., 8., 9.])</span>
<span class="sd">            }</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.relu6(x, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">    a: ivy.array([0., 0., 0., 0., 1., 2., 3., 4., 5.]),</span>
<span class="sd">    b: ivy.array([1., 2., 3., 4., 5., 6., 6., 6., 6.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">relu6</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="batch_norm"><a class="viewcode-back" href="../../../functional/ivy/experimental/batch_norm/batch_norm_array.html#ivy.array.array_methods.batch_norm">[docs]</a><span class="k">def</span> <span class="nf">batch_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">mean</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
    <span class="n">variance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.batch_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.batch_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array of shape (N,C,S), where N is the batch dimension, C is the</span>
<span class="sd">        feature dimension and S corresponds to the following spatial dimensions.</span>
<span class="sd">    mean</span>
<span class="sd">        A mean array for the input&#39;s normalization.</span>
<span class="sd">    variance</span>
<span class="sd">        A variance array for the input&#39;s normalization.</span>
<span class="sd">    offset</span>
<span class="sd">        An offset array. If present, will be added to the normalized input.</span>
<span class="sd">    scale</span>
<span class="sd">        A scale array. If present, the scale is applied to the normalized input.</span>
<span class="sd">    training</span>
<span class="sd">        If true, calculate and use the mean and variance of `x`. Otherwise, use the</span>
<span class="sd">        provided `mean` and `variance`.</span>
<span class="sd">    eps</span>
<span class="sd">        A small float number to avoid dividing by 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">         Array containing the normalized, scaled, offset values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">batch_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">mean</span><span class="p">,</span>
        <span class="n">variance</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.general</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="is_native_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_native_array/is_native_array_array.html#ivy.array.array_methods.is_native_array">[docs]</a><span class="k">def</span> <span class="nf">is_native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_native_array. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_native_array</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.is_native_array()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.native_array([9.1, -8.3])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.is_native_array(exclusive=True)</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_ivy_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_array/is_ivy_array_array.html#ivy.array.array_methods.is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_ivy_array. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_ivy_array also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.is_ivy_array()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.native_array([9.1, -8.3])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.is_ivy_array(exclusive=True)</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_array/is_array_array.html#ivy.array.array_methods.is_array">[docs]</a><span class="k">def</span> <span class="nf">is_array</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_array. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.is_array also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(x.is_array())</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.native_array([9.1, -8.3, 2.8, 3.0])</span>
<span class="sd">    &gt;&gt;&gt; print(x.is_array(exclusive=True))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_ivy_container"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_container/is_ivy_container_array.html#ivy.array.array_methods.is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_container</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.is_ivy_container. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_ivy_container also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(x.is_ivy_container())</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="all_equal"><a class="viewcode-back" href="../../../functional/ivy/general/all_equal/all_equal_array.html#ivy.array.array_methods.all_equal">[docs]</a><span class="k">def</span> <span class="nf">all_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="n">x2</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.all_equal. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all_equal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    x2</span>
<span class="sd">        input iterable to compare to ``self``</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix array of booleans if</span>
<span class="sd">        equality_matrix=True is set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([1, 1, 0, 0, 1, -1])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 1, 0, 0, 1, -1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([0, 0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0, 0])</span>
<span class="sd">    &gt;&gt;&gt; x3 = ivy.array([1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2, x3, equality_matrix=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ True,  True, False],</span>
<span class="sd">       [ True,  True, False],</span>
<span class="sd">       [False, False,  True]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all_equal</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">equality_matrix</span><span class="o">=</span><span class="n">equality_matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="has_nans"><a class="viewcode-back" href="../../../functional/ivy/general/has_nans/has_nans_array.html#ivy.array.array_methods.has_nans">[docs]</a><span class="k">def</span> <span class="nf">has_nans</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.has_nans. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.has_nans also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include ``+infinity`` and ``-infinity`` in the check.</span>
<span class="sd">        Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the array contains nans.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.has_nans()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">has_nans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">)</span></div>


<div class="viewcode-block" id="gather"><a class="viewcode-back" href="../../../functional/ivy/general/gather/gather_array.html#ivy.array.array_methods.gather">[docs]</a><span class="k">def</span> <span class="nf">gather</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gather. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gather also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        The array which indicates the indices that will be gathered along</span>
<span class="sd">        the specified axis.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis from which the indices will be gathered. Default is ``-1``.</span>
<span class="sd">    batch_dims</span>
<span class="sd">        optional int, lets you gather different items from each element of a batch.</span>
<span class="sd">    out</span>
<span class="sd">        optional array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with the values gathered at the specified indices along</span>
<span class="sd">        the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; x.gather(y)</span>
<span class="sd">    ivy.array([0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="scatter_nd"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_nd/scatter_nd_array.html#ivy.array.array_methods.scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">scatter_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scatter updates into an array according to indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array of indices</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is ``None``, in which case tensor</span>
<span class="sd">        argument must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values scattered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With scatter values into an array</span>
<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1,2,3,4,5,6,7,8, 9, 10])</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([[4], [3], [1], [7]])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([9, 10, 11, 12])</span>
<span class="sd">    &gt;&gt;&gt; scatter = indices.scatter_nd(updates, reduction=&#39;replace&#39;, out=arr)</span>
<span class="sd">    &gt;&gt;&gt; print(scatter)</span>
<span class="sd">    ivy.array([ 1, 11,  3, 10,  9,  6,  7, 12,  9, 10])</span>
<span class="sd">    With scatter values into an empty array</span>

<span class="sd">    &gt;&gt;&gt; shape = ivy.array([2, 5])</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.array([[1,4], [0,3], [1,1], [0,2]])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([25, 40, 21, 22])</span>
<span class="sd">    &gt;&gt;&gt; scatter = indices.scatter_nd(updates, shape=shape)</span>
<span class="sd">    &gt;&gt;&gt; print(scatter)</span>
<span class="sd">    ivy.array([[ 0,  0, 22, 40,  0],</span>
<span class="sd">                [ 0, 21,  0,  0, 25]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">scatter_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="gather_nd"><a class="viewcode-back" href="../../../functional/ivy/general/gather_nd/gather_nd_array.html#ivy.array.array_methods.gather_nd">[docs]</a><span class="k">def</span> <span class="nf">gather_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gather_nd. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.gather_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The array from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        Index array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values gathered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1])</span>
<span class="sd">    &gt;&gt;&gt; z = x.gather_nd(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="einops_rearrange"><a class="viewcode-back" href="../../../functional/ivy/general/einops_rearrange/einops_rearrange_array.html#ivy.array.array_methods.einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">einops_rearrange</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_rearrange.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.einops_rearrange also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be re-arranged.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.rearrange having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 3],</span>
<span class="sd">    ...               [-4, -5, -6]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_rearrange(&quot;height width -&gt; width height&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 1, -4],</span>
<span class="sd">        [ 2, -5],</span>
<span class="sd">        [ 3, -6]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[ 1,  2,  3],</span>
<span class="sd">    ...                  [ 4,  5,  6]],</span>
<span class="sd">    ...               [[ 7,  8,  9],</span>
<span class="sd">    ...                  [10, 11, 12]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_rearrange(&quot;c h w -&gt; c (h w)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 1,  2,  3,  4,  5,  6],</span>
<span class="sd">        [ 7,  8,  9, 10, 11, 12]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 3, 4, 5, 6]</span>
<span class="sd">    ...               [7, 8, 9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_rearrange(&quot;c (h w) -&gt; (c h) w&quot;, h=2, w=3)</span>
<span class="sd">    ivy.array([[ 1,  2,  3],</span>
<span class="sd">        [ 4,  5,  6],</span>
<span class="sd">        [ 7,  8,  9],</span>
<span class="sd">        [10, 11, 12]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einops_rearrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_lengths</span><span class="p">)</span></div>


<div class="viewcode-block" id="einops_reduce"><a class="viewcode-back" href="../../../functional/ivy/general/einops_reduce/einops_reduce_array.html#ivy.array.array_methods.einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">einops_reduce</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_reduce. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_reduce also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be reduced.</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.reduce having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[5, 4],</span>
<span class="sd">    ...                 [11, 2]],</span>
<span class="sd">    ...                [[3, 5],</span>
<span class="sd">    ...                 [9, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; reduced = x.einops_reduce(&#39;a b c -&gt; b c&#39;, &#39;max&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(reduced)</span>
<span class="sd">    ivy.array([[ 5,  5],</span>
<span class="sd">               [11,  7]])</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[5, 4, 3],</span>
<span class="sd">    ...                 [11, 2, 9]],</span>
<span class="sd">    ...                [[3, 5, 7],</span>
<span class="sd">    ...                 [9, 7, 1]]])</span>
<span class="sd">    &gt;&gt;&gt; reduced = x.einops_reduce(&#39;a b c -&gt; a () c&#39;, &#39;min&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(reduced)</span>
<span class="sd">    ivy.array([[[5, 2, 3]],</span>
<span class="sd">               [[3, 5, 1]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einops_reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_lengths</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einops_repeat"><a class="viewcode-back" href="../../../functional/ivy/general/einops_repeat/einops_repeat_array.html#ivy.array.array_methods.einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">einops_repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einops_repeat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_repeat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to be repeated.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with einops.repeat having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5,4])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_repeat(&#39;a -&gt; a c&#39;, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[5,5,5],[4,4,4]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[5,4],</span>
<span class="sd">    ...                [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einops_repeat(&#39;a b -&gt;  a b c&#39;, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[5,5,5],[4,4,4]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einops_repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_lengths</span><span class="p">)</span></div>


<div class="viewcode-block" id="to_numpy"><a class="viewcode-back" href="../../../functional/ivy/general/to_numpy/to_numpy_array.html#ivy.array.array_methods.to_numpy">[docs]</a><span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    copy</span>
<span class="sd">        whether to copy the array to a new address or not. Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a numpy array copying all the element of the array ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [-1  0  1]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, 0, 1],[-1, 0, 1], [1,0,-1]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [[-1  0  1]</span>
<span class="sd">    [-1  0  1]</span>
<span class="sd">    [ 1  0 -1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="to_list"><a class="viewcode-back" href="../../../functional/ivy/general/to_list/to_list_array.html#ivy.array.array_methods.to_list">[docs]</a><span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_list()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="supports_inplace_updates"><a class="viewcode-back" href="../../../functional/ivy/general/supports_inplace_updates/supports_inplace_updates_array.html#ivy.array.array_methods.supports_inplace_updates">[docs]</a><span class="k">def</span> <span class="nf">supports_inplace_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.supports_inplace_updates. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.supports_inplace_updates</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array whose elements&#39; data type is to be checked.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Bool value depends on whether the currently active backend</span>
<span class="sd">        framework supports in-place operations with argument&#39;s data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `numpy`:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.supports_inplace_updates()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    True</span>
<span class="sd">    With `ivy.Array` input and backend set as &quot;tensorflow&quot;:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 4.2, 2.2])</span>
<span class="sd">    &gt;&gt;&gt; ret = x.supports_inplace_updates()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">supports_inplace_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="inplace_decrement"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_decrement/inplace_decrement_array.html#ivy.array.array_methods.inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">inplace_decrement</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_decrement. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.inplace_decrement also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to be decremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance methods:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, 4.3, 2.5, 1.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([4.7, 3.3, 1.5, 0.9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(2.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.5, 2.5, 3.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">inplace_decrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="stable_divide"><a class="viewcode-back" href="../../../functional/ivy/general/stable_divide/stable_divide_array.html#ivy.array.array_methods.stable_divide">[docs]</a><span class="k">def</span> <span class="nf">stable_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stable_divide. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.stable_divide also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array, used as the numerator for division.</span>
<span class="sd">    denominator</span>
<span class="sd">        denominator for division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        the minimum denominator to use, use global ivy._MIN_DENOMINATOR by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a numpy array containing the elements of numerator divided by</span>
<span class="sd">        the corresponding element of denominator</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 2.5, 3.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(4, min_denominator=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.8, 1. , 1.2])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([[4., 5., 6.], [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.asarray([[1., 2., 3.], [2., 3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[4.  , 2.5 , 2.  ],</span>
<span class="sd">            [3.5 , 2.67, 2.25]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">stable_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">denominator</span><span class="p">,</span> <span class="n">min_denominator</span><span class="o">=</span><span class="n">min_denominator</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip_vector_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_vector_norm/clip_vector_norm_array.html#ivy.array.array_methods.clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip_vector_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.clip_vector_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. </span>
<span class="sd">        Default is 2.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. </span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_vector_norm(2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0.894, 1.79])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">clip_vector_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_norm</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="array_equal"><a class="viewcode-back" href="../../../functional/ivy/general/array_equal/array_equal_array.html#ivy.array.array_methods.array_equal">[docs]</a><span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.array_equal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.array_equal also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    x</span>
<span class="sd">        input array to compare to ``self``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the input arrays are equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1,0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1,0])</span>
<span class="sd">    &gt;&gt;&gt; z = x.array_equal(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; c = a.array_equal(b)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_supports_inplace"><a class="viewcode-back" href="../../../functional/ivy/general/assert_supports_inplace/assert_supports_inplace_array.html#ivy.array.array_methods.assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">assert_supports_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.assert_supports_inplace. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.assert_supports_inplace</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if supports, raises IvyBackendException otherwise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `numpy`:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; print(x.assert_supports_inplace())</span>
<span class="sd">    True</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `jax`:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; print(x.assert_supports_inplace())</span>
<span class="sd">    IvyBackendException: jax: assert_supports_inplace: Inplace operations \</span>
<span class="sd">    are not supported &lt;class &#39;jaxlib.xla_extension.DeviceArray&#39;&gt; types </span>
<span class="sd">    with jax backend</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">assert_supports_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="to_scalar"><a class="viewcode-back" href="../../../functional/ivy/general/to_scalar/to_scalar_array.html#ivy.array.array_methods.to_scalar">[docs]</a><span class="k">def</span> <span class="nf">to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a scalar copying the element of the array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_scalar()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="fourier_encode"><a class="viewcode-back" href="../../../functional/ivy/general/fourier_encode/fourier_encode_array.html#ivy.array.array_methods.fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">fourier_encode</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">concat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.fourier_encode. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fourier_encode also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to encode</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    concat</span>
<span class="sd">        Whether to concatenate the position, sin and cos values, or return</span>
<span class="sd">        seperately. Default is ``True``.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array with the final dimension expanded, and the encodings stored in</span>
<span class="sd">        this channel.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = 1.5</span>
<span class="sd">    &gt;&gt;&gt; z = x.fourier_encode(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[ 1.0000000e+00, 1.2246468e-16, 0.0000000e+00, 0.0000000e+00,</span>
<span class="sd">                 0.0000000e+00, -1.0000000e+00, 1.0000000e+00, 1.0000000e+00,</span>
<span class="sd">                 1.0000000e+00],</span>
<span class="sd">               [ 2.0000000e+00, -2.4492936e-16, 0.0000000e+00, 0.0000000e+00,</span>
<span class="sd">                 0.0000000e+00, 1.0000000e+00, 1.0000000e+00, 1.0000000e+00,</span>
<span class="sd">                 1.0000000e+00],</span>
<span class="sd">               [ 3.0000000e+00, 3.6739404e-16, 0.0000000e+00, 0.0000000e+00,</span>
<span class="sd">                 0.0000000e+00, -1.0000000e+00, 1.0000000e+00, 1.0000000e+00,</span>
<span class="sd">                 1.0000000e+00]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3, 10])</span>
<span class="sd">    &gt;&gt;&gt; y = 2.5</span>
<span class="sd">    &gt;&gt;&gt; z = x.fourier_encode(y, num_bands=3)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[ 3.0000000e+00,  3.6739404e-16,  3.6739404e-16,  3.6739404e-16,</span>
<span class="sd">                -1.0000000e+00, -1.0000000e+00, -1.0000000e+00],</span>
<span class="sd">               [ 1.0000000e+01, -1.2246468e-15, -1.2246468e-15, -1.2246468e-15,</span>
<span class="sd">                 1.0000000e+00,  1.0000000e+00,  1.0000000e+00]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">fourier_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="p">,</span>
        <span class="n">num_bands</span><span class="o">=</span><span class="n">num_bands</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">concat</span><span class="o">=</span><span class="n">concat</span><span class="p">,</span>
        <span class="n">flatten</span><span class="o">=</span><span class="n">flatten</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="value_is_nan"><a class="viewcode-back" href="../../../functional/ivy/general/value_is_nan/value_is_nan_array.html#ivy.array.array_methods.value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">value_is_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.value_is_nan. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.value_is_nan also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Array` instance method:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([92])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;nan&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([float(&#39;inf&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan(include_infs=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">value_is_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">)</span></div>


<div class="viewcode-block" id="exists"><a class="viewcode-back" href="../../../functional/ivy/general/exists/exists_array.html#ivy.array.array_methods.exists">[docs]</a><span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.exists. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.exists also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if x is not None, else False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.exists()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array(None)</span>
<span class="sd">    &gt;&gt;&gt; y = x.exists()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="default"><a class="viewcode-back" href="../../../functional/ivy/general/default/default_array.html#ivy.array.array_methods.default">[docs]</a><span class="k">def</span> <span class="nf">default</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">default_val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">catch_exceptions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">rev</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">with_callable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.default. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.default also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    default_val</span>
<span class="sd">        The default value.</span>
<span class="sd">    catch_exceptions</span>
<span class="sd">        Whether to catch exceptions from callable x. Default is ``False``.</span>
<span class="sd">    rev</span>
<span class="sd">        Whether to reverse the input x and default_val. Default is ``False``.</span>
<span class="sd">    with_callable</span>
<span class="sd">        Whether either of the arguments might be callable functions.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        x if x exists (is not None), else default.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 1.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.default(0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1. , 2. , 3. , 1.2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">default_val</span><span class="p">,</span>
        <span class="n">catch_exceptions</span><span class="o">=</span><span class="n">catch_exceptions</span><span class="p">,</span>
        <span class="n">rev</span><span class="o">=</span><span class="n">rev</span><span class="p">,</span>
        <span class="n">with_callable</span><span class="o">=</span><span class="n">with_callable</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="stable_pow"><a class="viewcode-back" href="../../../functional/ivy/general/stable_pow/stable_pow_array.html#ivy.array.array_methods.stable_pow">[docs]</a><span class="k">def</span> <span class="nf">stable_pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stable_pow. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.stable_pow also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array, used as the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        The exponent number.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new item following the numerically stable power.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">stable_pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">min_base</span><span class="o">=</span><span class="n">min_base</span><span class="p">)</span></div>


<div class="viewcode-block" id="inplace_update"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_update/inplace_update_array.html#ivy.array.array_methods.inplace_update">[docs]</a><span class="k">def</span> <span class="nf">inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">ensure_in_backend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.inplace_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to update</span>
<span class="sd">    val</span>
<span class="sd">        The array to update the variable with.</span>
<span class="sd">    ensure_in_backend</span>
<span class="sd">        Whether to ensure that the `ivy.NativeArray` is also inplace updated.</span>
<span class="sd">        In cases where it should be, backends which do not natively support inplace</span>
<span class="sd">        updates will raise an exception.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following the in-place update.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `numpy`:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; x.inplace_update(y)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([0])</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `torch`:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; x.inplace_update(y, ensure_in_backend=True)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([0])</span>
<span class="sd">    With :class:`ivy.Array` input and default backend set as `jax`:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1])</span>
<span class="sd">    &gt;&gt;&gt; x.inplace_update(y, ensure_in_backend=True)</span>
<span class="sd">    IvyBackendException: jax: inplace_update: JAX does not natively</span>
<span class="sd">    support inplace updates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">inplace_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ensure_in_backend</span><span class="o">=</span><span class="n">ensure_in_backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="inplace_increment"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_increment/inplace_increment_array.html#ivy.array.array_methods.inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">inplace_increment</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inplace_increment. This</span>
<span class="sd">    method wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inplace_increment also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to be incremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of increment.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place increment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance methods:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([5.7, 4.3, 2.5, 1.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_increment(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6.7, 5.3, 3.5, 2.9])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.asarray([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_increment(2.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6.5, 7.5, 8.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">inplace_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip_matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_matrix_norm/clip_matrix_norm_array.html#ivy.array.array_methods.clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip_matrix_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.clip_matrix_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_matrix_norm(2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0.   , 0.894, 1.79 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">clip_matrix_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_norm</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="scatter_flat"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_flat/scatter_flat_array.html#ivy.array.array_methods.scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">scatter_flat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.scatter_flat. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.scatter_flat also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the indices where the new values will occupy</span>
<span class="sd">    updates</span>
<span class="sd">        Values for the new array to hold.</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result. Default is `None`, in which case tensor</span>
<span class="sd">        argument out must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39; or</span>
<span class="sd">        &#39;replace&#39;</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New array of given shape, with the values scattered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; indices = ivy.array([0, 0, 1, 0, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([5, 1, 7, 2, 3, 2, 1, 3])</span>
<span class="sd">    &gt;&gt;&gt; size = 8</span>
<span class="sd">    &gt;&gt;&gt; out = indices.scatter_flat(updates, size=size)</span>
<span class="sd">    &gt;&gt;&gt; print(out)</span>
<span class="sd">    ivy.array([8, 7, 5, 4, 0, 0, 0, 0])</span>
<span class="sd">    With :class:`ivy.Array` input:</span>


<span class="sd">    &gt;&gt;&gt; indices = ivy.array([0, 0, 1, 0, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.array([5, 1, 7, 2, 3, 2, 1, 3])</span>
<span class="sd">    &gt;&gt;&gt; out = ivy.array([0, 0, 0, 0, 0, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; indices.scatter_flat(updates, out=out)</span>
<span class="sd">    &gt;&gt;&gt; print(out)</span>
<span class="sd">    ivy.array([8, 7, 5, 4, 0, 0, 0, 0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">scatter_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_num_dims"><a class="viewcode-back" href="../../../functional/ivy/general/get_num_dims/get_num_dims_array.html#ivy.array.array_methods.get_num_dims">[docs]</a><span class="k">def</span> <span class="nf">get_num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.shape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.shape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to infer the number of dimensions  for</span>
<span class="sd">    as_array</span>
<span class="sd">        Whether to return the shape as a array, default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Shape of the array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.,1.,1.],[1.,0.,0.],[8.,2.,3.]])</span>
<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims()</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0, 0, 0], [0, 0, 0], [0, 0, 0]],\</span>
<span class="sd">                        [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\</span>
<span class="sd">                        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]])</span>
<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims(as_array=False)</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    3</span>
<span class="sd">    </span>

<span class="sd">    &gt;&gt;&gt; b = x.get_num_dims(as_array=True)</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    ivy.array(3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="n">as_array</span><span class="p">)</span></div>


<span class="c1">#ivy.array.gradients</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../functional/ivy/gradients/stop_gradient/stop_gradient_array.html#ivy.array.array_methods.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array for which to stop the gradient.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve gradient computation on ivy.Array instances. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.stop_gradient(preserve_type=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 2., 3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preserve_type</span><span class="o">=</span><span class="n">preserve_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="adam_step"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_step/adam_step_array.html#ivy.array.array_methods.adam_step">[docs]</a><span class="k">def</span> <span class="nf">adam_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">mw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.adam_step. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.adam_step also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    mw</span>
<span class="sd">        running average of the gradients.</span>
<span class="sd">    vw</span>
<span class="sd">        running average of second moments of the gradients.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The adam step delta.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.ones(3)</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.ones(1)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array(3)</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    (ivy.array([0.2020105,0.22187898,0.24144873]),</span>
<span class="sd">        ivy.array([1.,1.10000002,1.20000005]),</span>
<span class="sd">        ivy.array([1.,1.00300002,1.00800002]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adam_step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">vw</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="optimizer_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/optimizer_update/optimizer_update_array.html#ivy.array.array_methods.optimizer_update">[docs]</a><span class="k">def</span> <span class="nf">optimizer_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">effective_grad</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.optimizer_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.optimizer_update also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    effective_grad</span>
<span class="sd">        Effective gradients of the cost c with respect to the weights ws,</span>
<span class="sd">        [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the optimizer updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    ivy.array([1., 2., 3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">optimizer_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">effective_grad</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gradient_descent_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/gradient_descent_update/gradient_descent_update_array.html#ivy.array.array_methods.gradient_descent_update">[docs]</a><span class="k">def</span> <span class="nf">gradient_descent_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.gradient_descent_update.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.gradient_descent_update also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be</span>
<span class="sd">        updated relative to the gradient.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new weights, following the gradient descent updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2, 3],</span>
<span class="sd">    ...                [4, 6, 1],</span>
<span class="sd">    ...                [1, 0, 7]])</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([[0.5, 0.2, 0.1],</span>
<span class="sd">    ...                   [0.3, 0.6, 0.4],</span>
<span class="sd">    ...                   [0.4, 0.7, 0.2]])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.1)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.gradient_descent_update(dcdw, lr, stop_gradients = True)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ivy.array([[ 0.95,  1.98,  2.99],</span>
<span class="sd">    ...        [ 3.97,  5.94,  0.96],</span>
<span class="sd">    ...        [ 0.96, -0.07,  6.98]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gradient_descent_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dcdw</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lars_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lars_update/lars_update_array.html#ivy.array.array_methods.lars_update">[docs]</a><span class="k">def</span> <span class="nf">lars_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.lars_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.lars_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate, the rate at which the weights should be updated relative to</span>
<span class="sd">        the gradient.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LARS updates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lars_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">decay_lambda</span><span class="o">=</span><span class="n">decay_lambda</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="adam_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_update/adam_update_array.html#ivy.array.array_methods.adam_update">[docs]</a><span class="k">def</span> <span class="nf">adam_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.adam_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.adam_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, and also new mw and vw, following the adam</span>
<span class="sd">        updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.array([1., 2, 3.])</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([0.2,0.1,0.3])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.1)</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.zeros(1)</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; step = 2</span>
<span class="sd">    &gt;&gt;&gt; updated_weights = w.adam_update(dcdw, lr, mw_tm1, vw_tm1, step)</span>
<span class="sd">    &gt;&gt;&gt; print(updated_weights)</span>
<span class="sd">    (ivy.array([0.92558753, 1.92558873, 2.92558718]),</span>
<span class="sd">    ivy.array([0.02, 0.01, 0.03]),</span>
<span class="sd">    ivy.array([4.00000063e-05, 1.00000016e-05, 9.00000086e-05]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adam_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">mw_tm1</span><span class="p">,</span>
        <span class="n">vw_tm1</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span>
        <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lamb_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lamb_update/lamb_update_array.html#ivy.array.array_methods.lamb_update">[docs]</a><span class="k">def</span> <span class="nf">lamb_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">max_trust_ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.lamb_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.lamb_update also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    max_trust_ratio</span>
<span class="sd">        The maximum value for the trust ratio. Default is 10.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LAMB updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.array([1., 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([0.5,0.2,0.1])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.1)</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.zeros(1)</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array(1)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, lr, mw_tm1, vw_tm1, step)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    (ivy.array([0.784, 1.78 , 2.78 ]),</span>
<span class="sd">    ivy.array([0.05, 0.02, 0.01]),</span>
<span class="sd">    ivy.array([2.5e-04, 4.0e-05, 1.0e-05]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lamb_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">mw_tm1</span><span class="p">,</span>
        <span class="n">vw_tm1</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span>
        <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">max_trust_ratio</span><span class="o">=</span><span class="n">max_trust_ratio</span><span class="p">,</span>
        <span class="n">decay_lambda</span><span class="o">=</span><span class="n">decay_lambda</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.layers</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># ToDo: update docstrings and typehints according to ivy\layers</span>




<div class="viewcode-block" id="linear"><a class="viewcode-back" href="../../../functional/ivy/layers/linear/linear_array.html#ivy.array.array_methods.linear">[docs]</a><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.linear. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.linear also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array to compute linear transformation on.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,in_features]*</span>
<span class="sd">    weight</span>
<span class="sd">        The weight matrix. *[outer_batch_shape,out_features,in_features]*</span>
<span class="sd">    bias</span>
<span class="sd">        The bias vector, default is ``None``. *[outer_batch_shape,out_features]*</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the linear transformation.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,out_features]*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3], \</span>
<span class="sd">                       [4.4, 5.5, 6.6], \</span>
<span class="sd">                       [7.7, 8.8, 9.9]])</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2., 3.], \</span>
<span class="sd">                       [4., 5., 6.], \</span>
<span class="sd">                       [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([1., 0., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.linear(w, bias=b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 16.4,  35.2,  54. ],</span>
<span class="sd">               [ 36.2,  84.7, 133. ],</span>
<span class="sd">               [ 56. , 134. , 212. ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dropout"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout/dropout_array.html#ivy.array.array_methods.dropout">[docs]</a><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">noise_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dropout. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.droput also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array x to perform dropout on.</span>
<span class="sd">    prob</span>
<span class="sd">        The probability of zeroing out each array element, float between 0 and 1.</span>
<span class="sd">    scale</span>
<span class="sd">        Whether to scale the output by `1/(1-prob)`, default is ``True``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If dtype is None, the output array data type</span>
<span class="sd">        must be inferred from x. Default: ``None``.</span>
<span class="sd">    training</span>
<span class="sd">        Turn on dropout if training, turn off otherwise. Default is ``True``.</span>
<span class="sd">    seed</span>
<span class="sd">        Set a default seed for random number generating (for</span>
<span class="sd">        reproducibility).Default is ``None``.</span>
<span class="sd">    noise_shape</span>
<span class="sd">        a sequence representing the shape of the binary dropout mask that will be</span>
<span class="sd">        multiplied with the input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the output after dropout is performed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2., 3.],</span>
<span class="sd">    ...                [4., 5., 6.],</span>
<span class="sd">    ...                [7., 8., 9.],</span>
<span class="sd">    ...                [10., 11., 12.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dropout(0.3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 1.42857146,  2.85714293,  4.28571415],</span>
<span class="sd">               [ 5.71428585,  7.14285755,  8.5714283 ],</span>
<span class="sd">               [ 0.        , 11.4285717 , 12.8571434 ],</span>
<span class="sd">               [14.2857151 ,  0.        ,  0.        ]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2., 3.],</span>
<span class="sd">    ...                [4., 5., 6.],</span>
<span class="sd">    ...                [7., 8., 9.],</span>
<span class="sd">    ...                [10., 11., 12.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dropout(0.3, scale=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 1.,  2., 3.],</span>
<span class="sd">               [ 4.,  5., 0.],</span>
<span class="sd">               [ 7.,  0., 9.],</span>
<span class="sd">               [10., 11., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">noise_shape</span><span class="o">=</span><span class="n">noise_shape</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">dropout1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dropout1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.droput1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array x to perform dropout on.</span>
<span class="sd">    prob</span>
<span class="sd">        The probability of zeroing out each array element, float between 0 and 1.</span>
<span class="sd">    training</span>
<span class="sd">        Turn on dropout if training, turn off otherwise. Default is ``True``.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Default is ``&quot;NCW&quot;``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the output after dropout is performed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 1, 1]).reshape([1, 1, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.dropout1d(0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[2., 0, 2.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dropout1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dropout3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.dropout3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.droput3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input array x to perform dropout on.</span>
<span class="sd">    prob</span>
<span class="sd">        The probability of zeroing out each array element, float between 0 and 1.</span>
<span class="sd">    training</span>
<span class="sd">        Turn on dropout if training, turn off otherwise. Default is ``True``.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NDHWC&quot; or &quot;NCDHW&quot;. Default is ``&quot;NDHWC&quot;``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the output after dropout is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">dropout3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="scaled_dot_product_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/scaled_dot_product_attention/scaled_dot_product_attention_array.html#ivy.array.array_methods.scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">scaled_dot_product_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.scaled_dot_product_attention.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.scaled_dot_product_attention also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The queries input array. The shape of queries input array should be in</span>
<span class="sd">        *[batch_shape,num_queries,feat_dim]*. The queries input array should</span>
<span class="sd">        have the same size as keys and values.</span>
<span class="sd">    k</span>
<span class="sd">        The keys input array. The shape of keys input array should be in</span>
<span class="sd">        *[batch_shape,num_keys,feat_dim]*. The keys input array should have</span>
<span class="sd">        the same size as queries and values.</span>
<span class="sd">    v</span>
<span class="sd">        The values input array. The shape of values input should be in</span>
<span class="sd">        *[batch_shape,num_keys,feat_dim]*. The values input array should</span>
<span class="sd">        have the same size as queries and keys.</span>
<span class="sd">    scale</span>
<span class="sd">        The scale float value.</span>
<span class="sd">        The scale float value is used to scale the query-key pairs before softmax.</span>
<span class="sd">    mask</span>
<span class="sd">        The mask input array. The mask to apply to the query-key values.</span>
<span class="sd">        Default is None. The shape of mask input should be in</span>
<span class="sd">        *[batch_shape,num_queries,num_keys]*.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The output following application of scaled dot-product attention.</span>
<span class="sd">        The output array is the weighted sum produced by the attention score</span>
<span class="sd">        and value. The shape of output array is</span>
<span class="sd">        *[batch_shape,num_queries,feat_dim]* .</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; q = ivy.array([[[0.2, 1.], [2.2, 3.], [4.4, 5.6]]])</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.array([[[0.6, 1.5], [2.4, 3.3], [4.2, 5.1]]])</span>
<span class="sd">    &gt;&gt;&gt; v = ivy.array([[[0.4, 1.3], [2.2, 3.1], [4.3, 5.3]]])</span>
<span class="sd">    &gt;&gt;&gt; mask = ivy.array([[[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]])</span>
<span class="sd">    &gt;&gt;&gt; result = q.scaled_dot_product_attention(k, v, 1, mask=mask)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[[2.3, 3.23],[2.3, 3.23],[2.3, 3.23]]])</span>

<span class="sd">    &gt;&gt;&gt; q = ivy.array([[[0.2, 1.], [2.2, 3.], [4.4, 5.6]]])</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.array([[[0.6, 1.5], [2.4, 3.3], [4.2, 5.1]]])</span>
<span class="sd">    &gt;&gt;&gt; v = ivy.array([[[0.4, 1.3], [2.2, 3.1], [4.3, 5.3]]])</span>
<span class="sd">    &gt;&gt;&gt; mask = ivy.array([[[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]])</span>
<span class="sd">    &gt;&gt;&gt; out = ivy.zeros(shape=(1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; q.scaled_dot_product_attention(k, v, 1, mask=mask, out=out)</span>
<span class="sd">    &gt;&gt;&gt; print(out)</span>
<span class="sd">    ivy.array([[[2.3, 3.23],[2.3, 3.23],[2.3, 3.23]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">scaled_dot_product_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multi_head_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/multi_head_attention/multi_head_attention_array.html#ivy.array.array_methods.multi_head_attention">[docs]</a><span class="k">def</span> <span class="nf">multi_head_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multi_head_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">to_q_fn</span><span class="o">=</span><span class="n">to_q_fn</span><span class="p">,</span>
        <span class="n">to_kv_fn</span><span class="o">=</span><span class="n">to_kv_fn</span><span class="p">,</span>
        <span class="n">to_out_fn</span><span class="o">=</span><span class="n">to_out_fn</span><span class="p">,</span>
        <span class="n">to_q_v</span><span class="o">=</span><span class="n">to_q_v</span><span class="p">,</span>
        <span class="n">to_kv_v</span><span class="o">=</span><span class="n">to_kv_v</span><span class="p">,</span>
        <span class="n">to_out_v</span><span class="o">=</span><span class="n">to_out_v</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv1d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d/conv1d_array.html#ivy.array.array_methods.conv1d">[docs]</a><span class="k">def</span> <span class="nf">conv1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,w,d_in]* or *[batch_size,d_in,w]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1., 2.], [3., 4.], [6., 7.], [9., 11.]]])  # NWC</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 1.], [1., 1.]]])  # WIO (I == C)</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv1d(filters, (1,), &#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[[ 2.,  3.],</span>
<span class="sd">    ...         [ 4.,  7.],</span>
<span class="sd">    ...         [ 7., 13.],</span>
<span class="sd">    ...         [11., 20.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv1d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d_transpose/conv1d_transpose_array.html#ivy.array.array_methods.conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv1d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.conv1d_transpose. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d_transpose also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,w,d_in]* or *[batch_size,d_in,w]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        either the string SAME (padding with zeros evenly), the string VALID (no</span>
<span class="sd">        padding), or a sequence of n (low, high) integer pairs that give the padding</span>
<span class="sd">        to apply before and after each spatial dimension.</span>
<span class="sd">    output_shape</span>
<span class="sd">        Shape of the output (Default value = None)</span>
<span class="sd">    data_format</span>
<span class="sd">        The ordering of the dimensions in the input, one of &quot;NWC&quot; or &quot;NCW&quot;. &quot;NWC&quot;</span>
<span class="sd">        corresponds to input with shape (batch_size, width, channels), while &quot;NCW&quot;</span>
<span class="sd">        corresponds to input with shape (batch_size, channels, width).</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the transpose convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1., 2.], [3., 4.], [6., 7.], [9., 11.]]])  # NWC</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 1.], [1., 1.]]])  # WIO (I == C)</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv1d_transpose(filters, (1,), &#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[[ 2.,  3.],</span>
<span class="sd">    ...         [ 4.,  7.],</span>
<span class="sd">    ...         [ 7., 13.],</span>
<span class="sd">    ...         [11., 20.]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv1d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="depthwise_conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/depthwise_conv2d/depthwise_conv2d_array.html#ivy.array.array_methods.depthwise_conv2d">[docs]</a><span class="k">def</span> <span class="nf">depthwise_conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.depthwise_conv2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.depthwise_conv2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from self)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.depthwise_conv2d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    (1, 64, 64, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">depthwise_conv2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d/conv2d_array.html#ivy.array.array_methods.conv2d">[docs]</a><span class="k">def</span> <span class="nf">conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.conv2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.conv2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]* or *[batch_size,d_in,h,w]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[[1.], [2.0],[3.]],</span>
<span class="sd">    ...                 [[1.], [2.0],[3.]],</span>
<span class="sd">    ...                 [[1.], [2.0],[3.]]]]) #NHWC</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[[0.]], [[1.]], [[0.]]],</span>
<span class="sd">    ...                      [[[0.]], [[1.]], [[0.]]],</span>
<span class="sd">    ...                      [[[0.]], [[1.]], [[0.]]]]) #HWIO</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv2d(filters, 1, &#39;SAME&#39;, data_format=&#39;NHWC&#39;,</span>
<span class="sd">    ...    dilations= 1)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[</span>
<span class="sd">              [[2.],[4.],[6.]],</span>
<span class="sd">              [[3.],[6.],[9.]],</span>
<span class="sd">              [[2.],[4.],[6.]]</span>
<span class="sd">              ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv2d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d_transpose/conv2d_transpose_array.html#ivy.array.array_methods.conv2d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv2d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.conv2d_transpose`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.conv2d_transpose` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]* or *[batch_size,d_in,h,w]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    output_shape</span>
<span class="sd">        Shape of the output (Default value = None)</span>
<span class="sd">    data_format</span>
<span class="sd">        The ordering of the dimensions in the input, one of &quot;NHWC&quot; or &quot;NCHW&quot;. &quot;NHWC&quot;</span>
<span class="sd">        corresponds to inputs with shape (batch_size, height, width, channels),</span>
<span class="sd">        while &quot;NCHW&quot; corresponds to input with shape (batch_size, channels, height,</span>
<span class="sd">        width). Default is ``&quot;NHWC&quot;``.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        Optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the transpose convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.random_normal(mean=0, std=1, shape=[1, 28, 28, 3])</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.conv2d_transpose(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    (1, 56, 56, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv2d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv3d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d/conv3d_array.html#ivy.array.array_methods.conv3d">[docs]</a><span class="k">def</span> <span class="nf">conv3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.conv3d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.conv3d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fd,fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.ones((1, 3, 3, 3, 1)).astype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.ones((1, 3, 3, 1, 1)).astype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv3d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    ivy.array([[[[[4.],[4.]],[[4.],[4.]]],[[[4.],[4.]],[[4.],[4.]]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv3d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d_transpose/conv3d_transpose_array.html#ivy.array.array_methods.conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv3d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of `ivy.conv3d_transpose`. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    `ivy.conv3d_transpose` also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]* or *[batch_size,d_in,d,h,w]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fd,fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    output_shape</span>
<span class="sd">        Shape of the output (Default value = None)</span>
<span class="sd">    data_format</span>
<span class="sd">        The ordering of the dimensions in the input, one of &quot;NDHWC&quot; or</span>
<span class="sd">        &quot;NCDHW&quot;. &quot;NDHWC&quot; corresponds to inputs with shape (batch_size,</span>
<span class="sd">         depth, height, width, channels), while &quot;NCDHW&quot; corresponds</span>
<span class="sd">         to input with shape (batch_size, channels, depth, height,</span>
<span class="sd">         width).</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the transpose convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.random_normal(mean=0, std=1, shape=[1, 3, 28, 28, 3])</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3, 3, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.conv3d_transpose(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    (1, 6, 56, 56, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">conv3d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lstm_update"><a class="viewcode-back" href="../../../functional/ivy/layers/lstm_update/lstm_update_array.html#ivy.array.array_methods.lstm_update">[docs]</a><span class="k">def</span> <span class="nf">lstm_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.lstm_update. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.lstm_update also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    init_h</span>
<span class="sd">        initial state tensor for the cell output *[batch_shape, out]*.</span>
<span class="sd">    init_c</span>
<span class="sd">        initial state tensor for the cell hidden state *[batch_shape, out]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        weights for cell kernel *[in, 4 x out]*.</span>
<span class="sd">    recurrent_kernel</span>
<span class="sd">        weights for cell recurrent kernel *[out, 4 x out]*.</span>
<span class="sd">    bias</span>
<span class="sd">        bias for cell kernel *[4 x out]*. (Default value = None)</span>
<span class="sd">    recurrent_bias</span>
<span class="sd">        bias for cell recurrent kernel *[4 x out]*. (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        hidden state for all timesteps *[batch_shape,t,out]* and cell state for last</span>
<span class="sd">        timestep *[batch_shape,out]*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.randint(0, 20, shape=(6, 20, 3))</span>
<span class="sd">    &gt;&gt;&gt; h_i = ivy.random_normal(shape=(6, 5))</span>
<span class="sd">    &gt;&gt;&gt; c_i = ivy.random_normal(shape=(6, 5))</span>
<span class="sd">    &gt;&gt;&gt; kernel = ivy.random_normal(shape=(3, 4 * 5))</span>
<span class="sd">    &gt;&gt;&gt; rc = ivy.random_normal(shape=(5, 4 * 5))</span>
<span class="sd">    &gt;&gt;&gt; result = x.lstm_update(h_i, c_i, kernel, rc)</span>
<span class="sd">    &gt;&gt;&gt; result[0].shape</span>
<span class="sd">    (6, 20, 5)</span>

<span class="sd">    &gt;&gt;&gt; result[1].shape</span>
<span class="sd">    (6, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lstm_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.linear_algebra</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>




<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matmul/matmul_array.html#ivy.array.array_methods.matmul">[docs]</a><span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">transpose_a</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">transpose_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">adjoint_a</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">adjoint_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.matmul. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.matmul also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type. Must have at least one</span>
<span class="sd">        dimension.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Should have a numeric data type. Must have at least one</span>
<span class="sd">        dimension.</span>
<span class="sd">    transpose_a</span>
<span class="sd">        if True, ``x1`` is transposed before multiplication.</span>
<span class="sd">    transpose_b</span>
<span class="sd">        if True, ``x2`` is transposed before multiplication.</span>
<span class="sd">    adjoint_a</span>
<span class="sd">        If True, takes the conjugate of the matrix then the transpose of the matrix.</span>
<span class="sd">        adjoint_a and transpose_a can not be true at the same time.</span>
<span class="sd">    adjoint_b</span>
<span class="sd">        If True, takes the conjugate of the matrix then the transpose of the matrix.</span>
<span class="sd">        adjoint_b and transpose_b can not be true at the same time.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array containing the output of matrix multiplication. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`. More details</span>
<span class="sd">        can be found in ivy.matmul.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 4.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3., 2.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.matmul(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(11.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">transpose_a</span><span class="o">=</span><span class="n">transpose_a</span><span class="p">,</span>
        <span class="n">transpose_b</span><span class="o">=</span><span class="n">transpose_b</span><span class="p">,</span>
        <span class="n">adjoint_a</span><span class="o">=</span><span class="n">adjoint_a</span><span class="p">,</span>
        <span class="n">adjoint_b</span><span class="o">=</span><span class="n">adjoint_b</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cholesky"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cholesky/cholesky_array.html#ivy.array.array_methods.cholesky">[docs]</a><span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cholesky. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cholesky also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions form</span>
<span class="sd">        square symmetric positive-definite matrices. Should have a floating-point</span>
<span class="sd">        data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Cholesky factors for each square matrix. If upper is</span>
<span class="sd">        False, the returned array must contain lower-triangular matrices; otherwise,</span>
<span class="sd">        the returned array must contain upper-triangular matrices. The returned</span>
<span class="sd">        array must have a floating-point data type determined by Type Promotion</span>
<span class="sd">        Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[4.0, 1.0, 2.0, 0.5, 2.0],</span>
<span class="sd">    ...               [1.0, 0.5, 0.0, 0.0, 0.0],</span>
<span class="sd">    ...               [2.0, 0.0, 3.0, 0.0, 0.0],</span>
<span class="sd">    ...               [0.5, 0.0, 0.0, 0.625, 0.0],</span>
<span class="sd">    ...               [2.0, 0.0, 0.0, 0.0, 16.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cholesky(upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 2.  ,  0.5 ,  1.  ,  0.25,  1.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.5 , -1.  , -0.25, -1.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  1.  , -0.5 , -2.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  0.  ,  0.5 , -3.  ],</span>
<span class="sd">    ...        [ 0.  ,  0.  ,  0.  ,  0.  ,  1.  ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="cross"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cross/cross_array.html#ivy.array.array_methods.cross">[docs]</a><span class="k">def</span> <span class="nf">cross</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cross. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cross also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute (default: -1) the cross product.vIf set to -1, the function</span>
<span class="sd">        computes the cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must</span>
<span class="sd">        have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 1., 0.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0., 0., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="det"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/det/det_array.html#ivy.array.array_methods.det">[docs]</a><span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2.,4.],[6.,7.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.det()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(-10.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diagonal/diagonal_array.html#ivy.array.array_methods.diagonal">[docs]</a><span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.diagonal. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.diagonal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    offset</span>
<span class="sd">        offset specifying the off-diagonal relative to the main diagonal.</span>
<span class="sd">        - ``offset = 0``: the main diagonal.</span>
<span class="sd">        - ``offset &gt; 0``: off-diagonal above the main diagonal.</span>
<span class="sd">        - ``offset &lt; 0``: off-diagonal below the main diagonal.</span>
<span class="sd">        Default: `0`.</span>
<span class="sd">    axis1</span>
<span class="sd">        axis to be used as the first axis of the 2-D sub-arrays from</span>
<span class="sd">        which the diagonals should be taken. Defaults to first axis (-2).</span>
<span class="sd">    axis2</span>
<span class="sd">        axis to be used as the second axis of the 2-D sub-arrays from which</span>
<span class="sd">        the diagonals should be taken. Defaults to second axis (-1).</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the diagonals and whose shape is determined</span>
<span class="sd">        by removing the last two dimensions and appending a dimension equal</span>
<span class="sd">        to the size of the resulting diagonals. The returned array must</span>
<span class="sd">        have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.],</span>
<span class="sd">    ...                [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; d = x.diagonal()</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    ivy.array([1., 4.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1., 2.],</span>
<span class="sd">    ...                 [3., 4.]],</span>
<span class="sd">    ...                [[5., 6.],</span>
<span class="sd">    ...                 [7., 8.]]])</span>
<span class="sd">    &gt;&gt;&gt; d = x.diagonal()</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    ivy.array([[1., 4.],</span>
<span class="sd">               [5., 8.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.],</span>
<span class="sd">    ...                [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; d = x.diagonal(offset=1)</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    ivy.array([2.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2],</span>
<span class="sd">    ...                [3, 4, 5],</span>
<span class="sd">    ...                [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; d = x.diagonal(offset=-1, axis1=0)</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    ivy.array([3, 7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diag/diag_array.html#ivy.array.array_methods.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.diag.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.diag also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2],</span>
<span class="sd">    &gt;&gt;&gt;                [3, 4, 5],</span>
<span class="sd">    &gt;&gt;&gt;                [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; x.diag(k=1)</span>
<span class="sd">    ivy.array([1, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="eig"><a class="viewcode-back" href="../../../functional/ivy/experimental/eig/eig_array.html#ivy.array.array_methods.eig">[docs]</a><span class="k">def</span> <span class="nf">eig</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigh/eigh_array.html#ivy.array.array_methods.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">UPLO</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="eigvalsh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigvalsh/eigvalsh_array.html#ivy.array.array_methods.eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">eigvalsh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">UPLO</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.eigvalsh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eigvalsh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions form</span>
<span class="sd">        square matrices. Must have floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the computed eigenvalues. The returned array must have shape</span>
<span class="sd">        (..., M) and have the same data type as x.</span>
<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/extensions/generated/signatures.linalg.eigvalsh.html&gt;`_ </span>
<span class="sd">    in the standard.</span>
<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :class:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[1.0,2.0],[2.0,1.0]]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.eigvalsh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-1.,  3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inner/inner_array.html#ivy.array.array_methods.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="inv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inv/inv_array.html#ivy.array.array_methods.inv">[docs]</a><span class="k">def</span> <span class="nf">inv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.inv.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inv also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, M)`` and whose innermost two</span>
<span class="sd">        dimensions form square matrices. Should have a floating-point data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the multiplicative inverses. The returned array</span>
<span class="sd">        must have a floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        and must have the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.0, 2.0],[3.0, 4.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.inv()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-2., 1.],[1.5, -0.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_norm/matrix_norm_array.html#ivy.array.array_methods.matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array having shape (..., M, N) and whose innermost two dimensions</span>
<span class="sd">        form MxN matrices. Should have a floating-point data type.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is &quot;fro&quot;.</span>
<span class="sd">    axis</span>
<span class="sd">        specifies the axes that hold 2-D matrices. Default: (-2, -1).</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in</span>
<span class="sd">        the result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.2, 3.3], [1.0, 2.0, 3.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.3)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.arange(8, dtype=float).reshape((2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=&quot;nuc&quot;, axis=(2, 1), keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[ 4.24]],</span>
<span class="sd">            [[11.4 ]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matrix_power"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_power/matrix_power_array.html#ivy.array.array_methods.matrix_power">[docs]</a><span class="k">def</span> <span class="nf">matrix_power</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_rank/matrix_rank_array.html#ivy.array.array_methods.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.matrix_rank. This method returns</span>
<span class="sd">    the rank (i.e., number of non-zero singular values) of a matrix (or a stack of</span>
<span class="sd">    matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two dimensions</span>
<span class="sd">        form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    atol</span>
<span class="sd">        absolute tolerance. When None its considered to be zero.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values approximately</span>
<span class="sd">        less than or equal to ``rtol * largest_singular_value`` are set to zero.</span>
<span class="sd">        If a ``float``, the value is equivalent to a zero-dimensional array having</span>
<span class="sd">        a floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``) and must be broadcast against each matrix.</span>
<span class="sd">        If an ``array``, must have a floating-point data type and must be</span>
<span class="sd">        compatible with ``shape(x)[:-2]`` (see :ref:`broadcasting`).</span>
<span class="sd">        If ``None``, the default value is ``max(M, N) * eps``, where ``eps`` must</span>
<span class="sd">        be the machine epsilon associated with the floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion` (as applied to ``x``).</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and</span>
<span class="sd">        must have shape ``(...)``</span>
<span class="sd">        (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1. Full Matrix</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(2.)</span>
<span class="sd">    2. Rank Deficient Matrix</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 0.], [0., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(1.)</span>
<span class="sd">    3. 1 Dimension - rank 1 unless all 0</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.matrix_rank(x)</span>
<span class="sd">    ivy.array(0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="matrix_transpose"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_transpose/matrix_transpose_array.html#ivy.array.array_methods.matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">matrix_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have</span>
<span class="sd">        a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the transpose for each matrix and having shape</span>
<span class="sd">        ``(..., N, M)``. The returned array must have the same data</span>
<span class="sd">        type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [0., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_transpose()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 0.],</span>
<span class="sd">               [2., 3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">conjugate</span><span class="o">=</span><span class="n">conjugate</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/outer/outer_array.html#ivy.array.array_methods.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/pinv/pinv_array.html#ivy.array.array_methods.pinv">[docs]</a><span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.pinv. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.pinv also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. More details in ivy.pinv.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array containing the pseudo-inverses. More details in ivy.pinv.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.pinv()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-2., 1.],</span>
<span class="sd">               [1.5, -0.5]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.zeros((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.pinv(rtol=0, out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([[0.0426, 0.0964],</span>
<span class="sd">               [0.0605, 0.1368]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/qr/qr_array.html#ivy.array.array_methods.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.qr. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.qr also applies to this method with</span>
<span class="sd">    minimal changes.</span>
<span class="sd">    Returns the qr decomposition x = QR of a full column rank matrix (or a stack of</span>
<span class="sd">    matrices), where Q is an orthonormal matrix (or a stack of matrices) and R is an</span>
<span class="sd">    upper-triangular matrix (or a stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, N) and whose innermost two dimensions form</span>
<span class="sd">        MxN matrices of rank N. Should have a floating-point data type.</span>
<span class="sd">    mode</span>
<span class="sd">        decomposition mode. Should be one of the following modes:</span>
<span class="sd">        - &#39;reduced&#39;: compute only the leading K columns of q, such that q and r have</span>
<span class="sd">        dimensions (..., M, K) and (..., K, N), respectively, and where</span>
<span class="sd">        K = min(M, N).</span>
<span class="sd">        - &#39;complete&#39;: compute q and r with dimensions (..., M, M) and (..., M, N),</span>
<span class="sd">        respectively.</span>
<span class="sd">        Default: &#39;reduced&#39;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output tuple of arrays, for writing the result to. The arrays must</span>
<span class="sd">        have shapes that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple (Q, R) whose</span>
<span class="sd">        - first element must have the field name Q and must be an array whose shape</span>
<span class="sd">        depends on the value of mode and contain matrices with orthonormal columns.</span>
<span class="sd">        If mode is &#39;complete&#39;, the array must have shape (..., M, M). If mode is</span>
<span class="sd">        &#39;reduced&#39;, the array must have shape (..., M, K), where K = min(M, N). The</span>
<span class="sd">        first x.ndim-2 dimensions must have the same size as those of the input</span>
<span class="sd">        array x.</span>
<span class="sd">        - second element must have the field name R and must be an array whose shape</span>
<span class="sd">        depends on the value of mode and contain upper-triangular matrices. If mode</span>
<span class="sd">        is &#39;complete&#39;, the array must have shape (..., M, N). If mode is &#39;reduced&#39;,</span>
<span class="sd">        the array must have shape (..., K, N), where K = min(M, N). The first</span>
<span class="sd">        x.ndim-2 dimensions must have the same size as those of the input x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="slogdet"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/slogdet/slogdet_array.html#ivy.array.array_methods.slogdet">[docs]</a><span class="k">def</span> <span class="nf">slogdet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.slogdet. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.slogdet also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape (..., M, M) and whose innermost two dimensions</span>
<span class="sd">        form square matrices. Should have a floating-point data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        This function returns NamedTuple with two values -</span>
<span class="sd">            sign:</span>
<span class="sd">            An array containing a number representing the sign of the determinant</span>
<span class="sd">            for each square matrix.</span>
<span class="sd">            logabsdet:</span>
<span class="sd">            An array containing natural log of the absolute determinant of each</span>
<span class="sd">            square matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.slogdet()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    slogdet(sign=ivy.array(-1.), logabsdet=ivy.array(0.6931472))</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.2, 2.0, 3.1],</span>
<span class="sd">    ...                [6.0, 5.2, 4.0],</span>
<span class="sd">    ...                [9.0, 8.0, 7.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.slogdet()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    slogdet(sign=ivy.array(-1.), logabsdet=ivy.array(1.098611))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/solve/solve_array.html#ivy.array.array_methods.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">adjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svd/svd_array.html#ivy.array.array_methods.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compute_uv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.svf. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.svd also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form matrices on which to perform singular value decomposition.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    full_matrices</span>
<span class="sd">        If ``True``, compute full-sized ``U`` and ``Vh``, such that ``U`` has shape</span>
<span class="sd">        ``(..., M, M)`` and ``Vh`` has shape ``(..., N, N)``. If ``False``,</span>
<span class="sd">        compute on the leading ``K`` singular vectors, such that ``U`` has</span>
<span class="sd">        shape ``(..., M, K)`` and ``Vh`` has shape ``(..., K, N)`` and where</span>
<span class="sd">        ``K = min(M, N)``. Default: ``True``.</span>
<span class="sd">    compute_uv</span>
<span class="sd">        If ``True`` then left and right singular vectors will be computed and</span>
<span class="sd">        returned in ``U`` and ``Vh``, respectively. Otherwise, only the</span>
<span class="sd">        singular values will be computed, which can be significantly faster.</span>
<span class="sd">    .. note::</span>
<span class="sd">        with backend set as torch, svd with still compute left and right singular</span>
<span class="sd">        vectors irrespective of the value of compute_uv, however Ivy will still only</span>
<span class="sd">        return the singular values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    .. note::</span>
<span class="sd">        once complex numbers are supported, each square matrix must be Hermitian.</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(U, S, Vh)``. More details in ivy.svd.</span>
<span class="sd">        Each returned array must have the same floating-point data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.random_normal(shape = (9, 6))</span>
<span class="sd">    &gt;&gt;&gt; U, S, Vh = x.svd()</span>
<span class="sd">    &gt;&gt;&gt; print(U.shape, S.shape, Vh.shape)</span>
<span class="sd">    (9, 9) (6,) (6, 6)</span>
<span class="sd">    With reconstruction from SVD, result is numerically close to x</span>

<span class="sd">    &gt;&gt;&gt; reconstructed_x = ivy.matmul(U[:,:6] * S, Vh)</span>
<span class="sd">    &gt;&gt;&gt; print((reconstructed_x - x &gt; 1e-3).sum())</span>
<span class="sd">    ivy.array(0)</span>

<span class="sd">    &gt;&gt;&gt; U, S, Vh = x.svd(full_matrices = False)</span>
<span class="sd">    &gt;&gt;&gt; print(U.shape, S.shape, Vh.shape)</span>
<span class="sd">    (9, 6) (6,) (6, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="n">compute_uv</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">)</span></div>


<div class="viewcode-block" id="svdvals"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svdvals/svdvals_array.html#ivy.array.array_methods.svdvals">[docs]</a><span class="k">def</span> <span class="nf">svdvals</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">svdvals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="tensorsolve"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/tensorsolve/tensorsolve_array.html#ivy.array.array_methods.tensorsolve">[docs]</a><span class="k">def</span> <span class="nf">tensorsolve</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">tensorsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/trace/trace_array.html#ivy.array.array_methods.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.trace.</span>
<span class="sd">    This method Returns the sum along the specified diagonals of a matrix (or a</span>
<span class="sd">    stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    offset</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive and</span>
<span class="sd">        negative. Defaults to 0.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the traces and whose shape is determined by removing</span>
<span class="sd">        the last two dimensions and storing the traces in the last array dimension.</span>
<span class="sd">        For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,</span>
<span class="sd">        then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where</span>
<span class="sd">        ::</span>
<span class="sd">        out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.trace()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(5.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., 2., 4.], [6., 5., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Array.trace(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="vecdot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vecdot/vecdot_array.html#ivy.array.array_methods.vecdot">[docs]</a><span class="k">def</span> <span class="nf">vecdot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vecdot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="vector_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_norm/vector_norm_array.html#ivy.array.array_methods.vector_norm">[docs]</a><span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ivy.Array instance method variant of ivy.vector_norm.</span>
<span class="sd">        This method computes the vector norm of a vector (or batch of vectors).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        If an integer, ``axis`` specifies the axis (dimension) along which to</span>
<span class="sd">        compute vector norms. If an n-tuple, ``axis`` specifies the axes</span>
<span class="sd">        (dimensions) along which to compute batched vector norms. If ``None``,</span>
<span class="sd">        the vector norm must be computed over all array values (i.e., equivalent</span>
<span class="sd">        to computing the vector norm of a flattened array). Negative indices are</span>
<span class="sd">        also supported. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the axes (dimensions) specified by ``axis`` must be included</span>
<span class="sd">        in the result as singleton dimensions, and, accordingly, the result must be</span>
<span class="sd">        compatible with the input array (see :ref:`broadcasting`). Otherwise, if</span>
<span class="sd">        ``False``, the axes (dimensions) specified by ``axis`` must not be included</span>
<span class="sd">        in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    ord</span>
<span class="sd">        order of the norm. The following mathematical norms are supported:</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | ord              | description                |</span>
<span class="sd">        +==================+============================+</span>
<span class="sd">        | 1                | L1-norm (Manhattan)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | 2                | L2-norm (Euclidean)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | inf              | infinity norm              |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | (int,float &gt;= 1) | p-norm                     |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        The following non-mathematical &quot;norms&quot; are also supported:</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | ord              | description                    |</span>
<span class="sd">        +==================+================================+</span>
<span class="sd">        | 0                | sum(a != 0)                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -inf             | min(abs(a))                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | (int,float &lt; 1)  | sum(abs(a)**ord)**(1./ord)     |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        Default: ``2``.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type that may be used to perform the computation more precisely.</span>
<span class="sd">        The input array ``self`` gets cast to ``dtype`` before the function&#39;s</span>
<span class="sd">        computations.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the vector norms. If ``axis`` is ``None``, the returned</span>
<span class="sd">        array must be a zero-dimensional array containing a vector norm. If ``axis``</span>
<span class="sd">        is a scalar value (``int`` or ``float``), the returned array must have a</span>
<span class="sd">        rank which is one less than the rank of ``self``. If ``axis`` is a</span>
<span class="sd">        ``n``-tuple, the returned array must have a rank which is ``n`` less than</span>
<span class="sd">        the rank of ``self``. The returned array must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.vector_norm()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([3.7416575])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_to_skew_symmetric_matrix/vector_to_skew_symmetric_matrix_array.html#ivy.array.array_methods.vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vector_to_skew_symmetric_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vander/vander_array.html#ivy.array.array_methods.vander">[docs]</a><span class="k">def</span> <span class="nf">vander</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">increasing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.vander.</span>
<span class="sd">    This method Returns the Vandermonde matrix of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        1-D input array.</span>
<span class="sd">    N</span>
<span class="sd">        Number of columns in the output. If N is not specified,</span>
<span class="sd">        a square array is returned (N = len(x))</span>
<span class="sd">    increasing</span>
<span class="sd">        Order of the powers of the columns. If True, the powers increase</span>
<span class="sd">        from left to right, if False (the default) they are reversed.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the Vandermonde matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[  1,   1,   1,   1],</span>
<span class="sd">        [  8,   4,   2,   1],</span>
<span class="sd">        [ 27,   9,   3,   1],</span>
<span class="sd">        [125,  25,   5,   1]]</span>
<span class="sd">        )</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x, N=3)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[ 1,  1,  1],</span>
<span class="sd">        [ 4,  2,  1],</span>
<span class="sd">        [ 9,  3,  1],</span>
<span class="sd">        [25,  5,  1]]</span>
<span class="sd">        )</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 5])</span>
<span class="sd">    &gt;&gt;&gt; ivy.vander(x, N=3, increasing=True)</span>
<span class="sd">    ivy.array(</span>
<span class="sd">    [[ 1,  1,  1],</span>
<span class="sd">        [ 1,  2,  4],</span>
<span class="sd">        [ 1,  3,  9],</span>
<span class="sd">        [ 1,  5, 25]]</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="n">increasing</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.losses</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/cross_entropy/cross_entropy_array.html#ivy.array.array_methods.cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 0, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(1.3862944)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="binary_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/binary_cross_entropy/binary_cross_entropy_array.html#ivy.array.array_methods.binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.binary_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.binary_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.7, 0.8, 0.2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.binary_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0.357, 0.223, 0.223])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">binary_cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sparse_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/sparse_cross_entropy/sparse_cross_entropy_array.html#ivy.array.array_methods.sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">sparse_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sparse_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.sparse_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied. Default:</span>
<span class="sd">        ``1e-7``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0.7, 0.8, 0.2])</span>
<span class="sd">    &gt;&gt;&gt; z = x.sparse_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([0.223, 0.223, 0.357])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sparse_cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.manipulation</span>
<span class="c1"># For Review</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy</span> <span class="kn">import</span> <span class="n">handle_view</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<span class="k">def</span> <span class="nf">view</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/concat/concat_array.html#ivy.array.array_methods.concat">[docs]</a><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.concat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.concat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to join with other arrays ``xs``.</span>
<span class="sd">    xs</span>
<span class="sd">        The other arrays to join with. The arrays must</span>
<span class="sd">        have the same shape, except in the dimension</span>
<span class="sd">        specified by axis.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which the arrays will be joined. If axis is None, arrays</span>
<span class="sd">        must be flattened before concatenation. If axis is negative, axis on</span>
<span class="sd">        which to join arrays is determined by counting from the top. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array containing the concatenated values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/expand_dims/expand_dims_array.html#ivy.array.array_methods.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.expand_dims. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.expand_dims also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        position in the expanded array where a new axis (dimension) of size one</span>
<span class="sd">        will be added. If array ``self`` has the rank of ``N``, the ``axis`` needs</span>
<span class="sd">        to be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of ``self``, but with its dimension added</span>
<span class="sd">        by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-4.7, -2.3, 0.7]) #x.shape-&gt;(3,)</span>
<span class="sd">    &gt;&gt;&gt; y = x.expand_dims() #y.shape-&gt;(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-4.7, -2.3,  0.7]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="flip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/flip/flip_array.html#ivy.array.array_methods.flip">[docs]</a><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.flip. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flip also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which to flip. If axis is None, all</span>
<span class="sd">        input array axes are flipped. If axis is negative, axis</span>
<span class="sd">        is counted from the last dimension. If provided more than</span>
<span class="sd">        one axis, only the specified axes. Default: None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type and</span>
<span class="sd">        shape as``self`` and whose elements, relative</span>
<span class="sd">        to ``self``, are reordered.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([3, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6, 5, 4])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="permute_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/permute_dims/permute_dims_array.html#ivy.array.array_methods.permute_dims">[docs]</a><span class="k">def</span> <span class="nf">permute_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axes</span>
<span class="sd">        tuple containing a permutation of (0, 1, ..., N-1) where N is</span>
<span class="sd">        the number of axes (dimensions) of x.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the axes permutation. The returned array</span>
<span class="sd">        must have the same data type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.permute_dims(axes=(1, 0))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1, 4],</span>
<span class="sd">               [2, 5],</span>
<span class="sd">               [3, 6]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.zeros((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; y = x.permute_dims(axes=(1, 0))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 0.],</span>
<span class="sd">               [0., 0.],</span>
<span class="sd">               [0., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">permute_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../functional/ivy/manipulation/reshape/reshape_array.html#ivy.array.array_methods.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
    <span class="n">allowzero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.reshape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reshape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: ``None``.</span>
<span class="sd">    order</span>
<span class="sd">        Read the elements of the input array using this index order,</span>
<span class="sd">        and place the elements into the reshaped array using this index order.</span>
<span class="sd">        C means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first axis index</span>
<span class="sd">        changing slowest.</span>
<span class="sd">        F means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the C and F options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        Default order is &#39;C&#39;</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type as ``self``</span>
<span class="sd">        and  elements as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.],[3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 1.],</span>
<span class="sd">               [2., 3.],</span>
<span class="sd">               [4., 5.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.],[3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((3,2), order=&#39;F&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 4.],</span>
<span class="sd">               [3., 2.],</span>
<span class="sd">               [1., 5.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">allowzero</span><span class="o">=</span><span class="n">allowzero</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../functional/ivy/manipulation/roll/roll_array.html#ivy.array.array_methods.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positive, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output array having the same data type as ``self`` and whose elements,</span>
<span class="sd">        relative to ``self``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.roll(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 0., 1.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.],</span>
<span class="sd">    ...                [3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.roll(2, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[1., 2., 0.],</span>
<span class="sd">                [4., 5., 3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../functional/ivy/manipulation/squeeze/squeeze_array.html#ivy.array.array_methods.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.squeeze. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.squeeze also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0.],[ 1.]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0., 1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/stack/stack_array.html#ivy.array.array_methods.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.stack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stack also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Array to join with other ``arrays``.</span>
<span class="sd">    arrays</span>
<span class="sd">        Other arrays to join with. Each array must have the same shape.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which the arrays will be joined. More details can be found in</span>
<span class="sd">        the ``ivy.stack`` documentation.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        output array made by joining the input arrays along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([5, 6])</span>
<span class="sd">    &gt;&gt;&gt; print(x.stack(y, axis=1))</span>
<span class="sd">    ivy.array([[1, 5],</span>
<span class="sd">            [2, 6]])</span>

<span class="sd">    &gt;&gt;&gt; x.stack([y],axis=0)</span>
<span class="sd">    ivy.array([[[1, 2]],</span>
<span class="sd">            [[5, 6]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/clip/clip_array.html#ivy.array.array_methods.clip">[docs]</a><span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of self, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip(1., 5.)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 1., 2., 3., 4., 5., 5., 5., 5., 5.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="constant_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/constant_pad/constant_pad_array.html#ivy.array.array_methods.constant_pad">[docs]</a><span class="k">def</span> <span class="nf">constant_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to pad.</span>
<span class="sd">    pad_width</span>
<span class="sd">        Number of values padded to the edges of each axis.</span>
<span class="sd">        Specified as ((before_1, after_1),  (before_N, after_N)), where N</span>
<span class="sd">        is number of axes of x.</span>
<span class="sd">    value</span>
<span class="sd">        The constant value to pad the array with.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Padded array of rank equal to x with shape increased according</span>
<span class="sd">        to pad_width.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.constant_pad(pad_width = [[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 2., 3., 0., 0., 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">constant_pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/repeat/repeat_array.html#ivy.array.array_methods.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.repeat. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.repeat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    repeats</span>
<span class="sd">        The number of repetitions for each element. repeats is broadcast to</span>
<span class="sd">        fit the shape of the given axis.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to repeat values. By default, use the flattened</span>
<span class="sd">        input array, and return a flat output array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The repeated output array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y= x.repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 1., 2., 2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../../functional/ivy/manipulation/split/split_array.html#ivy.array.array_methods.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is ``0``.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A list of sub-arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([4, 6, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x.split()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([4]),ivy.array([6]),ivy.array([5]),ivy.array([3])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../functional/ivy/manipulation/swapaxes/swapaxes_array.html#ivy.array.array_methods.swapaxes">[docs]</a><span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.swap_axes. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis0</span>
<span class="sd">        First axis to be swapped.</span>
<span class="sd">    axis1</span>
<span class="sd">        Second axis to be swapped.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        x with its axes permuted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.swapaxes(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0.],</span>
<span class="sd">               [1.],</span>
<span class="sd">               [2.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.swapaxes(0, 2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[[0, 4],</span>
<span class="sd">                [2, 6]],</span>
<span class="sd">               [[1, 5],</span>
<span class="sd">                [3, 7]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="tile"><a class="viewcode-back" href="../../../functional/ivy/manipulation/tile/tile_array.html#ivy.array.array_methods.tile">[docs]</a><span class="k">def</span> <span class="nf">tile</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.tile. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.tile also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    repeats</span>
<span class="sd">        The number of repetitions of x along each axis.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The tiled output array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0], [1], [2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.tile((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2],</span>
<span class="sd">               [0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2],</span>
<span class="sd">               [0,0],</span>
<span class="sd">               [1,1],</span>
<span class="sd">               [2,2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">repeats</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="unstack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/unstack/unstack_array.html#ivy.array.array_methods.unstack">[docs]</a><span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.unstack. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unstack also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to unstack.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, unpacked along specified dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unstack(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([1, 2]), ivy.array([3, 4])]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unstack(axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [ivy.array([[1],</span>
<span class="sd">            [3]]), ivy.array([[2],</span>
<span class="sd">            [4]])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="zero_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/zero_pad/zero_pad_array.html#ivy.array.array_methods.zero_pad">[docs]</a><span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.zero_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zero_pad also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to pad.</span>
<span class="sd">    pad_width</span>
<span class="sd">        Number of values padded to the edges of each axis. Specified as</span>
<span class="sd">        ((before_1, after_1),  (before_N, after_N)),</span>
<span class="sd">        where N is number of axes of x.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Padded array of rank equal to x with shape increased according to pad_width.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3.,4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.zero_pad(pad_width = [[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0., 0., 1., 2., 3., 4., 5., 6., 0., 0., 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.norms</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="layer_norm"><a class="viewcode-back" href="../../../functional/ivy/norms/layer_norm/layer_norm_array.html#ivy.array.array_methods.layer_norm">[docs]</a><span class="k">def</span> <span class="nf">layer_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">normalized_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">_MIN_BASE</span><span class="p">,</span>
    <span class="n">new_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.layer_norm. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.layer_norm also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array</span>
<span class="sd">    normalized_idxs</span>
<span class="sd">        Indices to apply the normalization to.</span>
<span class="sd">    scale</span>
<span class="sd">        Learnable gamma variables for elementwise post-multiplication,</span>
<span class="sd">        default is ``None``.</span>
<span class="sd">    b</span>
<span class="sd">        Learnable beta variables for elementwise post-addition, default is ``None``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        small constant to add to the denominator, use global ivy._MIN_BASE by</span>
<span class="sd">        default.</span>
<span class="sd">    new_std</span>
<span class="sd">        The standard deviation of the new normalized values. Default is 1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The layer after applying layer normalization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0976, -0.3452,  1.2740],</span>
<span class="sd">    ...                   [0.1047,  0.5886,  1.2732],</span>
<span class="sd">    ...                   [0.7696, -1.7024, -2.2518]])</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm([0, 1], epsilon=0.001,</span>
<span class="sd">    ...                     new_std=1.5, scale=0.5, b=[0.5, 0.02, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    ivy.array([[ 0.826, -0.178, 0.981 ],</span>
<span class="sd">               [ 0.831,  0.421, 0.981 ],</span>
<span class="sd">               [ 1.26 , -1.05 , -1.28 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">layer_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">normalized_idxs</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">new_std</span><span class="o">=</span><span class="n">new_std</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.random</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="random_uniform"><a class="viewcode-back" href="../../../functional/ivy/random/random_uniform/random_uniform_array.html#ivy.array.array_methods.random_uniform">[docs]</a><span class="k">def</span> <span class="nf">random_uniform</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.random_uniform. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.random_uniform also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[9.8, 3.4], [5.8, 7.2]])</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([[9.86, 4.89],</span>
<span class="sd">               [7.06, 7.47]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([[10.1 ,  6.53],</span>
<span class="sd">               [ 7.94,  8.85]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.7, 9.3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([12.8, 14.5])</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(y)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([12.1, 14. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">random_uniform</span><span class="p">(</span>
        <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="random_normal"><a class="viewcode-back" href="../../../functional/ivy/random/random_normal/random_normal_array.html#ivy.array.array_methods.random_normal">[docs]</a><span class="k">def</span> <span class="nf">random_normal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.random_normal. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.random_normal also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[9.8, 3.4], [5.8, 7.2]])</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2)</span>
<span class="sd">    ivy.array([[19.   , -6.44 ],</span>
<span class="sd">               [ 5.72 ,  0.235]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[18.7 , 25.2 ],</span>
<span class="sd">               [27.5 , -3.22]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([[26.6 , 12.1 ],</span>
<span class="sd">               [ 4.56,  5.49]])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([[ 1.02, -1.39],</span>
<span class="sd">               [14.2 , -1.  ]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([[ 7.72, -8.32],</span>
<span class="sd">               [ 4.95, 15.8 ]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.7, 9.3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([12.8, 14.5])</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    ivy.array([-10.8,  12.1])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([ 13. , -26.9])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    ivy.array([14.3  , -0.807])</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    ivy.array([21.3 ,  3.85])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    ivy.array([ 4.32, 42.2 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">random_normal</span><span class="p">(</span>
        <span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multinomial"><a class="viewcode-back" href="../../../functional/ivy/random/multinomial/multinomial_array.html#ivy.array.array_methods.multinomial">[docs]</a><span class="k">def</span> <span class="nf">multinomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.multinomial. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.multinomial also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is ``True``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span>
        <span class="n">population_size</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">probs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="randint"><a class="viewcode-back" href="../../../functional/ivy/random/randint/randint_array.html#ivy.array.array_methods.randint">[docs]</a><span class="k">def</span> <span class="nf">randint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.randint. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.randint also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the half-open interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [0, 5]])</span>
<span class="sd">    &gt;&gt;&gt; x.randint(10)</span>
<span class="sd">    ivy.array([[1, 5],</span>
<span class="sd">               [9, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(8, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([[6, 5],</span>
<span class="sd">               [0, 5]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(9, dtype=&#39;int8&#39;)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">               [7, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(14, device=&#39;cpu&#39;, dtype=&#39;int16&#39;)</span>
<span class="sd">    ivy.array([[6, 5],</span>
<span class="sd">               [0, 5]])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(16, device=&#39;cpu&#39;, dtype=&#39;int64&#39;, out=z)</span>
<span class="sd">    ivy.array([[1, 2],</span>
<span class="sd">               [7, 7]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([23, 25, 98])</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    ivy.array([ 5, 14, 18])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    ivy.array([20, 13, 46])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int32&#39;)</span>
<span class="sd">    ivy.array([ 9, 18, 33])</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;)</span>
<span class="sd">    ivy.array([ 9, 20, 85])</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.ones((3,))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int64&#39;, out=z)</span>
<span class="sd">    ivy.array([20, 13, 46])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../../functional/ivy/random/shuffle/shuffle_array.html#ivy.array.array_methods.shuffle">[docs]</a><span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.shuffle. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.shuffle also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Should have a numeric data type.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array object, shuffled along the first dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([5, 2, 9])</span>
<span class="sd">    &gt;&gt;&gt; y = x.shuffle()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2, 5, 9])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.searching</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../functional/ivy/searching/argmax/argmax_array.html#ivy.array.array_methods.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">select_last_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Deafult: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    dtype</span>
<span class="sd">        Optional data type of the output array.</span>
<span class="sd">    select_last_index</span>
<span class="sd">        If this is set to True, the index corresponding to the</span>
<span class="sd">        last occurrence of the maximum value will be returned.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if axis is None, a zero-dimensional array containing the index of the first</span>
<span class="sd">        occurrence of the maximum value; otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the indices of the maximum values. The returned array must have</span>
<span class="sd">        the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(2)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1., -0., -1.], [-2., 3., 2.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argmax(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0, 1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[4., 0., -1.], [2., -3., 6]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argmax(axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0], [2]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[4., 0., -1.], [2., -3., 6]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argmax(axis=1, dtype=ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; print(y, y.dtype)</span>
<span class="sd">    ivy.array([0, 2]) int64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">select_last_index</span><span class="o">=</span><span class="n">select_last_index</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../functional/ivy/searching/argmin/argmin_array.html#ivy.array.array_methods.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">output_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">select_last_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    output_dtype</span>
<span class="sd">        An optional output_dtype from: int32, int64. Defaults to int64.</span>
<span class="sd">    select_last_index</span>
<span class="sd">        If this is set to True, the index corresponding to the</span>
<span class="sd">        last occurrence of the minimum value will be returned.</span>
<span class="sd">    out</span>
<span class="sd">        if axis is None, a zero-dimensional array containing the index of the first</span>
<span class="sd">        occurrence of the minimum value; otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the indices of the minimum values. The returned array must have</span>
<span class="sd">        the default array index data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the indices of the minimum values across the specified</span>
<span class="sd">        axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argmin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(2)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., -1.],[-2., 1., 2.],[1., -2., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; y= ivy.zeros((1,3), dtype=ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; x.argmin(axis=1, keepdims=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[2],</span>
<span class="sd">               [0],</span>
<span class="sd">               [1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">output_dtype</span><span class="o">=</span><span class="n">output_dtype</span><span class="p">,</span>
        <span class="n">select_last_index</span><span class="o">=</span><span class="n">select_last_index</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../functional/ivy/searching/nonzero/nonzero_array.html#ivy.array.array_methods.nonzero">[docs]</a><span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    as_tuple</span>
<span class="sd">        if True, the output is returned as a tuple of indices, one for each</span>
<span class="sd">        dimension of the input, containing the indices of the true elements in that</span>
<span class="sd">        dimension. If False, the coordinates are returned in a (N, ndim) array,</span>
<span class="sd">        where N is the number of true elements. Default = True.</span>
<span class="sd">    size</span>
<span class="sd">        if specified, the function will return an array of shape (size, ndim).</span>
<span class="sd">        If the number of non-zero elements is fewer than size, the remaining</span>
<span class="sd">        elements will be filled with fill_value. Default = None.</span>
<span class="sd">    fill_value</span>
<span class="sd">        when size is specified and there are fewer than size number of elements,</span>
<span class="sd">        the remaining elements in the output array will be filled with fill_value.</span>
<span class="sd">        Default = 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array containing the indices of the non-zero values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="n">as_tuple</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../functional/ivy/searching/where/where_array.html#ivy.array.array_methods.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Where True, yield x1, otherwise yield x2.</span>
<span class="sd">    x1</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        values from which to choose when condition is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with elements from self where condition is True, and elements from</span>
<span class="sd">        x2 otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; condition = ivy.array([[True, False], [True, True]])</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([[5, 6], [7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; res = x1.where(condition,x2)</span>
<span class="sd">    &gt;&gt;&gt; print(res)</span>
<span class="sd">    ivy.array([[1, 6], [3, 4]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="argwhere"><a class="viewcode-back" href="../../../functional/ivy/searching/argwhere/argwhere_array.html#ivy.array.array_methods.argwhere">[docs]</a><span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argwhere. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argwhere also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array for which indices are desired</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Array` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; res = x.argwhere()</span>
<span class="sd">    &gt;&gt;&gt; print(res)</span>
<span class="sd">    ivy.array([[0, 0], [0, 1], [1, 0], [1, 1]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; res = x.argwhere()</span>
<span class="sd">    &gt;&gt;&gt; print(res)</span>
<span class="sd">    ivy.array([[0, 1], [1, 0], [1, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.set</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="unique_counts"><a class="viewcode-back" href="../../../functional/ivy/set/unique_counts/unique_counts_array.html#ivy.array.array_methods.unique_counts">[docs]</a><span class="k">def</span> <span class="nf">unique_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.unique_counts. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_counts also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. If ``x`` has more than one dimension, the function must flatten</span>
<span class="sd">        ``x`` and return the unique elements of the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>
<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0., 1., 2. , 1. , 0.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_counts()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Results(values=ivy.array([0.,1.,2.]),counts=ivy.array([2,2,1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_counts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="unique_values"><a class="viewcode-back" href="../../../functional/ivy/set/unique_values/unique_values_array.html#ivy.array.array_methods.unique_values">[docs]</a><span class="k">def</span> <span class="nf">unique_values</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="unique_all"><a class="viewcode-back" href="../../../functional/ivy/set/unique_all/unique_all_array.html#ivy.array.array_methods.unique_all">[docs]</a><span class="k">def</span> <span class="nf">unique_all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.unique_all. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_all also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. If ``self`` has more than one dimension, the function</span>
<span class="sd">        must flatten ``self`` and return the unique elements of the</span>
<span class="sd">        flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, indices, inverse_indices, counts)``.</span>
<span class="sd">        The details can be found in the docstring for ivy.unique_all.</span>
<span class="sd">        .. note::</span>
<span class="sd">           The order of unique elements is not specified and may vary between</span>
<span class="sd">           implementations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.randint(0, 10, shape=(2, 2), seed=0)</span>
<span class="sd">    &gt;&gt;&gt; z = x.unique_all()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    Results(values=ivy.array([1, 2, 5, 9]),</span>
<span class="sd">            indices=ivy.array([3, 2, 1, 0]),</span>
<span class="sd">            inverse_indices=ivy.array([[3, 2], [1, 0]]),</span>
<span class="sd">           counts=ivy.array([1, 1, 1, 1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="unique_inverse"><a class="viewcode-back" href="../../../functional/ivy/set/unique_inverse/unique_inverse_array.html#ivy.array.array_methods.unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">unique_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.unique_inverse. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_inverse also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, inverse_indices)`` whose</span>
<span class="sd">        - first element must have the field name ``values`` and must be an array</span>
<span class="sd">          containing the unique elements of ``x``. The array must have the same data</span>
<span class="sd">          type as ``x``.</span>
<span class="sd">        - second element must have the field name ``inverse_indices`` and must be</span>
<span class="sd">          an array containing the indices of ``values`` that reconstruct ``x``.</span>
<span class="sd">          The array must have the same shape as ``x`` and must have the default</span>
<span class="sd">          array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.3,0.4,0.7,0.4,0.2,0.8,0.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_inverse()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    Results(values=ivy.array([0.2, 0.3, 0.4, 0.5, 0.7, 0.8]),</span>
<span class="sd">            inverse_indices=ivy.array([1, 2, 4, 2, 0, 5, 3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">unique_inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>


<span class="c1">#ivy.array.sorting</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">List</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../functional/ivy/sorting/argsort/argsort_array.html#ivy.array.array_methods.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.argsort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.argsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function</span>
<span class="sd">        must sort along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort ``x`` in descending order</span>
<span class="sd">        (by value). If ``False``, the returned indices sort ``x`` in ascending order</span>
<span class="sd">        (by value). Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices</span>
<span class="sd">        must maintain the relative order of ``x`` values</span>
<span class="sd">        which compare as equal. If ``False``, the returned</span>
<span class="sd">        indices may or may not maintain the relative order</span>
<span class="sd">        of ``x`` values which compare as equal (i.e., the</span>
<span class="sd">        relative order of ``x`` values which compare as</span>
<span class="sd">        equal is implementation-dependent). Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have the same</span>
<span class="sd">        shape as input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array of indices. The returned array must have the same shape as ``x``.</span>
<span class="sd">        The returned array must have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 5, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 2, 0])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([9.6, 2.7, 5.2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0, 2, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../functional/ivy/sorting/sort/sort_array.html#ivy.array.array_methods.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([7, 8, 6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([8, 7, 6])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([8.5, 8.2, 7.6])</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([8.5, 8.2, 7.6])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../functional/ivy/sorting/searchsorted/searchsorted_array.html#ivy.array.array_methods.searchsorted">[docs]</a><span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ret_dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.searchsorted.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.searchsorted also applies to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">,</span> <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.array.statistical</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../functional/ivy/statistical/min/min_array.html#ivy.array.array_methods.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the minimum value of the input array ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array. Should have a real-valued data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which minimum values must be computed.</span>
<span class="sd">        By default, the minimum value must be computed over the</span>
<span class="sd">        entire array. If a tuple of integers,minimum values must be</span>
<span class="sd">        computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional boolean, if ``True``, the reduced axes (dimensions)</span>
<span class="sd">        must be included in the result as singleton dimensions, and,</span>
<span class="sd">        accordingly, the result must be compatible with the input</span>
<span class="sd">        array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the</span>
<span class="sd">        result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the minimum value was computed over the entire array, a</span>
<span class="sd">        zero-dimensional array containing the minimum value; otherwise,</span>
<span class="sd">        a non-zero-dimensional array containing the minimum values.</span>
<span class="sd">        The returned array must have the same data type</span>
<span class="sd">        as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.min()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(3.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1, 0, 1], [2, 3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.min(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([-1,  2])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1, 1.1, 2.1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.min(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../functional/ivy/statistical/max/max_array.html#ivy.array.array_methods.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.max. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which maximum values must be computed.</span>
<span class="sd">        By default, the maximum value must be computed over the</span>
<span class="sd">        entire array. If a tuple of integers, maximum values must</span>
<span class="sd">        be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if ``True``, the reduced axes (dimensions) must be included</span>
<span class="sd">        in the result as singleton dimensions, and, accordingly, the</span>
<span class="sd">        result must be compatible with the input array</span>
<span class="sd">        (see :ref:`broadcasting`). Otherwise, if ``False``, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the maximum value was computed over the entire array,</span>
<span class="sd">        a zero-dimensional array containing the maximum value;</span>
<span class="sd">        otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the maximum values. The returned array must</span>
<span class="sd">        have the same data type</span>
<span class="sd">        as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x.max()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(3)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.array([0])</span>
<span class="sd">    &gt;&gt;&gt; y = x.max(out=z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(2)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2], [4, 6, 10]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.max(axis=0, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[4, 6, 10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../functional/ivy/statistical/mean/mean_array.html#ivy.array.array_methods.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.Array instance method variant of ivy.mean. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.mean also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    **Special Cases**</span>
<span class="sd">    Let ``N`` equal the number of elements over which to compute the</span>
<span class="sd">    arithmetic mean.</span>
<span class="sd">    -   If ``N`` is ``0``, the arithmetic mean is ``NaN``.</span>
<span class="sd">    -   If ``x_i`` is ``NaN``, the arithmetic mean is ``NaN`` (i.e., ``NaN``</span>
<span class="sd">        values propagate).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which arithmetic means must be computed. By default,</span>
<span class="sd">        the mean must be computed over the entire array. If a Sequence of</span>
<span class="sd">        integers, arithmetic means must be computed over multiple axes.</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if ``True``, the reduced axes (dimensions) must be included in the</span>
<span class="sd">        result as singleton dimensions, and, accordingly, the result must be</span>
<span class="sd">        compatible with the input array (see :ref:`broadcasting`). Otherwise,</span>
<span class="sd">        if ``False``, the reduced axes (dimensions) must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        array, if the arithmetic mean was computed over the entire array, a</span>
<span class="sd">        zero-dimensional array containing the arithmetic mean; otherwise, a</span>
<span class="sd">        non-zero-dimensional array containing the arithmetic means.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.mean()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(4.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.mean(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0.1, 1.1, 2.1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.mean(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(1.1)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1., 2., 3., 0., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; ivy.mean(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-0.5, 1., 2.], [0.0, 1.1, 2.2]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x.mean(axis=0, keepdims=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[-0.25      ,  1.04999995,  2.0999999 ]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 1., 2.], [3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; ivy.mean(x, axis=1, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1., 4.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../functional/ivy/statistical/var/var_array.html#ivy.array.array_methods.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.var. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.var also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    **Special Cases**</span>
<span class="sd">    Let N equal the number of elements over which to compute the variance.</span>
<span class="sd">    If N - correction is less than or equal to 0, the variance is NaN.</span>
<span class="sd">    If x_i is NaN, the variance is NaN (i.e., NaN values propagate).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which variances must be computed. By default, the</span>
<span class="sd">        variance must be computed over the entire array. If a tuple of integers,</span>
<span class="sd">        variances must be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    correction</span>
<span class="sd">        degrees of freedom adjustment. Setting this parameter to a value other</span>
<span class="sd">        than 0 has the effect of adjusting the divisor during the calculation</span>
<span class="sd">        of the variance according to N-c where N corresponds to the total</span>
<span class="sd">        number of elements over which the variance is computed and c corresponds</span>
<span class="sd">        to the provided degrees of freedom adjustment. When computing the variance</span>
<span class="sd">        of a population, setting this parameter to 0 is the standard choice</span>
<span class="sd">        (i.e., the provided array contains data constituting an entire population).</span>
<span class="sd">        When computing the unbiased sample variance, setting this parameter to 1</span>
<span class="sd">        is the standard choice (i.e., the provided array contains data sampled</span>
<span class="sd">        from a larger population; this is commonly referred to as Bessel&#39;s</span>
<span class="sd">        correction). Default: ``0``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see Broadcasting). Otherwise, if False, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the variance was computed over the entire array, a zero-dimensional array</span>
<span class="sd">        containing the variance; otherwise, a non-zero-dimensional array containing</span>
<span class="sd">        the variances. The returned array must have the same data type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, 8.0]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.var()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(6.6666665)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, .08]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.var(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([6., 6., 4.1])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0.0, 1.0, 2.0],</span>
<span class="sd">    ...                [3.0, 4.0, 5.0],</span>
<span class="sd">    ...                [6.0, 7.0, .08]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; x.var(axis=1, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([0.667, 0.667, 9.33 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../../../functional/ivy/statistical/prod/prod_array.html#ivy.array.array_methods.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.array instance method variant of ivy.prod.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.prod also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which products must be computed. By default,</span>
<span class="sd">        the product must be computed over the entire array. If a</span>
<span class="sd">        tuple of integers, products must be computed over multiple</span>
<span class="sd">        axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if True, the reduced axes (dimensions) must be</span>
<span class="sd">        included in the result as singleton dimensions, and,</span>
<span class="sd">        accordingly, the result must be compatible with the</span>
<span class="sd">        input array (see Broadcasting). Otherwise, if False,</span>
<span class="sd">        the reduced axes (dimensions) must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container, if the product was computed over the entire array,</span>
<span class="sd">        a zero-dimensional array containing the product;</span>
<span class="sd">        otherwise, a non-zero-dimensional array containing the products.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With: class: `ivy.Array` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x.prod()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(6)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 0, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x.prod()</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(0)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.prod(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([60.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.prod(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(2.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1., -2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.prod(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([2., 9.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../functional/ivy/statistical/sum/sum_array.html#ivy.array.array_methods.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../functional/ivy/statistical/std/std_array.html#ivy.array.array_methods.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ivy.array instance method variant of ivy.std.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.std also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which standard deviation must be computed.</span>
<span class="sd">        By default, the product must be computed over the entire array.</span>
<span class="sd">        If a tuple of integers, products must be computed over multiple</span>
<span class="sd">        axes. Default: ``None``.</span>
<span class="sd">    correction</span>
<span class="sd">        degrees of freedom adjustment. Setting this parameter to a</span>
<span class="sd">        value other than ``0`` has the effect of adjusting the</span>
<span class="sd">        divisor during the calculation of the standard deviation</span>
<span class="sd">        according to ``N-c`` where ``N`` corresponds to the total</span>
<span class="sd">        number of elements over which the standard deviation is</span>
<span class="sd">        computed and ``c`` corresponds to the provided degrees of</span>
<span class="sd">        freedom adjustment. When computing the standard deviation</span>
<span class="sd">        of a population, setting this parameter to ``0`` is the</span>
<span class="sd">        standard choice (i.e., the provided array contains data</span>
<span class="sd">        constituting an entire population). When computing</span>
<span class="sd">        the corrected sample standard deviation, setting this</span>
<span class="sd">        parameter to ``1`` is the standard choice (i.e., the</span>
<span class="sd">        provided array contains data sampled from a larger</span>
<span class="sd">        population; this is commonly referred to as Bessel&#39;s</span>
<span class="sd">        correction). Default: ``0``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if True, the reduced axes (dimensions) must be</span>
<span class="sd">        included in the result as singleton dimensions, and,</span>
<span class="sd">        accordingly, the result must be compatible with the</span>
<span class="sd">        input array (see Broadcasting). Otherwise, if False,</span>
<span class="sd">        the reduced axes (dimensions) must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container, if the product was computed over the entire array,</span>
<span class="sd">        a zero-dimensional array containing the product;</span>
<span class="sd">        otherwise, a non-zero-dimensional array containing the products.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With: class: `ivy.Array` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = x.std()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.8164966)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1., 0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; z = x.std(correction=1)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array(1.)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.std(keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[2.]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2., 1.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; x.std(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(0.5)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[-1., -2.], [3., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.std(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1.5, 1. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumsum/cumsum_array.html#ivy.array.array_methods.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cumsum. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cumsum also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array to apply cumsum.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Array which holds the result of applying cumsum at each</span>
<span class="sd">        original array elements along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([ 1,  3,  6, 10, 15])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([2, 6, 4, 10])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=0, exclusive=False, reverse=True, dtype=&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([22., 20., 14., 10.])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 3], [4, 6], [8, 12]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1, exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0, 2],</span>
<span class="sd">               [0, 4],</span>
<span class="sd">               [0, 8]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 5, 2],</span>
<span class="sd">    ...                [4, 3, 0],</span>
<span class="sd">    ...                [4, 8, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=1, exclusive=True, reverse=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ 7,  2,  0],</span>
<span class="sd">               [ 3,  0,  0],</span>
<span class="sd">               [10,  2,  0]])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1, 5, 10], [4, 8, 10], [2, 3, 5]])</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    ivy.array([[ 1,  5, 10],</span>
<span class="sd">               [ 5, 13, 20],</span>
<span class="sd">               [ 7, 16, 25]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumprod/cumprod_array.html#ivy.array.array_methods.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.cumprod. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cumprod also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    axis</span>
<span class="sd">        int, axis along which to take the cumulative product. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        optional bool, whether to exclude the first value of the input array.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumprod from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array. If None, if the default data type</span>
<span class="sd">        corresponding to the data type kind (integer or floating-point) of x</span>
<span class="sd">        has a smaller range of values than the data type of x (e.g., x has data</span>
<span class="sd">        type int64 and the default data type is int32, or x has data type uint64</span>
<span class="sd">        and the default data type is int64), the returned array must have the</span>
<span class="sd">        same data type as x. if x has a floating-point data type, the returned array</span>
<span class="sd">        must have the default floating-point data type. if x has a signed integer</span>
<span class="sd">        data type (e.g., int16), the returned array must have the default integer</span>
<span class="sd">        data type. if x has an unsigned integer data type (e.g., uint16), the</span>
<span class="sd">        returned array must have an unsigned integer data type having the same</span>
<span class="sd">        number of bits as the default integer data type (e.g., if the default</span>
<span class="sd">        integer data type is int32, the returned array must have a uint32 data</span>
<span class="sd">        type). If the data type (either specified or resolved) differs from the</span>
<span class="sd">        data type of x, the input array should be cast to the specified data type</span>
<span class="sd">        before computing the product. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Input array with cumulatively multiplied elements along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumprod()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([1, 2, 6, 24, 120])</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[2, 3], [5, 7], [11, 13]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.zeros((3, 2), dtype=&quot;int32&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x.cumprod(axis=1, exclusive=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[0, 0],</span>
<span class="sd">               [0, 0],</span>
<span class="sd">               [0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/einsum/einsum_array.html#ivy.array.array_methods.einsum">[docs]</a><span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">equation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.einsum. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.einsum also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    equation</span>
<span class="sd">        A str describing the contraction, in the same format as numpy.einsum.</span>
<span class="sd">    operands</span>
<span class="sd">        seq of arrays, the inputs to contract (each one an ivy.Array), whose shapes</span>
<span class="sd">        should be consistent with equation.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array with sums computed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.einsum(&#39;ii&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(12)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; z = x.einsum(&#39;ij -&gt; j&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    ivy.array([ 9, 12, 15])</span>

<span class="sd">    &gt;&gt;&gt; A = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; B = ivy.array([[ 0,  1,  2,  3],</span>
<span class="sd">    ...                [ 4,  5,  6,  7],</span>
<span class="sd">    ...                [ 8,  9, 10, 11]])</span>
<span class="sd">    &gt;&gt;&gt; C = A.einsum(&#39;i,ij-&gt;i&#39;, B)</span>
<span class="sd">    &gt;&gt;&gt; print(C)</span>
<span class="sd">    ivy.array([ 0, 22, 76])</span>

<span class="sd">    &gt;&gt;&gt; A = ivy.array([[1, 1, 1],</span>
<span class="sd">    ...                [2, 2, 2],</span>
<span class="sd">    ...                [5, 5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; B = ivy.array([[0, 1, 0],</span>
<span class="sd">    ...                [1, 1, 0],</span>
<span class="sd">    ...                [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; C = A.einsum(&#39;ij,jk-&gt;ik&#39;, B)</span>
<span class="sd">    &gt;&gt;&gt; print(C)</span>
<span class="sd">    ivy.array([[ 2,  3,  1],</span>
<span class="sd">           [ 4,  6,  2],</span>
<span class="sd">           [10, 15,  5]])</span>

<span class="sd">    &gt;&gt;&gt; A = ivy.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; B = A.einsum(&#39;i-&gt;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(B)</span>
<span class="sd">    ivy.array(45)</span>

<span class="sd">    &gt;&gt;&gt; A = ivy.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; B = ivy.arange(5, 15)</span>
<span class="sd">    &gt;&gt;&gt; C = A.einsum(&#39;i,i-&gt;i&#39;, B)</span>
<span class="sd">    &gt;&gt;&gt; print(C)</span>
<span class="sd">    ivy.array([  0,   6,  14,  24,  36,  50,  66,  84, 104, 126])</span>

<span class="sd">    &gt;&gt;&gt; A = ivy.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; B = ivy.arange(5, 15)</span>
<span class="sd">    &gt;&gt;&gt; C = A.einsum(&#39;i,i-&gt;&#39;, B) # or just use &#39;i,i&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(C)</span>
<span class="sd">    ivy.array(510)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,)</span> <span class="o">+</span> <span class="n">operands</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.utility</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../functional/ivy/utility/all/all_array.html#ivy.array.array_methods.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        array must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned array must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned array must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.all()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(False)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0, 1], [0, 0]], [[1, 2], [3, 4]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.all(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[False, False],</span>
<span class="sd">           [ True,  True]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../functional/ivy/utility/any/any_array.html#ivy.array.array_methods.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Array instance method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        array must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned array must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned array must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x.any()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array(True)</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[[0, 1], [0, 0]], [[1, 2], [3, 4]]])</span>
<span class="sd">    &gt;&gt;&gt; y = x.any(axis=2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    ivy.array([[ True, False],</span>
<span class="sd">           [ True,  True]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1">#ivy.array.wrapping</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>
<span class="n">TO_IGNORE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wraps the function called `function_name`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function_name</span>
<span class="sd">        the name of the function e.g. &quot;abs&quot;, &quot;mean&quot; etc.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_function</span>
<span class="sd">        the wrapped function.</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ivy.set_backend(&quot;torch&quot;)</span>
<span class="sd">    &gt;&gt;&gt; from ivy.array.wrapping import _wrap_function</span>
<span class="sd">    &gt;&gt;&gt; absolute = _wrap_function(&quot;abs&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1])</span>
<span class="sd">    &gt;&gt;&gt; print(absolute(x))</span>
<span class="sd">    ivy.array([1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the data of the current array from which the instance function is invoked</span>
<span class="sd">        as the first arg parameter or kwarg parameter. Return the new function with</span>
<span class="sd">        the name function_name and the new args variable or kwargs as the new inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span>
        <span class="c1"># gives us the position and name of the array argument</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">array_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">]</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">]</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_function</span>



<span class="k">def</span> <span class="nf">add_ivy_array_instance_methods</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">modules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">],</span> <span class="n">to_ignore</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">()</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Loop over all ivy modules such as activations, general, etc. and add</span>
<span class="sd">    the module functions to ivy arrays as instance methods using _wrap_function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls</span>
<span class="sd">        the class we want to add the instance methods to.</span>
<span class="sd">    modules</span>
<span class="sd">        the modules to loop over: activations, general etc.</span>
<span class="sd">    to_ignore</span>
<span class="sd">        any items we don&#39;t want to add an instance method for.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    As shown, `add_ivy_array_instance_methods` adds all the appropriate functions from</span>
<span class="sd">    the activations module as instance methods to our toy `ArrayExample` class:</span>
<span class="sd">    &gt;&gt;&gt; from ivy.functional.ivy import activations</span>
<span class="sd">    &gt;&gt;&gt; class ArrayExample:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; ivy.add_ivy_array_instance_methods(ArrayExample, [activations])</span>
<span class="sd">    &gt;&gt;&gt; print(hasattr(ArrayExample, &quot;relu&quot;), hasattr(ArrayExample, &quot;softmax&quot;))</span>
<span class="sd">    True True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


</pre></div>

            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  <nav class="bd-links" id="bd-docs-nav" aria-label="Section navigation">
  <p class="bd-links__title" role="heading" aria-level="1">
    Section Navigation
  </p>
  <div class="bd-toc-item navbar-nav">
    
  </div>
</nav>
</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2020-2023, Ivy Team.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  </body>
</html>